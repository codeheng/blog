

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/resizeApi.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yiheng">
  <meta name="keywords" content="">
  <title>c语言学习 - 寻归往</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Yiheng.blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/article_img.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-07-17 19:59" pubdate>
      2021年7月17日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      140
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">c语言学习</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="C语言再学习！"><a href="#C语言再学习！" class="headerlink" title="C语言再学习！"></a>C语言再学习！</h2><p>利用Visual Studio </p>
<p>vs –debug 将监视窗口、调用堆栈、以及内存变化调整出来！</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>错误：编译错误&amp;链接错误</p>
<p>​    编译错误：双击就可以定位到第几行</p>
<p>​    链接错误：库函数可能写错了！看对应函数符号</p>
</blockquote>
<p>​    </p>
<p>编辑main.c —&gt; 编译main.obj —&gt;和库函数进行链接—&gt;main.exe—-&gt;执行</p>
<p><strong>写代码——增量编写法，写一点进行测试测试</strong>，<strong>保证正确</strong>，<strong>再继续写</strong></p>
<h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>​    1. <strong>基本类型</strong></p>
<ul>
<li>整型 int</li>
</ul>
<p>​            表示范围：-2^31 到 2^31 - 1</p>
<p>​                short 表示范围：-2 ^ 15 到 2 ^ 15 - 1</p>
<p>​                long 32位机器(4个字节)，64位机器(8个字节)  -2 ^ 63 到 -2 ^63 - 1</p>
<p>​                unsigned int 变化范围： 0 到 2^32 - 1</p>
<ul>
<li>字符型 char</li>
</ul>
<p>​                    \n  光标到下一行行首</p>
<p>​                    \r   光标回到当前行行首</p>
<p>​                    \b  向前退一格</p>
<ul>
<li>实型(浮点型)：</li>
</ul>
<p>​                单精度实型float(四个字节)；  有效数字：6-7位</p>
<p>​                双精度double(八个字节)       有效数字：15-16位</p>
<p>​    2.<strong>构造类型</strong></p>
<blockquote>
<p>数组类型[]</p>
<p>结构类型struct</p>
<p>联合类型union</p>
<p>枚举类型 enum</p>
</blockquote>
<p>​    3.*<em>指针类型 **</em></p>
<ol start="4">
<li><strong>空类型(无值类) ：void</strong></li>
</ol>
<p>常量：例如 100，3.14，‘a’，“abc”</p>
<p>变量：代表内存中具有特定属性的一个存储单元，用来存放数据，这就是变量的值，<strong>在程序运行期间，这些值得程序的执行过程是可以改变的。</strong></p>
<p>符号常量：#define SUN 7</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/3.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/4.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>熟悉进制的转换</p>
</blockquote>
<p>vs采用小端：低位在前，高位在后</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5.png" srcset="/img/loading.gif"></p>
<p>补码：按位取反再+1</p>
<h3 id="二、scanf原理"><a href="#二、scanf原理" class="headerlink" title="二、scanf原理"></a>二、scanf原理</h3><blockquote>
<p>输入读取接口：scanf，getchar</p>
<p>标准输出接口：printf，putchar</p>
</blockquote>
<p>1、标准输入缓冲区原理</p>
<pre><code class="hljs C"><span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">char</span> c;
<span class="hljs-comment">//用户输入</span>
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; i = %d\n&quot;</span>,i);<span class="hljs-comment">//正常打印了</span>

<span class="hljs-comment">//清除缓冲区  ps:vs2013以上版本需要rewind(stdin)  </span>
fflush(<span class="hljs-built_in">stdin</span>); <span class="hljs-comment">//如果没有这一句，则c不会等待用户输入，而是直接显示出来c = </span>

<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c); 
<span class="hljs-comment">//为何？因为输入一个数之后，按回车了，\n在缓冲区里面，读取到了 \n 所以不会等待用户输入 </span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>,c); </code></pre>

<p><strong>当使用%d的时候，会忽略空格 和 \n</strong></p>
<p>scanf匹配原理：即是匹配到什么之后，删除什么，没有匹配的仍在缓冲区中</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5_1.png" srcset="/img/loading.gif"></p>
<p>2、scanf循环读取</p>
<p><code>while( scanf(&quot;%d&quot;,&amp;i) != EOF )</code></p>
<p>进行完善</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> i,ret
<span class="hljs-comment">//即便输入的不是整型，也可以提供用户继续输入</span>
<span class="hljs-keyword">while</span> ( fflush(<span class="hljs-built_in">stdin</span>),(ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i)) != EOF ) </code></pre>

<p>3、混合读取 </p>
<pre><code class="hljs c"><span class="hljs-comment">//  %d %c中间加一个空格</span>
<span class="hljs-comment">//即在读取字符时，在字符前面加上空格</span>
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c%f%lf&quot;</span>,&amp;i,&amp;c,&amp;f,&amp;d);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %5.2f %f &quot;</span>,i,c,f,d);</code></pre>



<p>getchar() 和 putchar()</p>
<pre><code class="hljs c"><span class="hljs-keyword">char</span> c;
c = getchar();
<span class="hljs-built_in">putchar</span>(c);
c = getchar();<span class="hljs-comment">//并不会再次阻塞，等待继续输入，而是直接结束，因为缓冲区里有\n,读取到直接退出了</span>
<span class="hljs-built_in">putchar</span>(c);</code></pre>



<p>printf()利用占位符进行对其</p>
<pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-number">21</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;Yiheng&quot;</span>,<span class="hljs-number">5</span>);</code></pre>



<h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h3><p>*<em>1、算术运算符（ + - * / %）*</em></p>
<p><strong>2、关系运算符( &gt; ,&lt;, ==, &gt;= ,&lt;= , !=)</strong></p>
<p><strong>3、逻辑运算符( !,&amp;&amp;,|| )</strong></p>
<p><strong>4、位运算符( &lt;&lt;, &gt;&gt;, ~, | , ^ , &amp;)</strong></p>
<p>​            左移&lt;&lt; : 高位丢弃，低位补0，<strong>相当于乘2</strong>，但效率比乘法高</p>
<p>​            右移&gt;&gt;：**相当于除2 **  正数(unsigned)的话，低位丢弃，高位补0(直接除2);负数的话，低位丢弃，高位补1(减1再除2)</p>
<p><strong>5、赋值运算符 （ = 及其扩展赋值运算符 ）</strong></p>
<p><strong>6、条件运算符( ? : )  即三目运算符</strong></p>
<p><strong>7、逗号运算符 ( , )</strong></p>
<p>*<em>8、指针运算符 （ * 和 &amp;）*</em></p>
<p><strong>9、求字节数运算符（ sizeof() )</strong></p>
<p><strong>10、强制类型转换运算符 （ （类型） ）</strong></p>
<p><strong>11、分量运算符 (  .  -&gt; )</strong></p>
<p><strong>12、下标运算符 （ [ ]  ）</strong></p>
<p><strong>13、其他，如函数调用运算符:()</strong></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6_1.png" srcset="/img/loading.gif"></p>
<p><strong>算术运算符优先级高于关系运算符</strong></p>
<p><strong>关系运算符高于逻辑与和逻辑或</strong></p>
<p>a = 5  ==&gt;范围 -6到5</p>
<p> 0000 0101</p>
<p>1111 1010 ==&gt; 0000 0110 ==&gt; -6 </p>
<p>1111 1011 ==&gt;0000 0101 ==&gt; -5</p>
<p>ps:若要拿到任意一个数的最低位为1的那个数，不利用循环如何实现？<br>     1、若是循环，则此数字每一位和1进行&amp;运算，若为0，则1&lt;&lt;1，再进行下一位比较，为1则找到了<br>        2、利用 i &amp; -i = 最终低位为1的那个数字 ===&gt;该数与其对应补码进行&amp;操作</p>
<p>异或^：</p>
<p>​    <strong>任何数与自身异或为 0</strong> </p>
<p>​    <strong>任何数与0异或为其自身</strong></p>
<p>可利用异或对两个数进行交换，而不使用中间变量</p>
<p>交换两个数，三种方法</p>
<pre><code class="hljs c"><span class="hljs-comment">//1、利用异或，但必须有两个空间，不会出现溢出</span>
a = <span class="hljs-number">5</span>,b = <span class="hljs-number">4</span>;
a = a ^ b;
b = a ^ b; <span class="hljs-comment">// 此时即为 b = (a^b) ^b = a</span>
a = a ^ b; <span class="hljs-comment">//此时 a = (a ^ b ) ^ a = b</span></code></pre>

<pre><code class="hljs c"><span class="hljs-comment">//2、利用数学运算对其进行交换,可能会溢出</span>
a = a + b;
b = a - b;<span class="hljs-comment">// b = (a + b) - b = a </span>
a = a - b;<span class="hljs-comment">// a = (a + b) - a = b</span></code></pre>

<pre><code class="hljs c"><span class="hljs-comment">//3、传统的，利用另一个变量temp</span>
<span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">7</span>,temp;
temp = a;
a = b;
b = temp;</code></pre>

<p>例题：若数组中 101个数，50个数出现两次，1个数出现一次，找出出现一次的这个数的值？**(经典)**</p>
<p>对数组的的数进行异或操作</p>
<pre><code class="hljs C"><span class="hljs-comment">//简化版本</span>
<span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;
    <span class="hljs-keyword">int</span> i ,result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); i++) &#123;
        result ^= arr[i];
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find value = %d\n&quot;</span>,result); <span class="hljs-comment">//最终输出为7</span>
</code></pre>



<p>自增和自减</p>
<p><code>j = i-- &gt; -2; //等价于j = i &gt; -2;i --</code></p>
<h3 id="四、选择，循环和数组"><a href="#四、选择，循环和数组" class="headerlink" title="四、选择，循环和数组"></a>四、选择，循环和数组</h3><p>1、if …else</p>
<p>2、switch</p>
<pre><code class="hljs angelscript"><span class="hljs-comment">// ( )里面不可以是浮点型表达式 </span>
<span class="hljs-keyword">switch</span>()&#123;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">break</span> 
    dafault:<span class="hljs-keyword">break</span>;
&#125;
</code></pre>

<p>3、循环</p>
<p>（1）goto  学校老师讲的不用掌握goto是错误的，<strong>goto才是循环的本质</strong>，对应于汇编中的jmp跳转 </p>
<pre><code class="hljs C"><span class="hljs-comment">//求前100个数字的和</span>
<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;
label:
    sum += i;
    i++; 
    <span class="hljs-comment">//需要进行判断，小于100才goto，不然一直循环</span>
    <span class="hljs-keyword">if</span>( i &lt;= <span class="hljs-number">100</span>)&#123;
        <span class="hljs-keyword">goto</span> label;
    &#125;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);
</code></pre>

<p>（2） while  和  do ….while </p>
<p>（3） for</p>
<p>4、数组：具有<strong>相同数据</strong>类型的数据的<strong>有序</strong>集合</p>
<p>(1)、一维数组</p>
<pre><code class="hljs C"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
    <span class="hljs-comment">//定义数组的时候，必须初始化</span>
    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//arr[0]到arr[4]</span>
    <span class="hljs-keyword">sizeof</span>(arr) <span class="hljs-comment">//大小为20个字节 5*4</span>
    <span class="hljs-comment">//访问越界，提示stack around arr 代表栈空间访问越界</span>
    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">6</span>;
    arr[<span class="hljs-number">6</span>] = <span class="hljs-number">7</span>;
    arr[<span class="hljs-number">7</span>] = <span class="hljs-number">8</span>;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<span class="hljs-comment">//此时i变为8了，在vs中</span>
</code></pre>

<p>访问越界如图所示</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/7.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/8.png" srcset="/img/loading.gif"></p>
<p>当作为函数参数传递时，是传递的数组的起始地址，<strong>即数组名存的是数组的起始地址</strong>，不可以修改</p>
<p>C<strong>语言函数调用是值传递</strong></p>
<p>(2)、二维数组</p>
<pre><code class="hljs markdown">int a[<span class="hljs-string">3</span>][<span class="hljs-symbol">4</span>] = &#123;1,3,5,7,2,4,6,8,9,11,13,15&#125;;//范围a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]到a[<span class="hljs-string">2</span>][<span class="hljs-symbol">3</span>]
sizeof(a) //48个字节
sizeof(a[0])  //16个字节 
sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">1</span>]) //4个字节
</code></pre>

<p>(3)、字符数组</p>
<p>利用%s时scanf(“%s”,d)， 如果输出的有空格，则停止向后读</p>
<pre><code class="hljs C"><span class="hljs-comment">//这样打印，会出现乱码，因为利用%s打印，遇到\0会停下，并没有存地方\0标志，所以会在内存中打印至\0为止</span>
<span class="hljs-comment">//  \0代表结束标志 而\0的值即为0</span>
<span class="hljs-keyword">char</span> c[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,c);

<span class="hljs-comment">//建议，要有空间保存\0，即长度比字符长度大1</span>
<span class="hljs-keyword">char</span> c[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;ABCDEF&quot;</span>;

<span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;
<span class="hljs-keyword">sizeof</span>(c); <span class="hljs-comment">// 为10</span>
<span class="hljs-built_in">strlen</span>(c); <span class="hljs-comment">//是5</span>
</code></pre>

<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/9.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/10.png" srcset="/img/loading.gif"></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/11.png" srcset="/img/loading.gif">当利用第二种方法存字符数组时，会在最后添上\0</p>
<pre><code class="hljs C">gets(c);<span class="hljs-comment">//会在最后添上\0，不会把\n读取到内存中   类似于scanf 也可能不安全，会访问越界</span>

 <span class="hljs-built_in">puts</span>(c)<span class="hljs-comment">//会在最后打印一个\n</span>
 <span class="hljs-comment">//等价于printf(&quot;%s\n&quot;,c);</span>

 <span class="hljs-comment">//循环输入字符串,并打印。按ctrl+z则会退出</span>
 <span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>];
 <span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span> ) &#123;
     <span class="hljs-built_in">puts</span>(c);
 &#125;

 <span class="hljs-comment">//安全，不会访问越界，当＞sizeof(c)时，系统不允许输入</span>
 <span class="hljs-comment">//并且会把\n读到内存中</span>
 fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>);
</code></pre>

<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/12.png" srcset="/img/loading.gif">例如：输入hello，fgets()会在后面增加\0和\0</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13.png" srcset="/img/loading.gif">例：gets()情况，输入hello之后</p>
<p>str<strong>系列字符串操作函数</strong>   (在头文件#include&lt;string.h&gt;中)</p>
<pre><code class="hljs C"><span class="hljs-comment">//如果去除fget()后的最后一个\n呐？</span>
<span class="hljs-comment">//可以利用strlen获取最后的位置，然后替换成\0</span>
<span class="hljs-comment">//打印输出，并计算长度(去除\n)</span>
<span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>];
<span class="hljs-keyword">size_t</span> len;
<span class="hljs-keyword">while</span>( fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;
    c[ <span class="hljs-built_in">strlen</span>(c) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//进行替换</span>
    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输入什么则进行输出什么</span>
    len = <span class="hljs-built_in">strlen</span>(c);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);<span class="hljs-comment">//输出输入的长度</span>
&#125;
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//复制字符串 不能用于整型数组</span>
<span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;hello&quot;</span>;
<span class="hljs-keyword">char</span> d[<span class="hljs-number">50</span>];<span class="hljs-comment">//如果过小，会访问越界</span>
<span class="hljs-built_in">strcpy</span>(d,c);<span class="hljs-comment">//利用此接口进行赋值，会把c中\0读到d中，之后结束</span>
<span class="hljs-built_in">puts</span>(d);

<span class="hljs-comment">//将字符进行拼接！</span>
<span class="hljs-built_in">strcat</span>(d,<span class="hljs-string">&quot;Yiheng&quot;</span>); <span class="hljs-comment">//最后会有\0</span>
</code></pre>

<p>strn<strong>系列字符串造作函数</strong></p>
<pre><code class="hljs C"><span class="hljs-comment">//strncpy</span>

<span class="hljs-keyword">int</span> c[<span class="hljs-number">50</span>];
<span class="hljs-keyword">int</span> d[<span class="hljs-number">50</span>];
<span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span>) &#123;
<span class="hljs-comment">//需要另加一句，保证要拷贝到的数组中元素为0</span>
    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));<span class="hljs-comment">//内置接口，此时将不会出现错误</span>
    <span class="hljs-built_in">strncpy</span>(d,c,<span class="hljs-number">7</span>);<span class="hljs-comment">//将c中的前7个字符拷贝到d中，不会有\0结束符，知道内存中遇到\0才结束输出</span>
    <span class="hljs-built_in">puts</span>(d);
&#125;

<span class="hljs-built_in">strncmp</span>(d,<span class="hljs-string">&quot;李宁&quot;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//判断前二个字节是否相等，即d中输入是否和‘李’相等(汉字占两个字节</span>

<span class="hljs-built_in">strncat</span>(d,<span class="hljs-string">&quot;牛牛牛&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//会部分拼接，把‘牛’拼到d后面</span>
</code></pre>

<pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;
<span class="hljs-keyword">int</span> b[<span class="hljs-number">5</span>];
<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//可以进行内存拷贝，不可以用strcpy()，因为遇到\0则停止拷贝</span>
</code></pre>

<h3 id="五、指针"><a href="#五、指针" class="headerlink" title="五、指针"></a>五、指针</h3><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
<span class="hljs-comment">//通过指针间接访问变量i</span>
<span class="hljs-keyword">int</span> *p = &amp;i;<span class="hljs-comment">//把i的地址保存起来，初始化必须是一个变量的取地址</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<span class="hljs-comment">//取保存起来地址所对应的值</span>
</code></pre>

<p>1、指针的使用场景：<strong>传递和偏移</strong></p>
<p>指针的传递：子函数要改变主函数的变量</p>
<pre><code class="hljs C"><span class="hljs-comment">//函数调用值传递</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *i)</span></span>&#123;
    *i /= <span class="hljs-number">2</span>;
&#125;
main() &#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
    change(&amp;i)<span class="hljs-comment">//这是会改变i的值，应该是传递的保存i的地址</span>
&#125;
</code></pre>

<p>指针的偏移(服务于数组)：p+1，是偏移的基类型的大小–&gt;sizeof(int)</p>
<pre><code class="hljs C"><span class="hljs-comment">//借助指针将数组元素输出</span>
<span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;
<span class="hljs-keyword">int</span> *p = &amp;a;<span class="hljs-comment">//数组名保存了数组的起始地址</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>,*(p + i)); <span class="hljs-comment">//其实a[i] &lt;==&gt; *(a+i)</span>
&#125;
</code></pre>

<p>2、指针和自增自减操作符</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;
<span class="hljs-keyword">int</span> *p = a;
<span class="hljs-keyword">int</span> j;

j = *p++;<span class="hljs-comment">//==&gt;j = *p ,p ++;</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 2 7</span>

j = (*p)++ <span class="hljs-comment">//===&gt; j = *p,(*p)++;</span>
<span class="hljs-comment">//上面可改成j  = p[0] ++ 两者等价，不会有影响</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 7 8</span>
<span class="hljs-comment">//通过上述(*p)++,把数组中第二个元素7变成了8</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[1] = %d\n&quot;</span>,a[<span class="hljs-number">1</span>]); <span class="hljs-comment">//8</span>
</code></pre>

<p>3、指针与一维数组</p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>&#123;
    *p = <span class="hljs-string">&#x27;H&#x27;</span>;
    p[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;E&#x27;</span>;
    *(p+<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;L&#x27;</span>;
&#125;
main()&#123;
    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;hello&quot;</span>;
    change(c);
    <span class="hljs-built_in">puts</span>(c) <span class="hljs-comment">//输出  HELlo</span>
&#125;
</code></pre>

<p> (1)动态内存申请</p>
<pre><code class="hljs C"><span class="hljs-keyword">int</span> needSize;
<span class="hljs-keyword">char</span> *pStart;
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;needStart);
pStart = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(needSize);<span class="hljs-comment">//使用malloc动态申请堆空间</span>
<span class="hljs-comment">//向申请的空间填入数据</span>
<span class="hljs-built_in">strcpy</span>(pStart,<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-built_in">puts</span>(pStart);
<span class="hljs-built_in">free</span>(pStart);<span class="hljs-comment">//最后用完进行释放</span>
<span class="hljs-comment">//释放完之后要将此指针赋值为NULL,不然就成了野指针</span>
pStart = <span class="hljs-literal">NULL</span>;
</code></pre>

<p>（2）野指针</p>
<pre><code class="hljs C"><span class="hljs-keyword">int</span> *p1,*p2,*p3;
p1 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
*p1 = <span class="hljs-number">1</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p1 = %d\n&quot;</span>,*p1);<span class="hljs-comment">//1</span>

p2 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
*p2 = <span class="hljs-number">2</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p2 = %d\n&quot;</span>,*p2);<span class="hljs-comment">//2</span>
<span class="hljs-built_in">free</span>(p2);
<span class="hljs-comment">//要加上p2 = NULL</span>
p2 = <span class="hljs-literal">NULL</span>;

p3 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
*p3 = <span class="hljs-number">3</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//3</span>

*p2 = <span class="hljs-number">100</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//不加p2 = NULL ，会输出100</span>
<span class="hljs-comment">//由于p2被free了，但是后来p3申请空间不知道，p3申请会用p2释放的空间。之后又用了p2所以造成p3出现错误</span>
<span class="hljs-comment">//在free后面添加p2 = NULL;，如果再次使用p2则会产生错误为何</span>
</code></pre>



<p>(3)都是内存空间，为何分栈和堆？</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13_1.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs awk"><span class="hljs-regexp">//</span>windows中栈空间有上限的，单个函数<span class="hljs-number">1</span>M，如果超过，则会Stack Overflow
<span class="hljs-regexp">//</span>函数递归调用也有一个上限

<span class="hljs-comment">#define N 500000</span>
int a[N]<span class="hljs-regexp">//</span>执行到这里则会出现栈溢出
</code></pre>

<p>(4)栈空间和堆空间的差异</p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printStack</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;i am stack&quot;</span>;
    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输出i am stack</span>
    <span class="hljs-keyword">return</span> c;
&#125;

<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printMalloc</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;i am malloc&quot;</span>);
    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出i am malloc</span>
    <span class="hljs-keyword">return</span> p;
 &#125;
main() &#123;
    <span class="hljs-keyword">char</span> *p;
    p = printStack();
    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//会出现乱码</span>
    <span class="hljs-comment">//因为函数执行进行压栈，执行完之后弹栈</span>
    <span class="hljs-comment">//之后执行puts的时候把原来函数的栈空间给占了</span>
    <span class="hljs-comment">//应该怎么办，利用堆！</span>
    p = printMalloc();
    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出 i am malloc</span>
    <span class="hljs-built_in">free</span>(p);
    p = <span class="hljs-literal">NULL</span>;
&#125;
</code></pre>

<p>(5)realloc动态扩容</p>
<pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 20</span>

<span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(MAX);
<span class="hljs-keyword">char</span> c;
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,max = MAX;
<span class="hljs-comment">//对其进行循环输入字符</span>
<span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c) != EOF ) &#123;
<span class="hljs-comment">//因为最后要放&#x27;\0&#x27;，故是max -1</span>
    <span class="hljs-keyword">if</span>( i == max - <span class="hljs-number">1</span>) &#123;
        p = (<span class="hljs-keyword">char</span> *)reallloc(p, max * <span class="hljs-number">2</span>);<span class="hljs-comment">//如果达到最后，利用realloc进行扩容</span>
    &#125;
    p[i] = c;<span class="hljs-comment">//每次输入的保存起来</span>
    i++;
&#125;
p[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//将最后弄成结束标志，按下ctrl+z则会显示结果</span>
<span class="hljs-built_in">puts</span>(p);
<span class="hljs-built_in">free</span>(p);
p = <span class="hljs-literal">NULL</span>;
</code></pre>

<p>（6）字符指针与字符数组初始化</p>
<p>申请完空间之后，为何<code>strcpy(p,&quot;i am malloc&quot;);</code>而不是 <code>p = &quot;i am malloc&quot;;</code></p>
<pre><code class="hljs C"><span class="hljs-keyword">char</span> *p = <span class="hljs-string">&quot;helloworld&quot;</span>; <span class="hljs-comment">//字符串存放在数据段的字符串常量区，是不可以修改的！p指向了首地址</span>
<span class="hljs-keyword">char</span> c[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-comment">//这个是在代码段，可以修改</span>
c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 正确！ </span>
p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 错误！！</span>
p = <span class="hljs-string">&quot;how are you&quot;</span><span class="hljs-comment">//正确</span>
c = <span class="hljs-string">&quot;how are you!&quot;</span><span class="hljs-comment">//错误！！因为c是起始地址，是只读的</span>
<span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;helloworld!&quot;</span>)<span class="hljs-comment">//错误，因为strcpy会对p[0]=&#x27;h&#x27;进行逐一赋值，但p空间此时不可以修改</span>
<span class="hljs-comment">//strcpy必须是可读可写的，即malloc申请的堆空间,或让p指向堆空间，指向可以修改的空间</span>
<span class="hljs-comment">//例如：</span>
p = c;
<span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;Yiheng&quot;</span>);<span class="hljs-comment">//此时正确</span>
</code></pre>

<p>(7)数组指针（服务于二维数组）</p>
<pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> b[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;
<span class="hljs-comment">//b数组名是保存了数组的起始地址 </span>
<span class="hljs-comment">//&amp;b也是保存了数组的起始地址，但&amp;b类型是数组指针，而b里面的类型为整型指针</span>
<span class="hljs-comment">//b+1 偏移的是数组类型的一个字节的大小，例如b + 1之后所对应地址的那个变量的值为2</span>
<span class="hljs-comment">//&amp;b+1 偏移的是整个数组字节大小，此时将跑到数组外面那个地址区域</span>
<span class="hljs-built_in">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;
<span class="hljs-comment">//a+1 指向2的起始地址</span>
<span class="hljs-comment">//&amp;a+1 指向15之后那个地方的地址(相当于&amp;a是一个二维数组指针,偏移整个数组的大小)</span>
</code></pre>

<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[][<span class="hljs-number">4</span>],<span class="hljs-keyword">int</span> row)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i,j;
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; row; i ++) &#123;
         <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-keyword">sizeof</span>(*p) /<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> );j++)&#123;
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*(*(p+i)+j));
             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,p[i][j]);</span>
             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,*(p[i]+ j));</span>
         &#125;
     &#125;
&#125;
main() &#123;
    <span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;
    <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>];<span class="hljs-comment">//数组指针，指向一个长度为4的一维数组</span>
    p = a;<span class="hljs-comment">//不会报错</span>
    print(p,<span class="hljs-number">3</span>);
&#125; 

<span class="hljs-comment">//动态二维数组</span>
p = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">4</span>])<span class="hljs-built_in">malloc</span>( <span class="hljs-number">16</span> * <span class="hljs-number">100</span>);
</code></pre>

<p> (7)二级指针  (<strong>只服务于一级指针的传递和偏移</strong>)</p>
<p>子函数内需要修改主函数某个一级指针的值，需要二级指针</p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p1,<span class="hljs-keyword">int</span> **p2)</span> </span>&#123;
    *p1 = *p2
&#125;
main() &#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>,j = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">int</span> *p1 = &amp;i,*p2 = &amp;j;<span class="hljs-comment">//此时*p1 = 10,*p2 = 5;</span>
    <span class="hljs-comment">//想改变*p1 = 5,*p2 = 10 </span>
    change(&amp;p1,&amp;p2);<span class="hljs-comment">//此时利用二级指针成了交换</span>
&#125;
</code></pre>

<p>二级指针的初始化必须是某个一级指针变量的取地址</p>
<pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">10</span>])</span> </span>&#123;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;
        pust(p[i]);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPointerArr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;
        pust(p[i]);
    &#125;
&#125;
main()&#123;
    <span class="hljs-keyword">char</span> b[N][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&quot;lilei&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;zhousi&quot;</span>&#125;;
    <span class="hljs-keyword">char</span> **p = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * N);

    print(b);<span class="hljs-comment">//打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>
    printPointerArr(b);<span class="hljs-comment">//同样打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>
&#125;

</code></pre>

<p>(8)函数指针</p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am b func&quot;</span>);
&#125;
main() &#123;
    <span class="hljs-keyword">void</span> (*p) () <span class="hljs-comment">//p为函数指针</span>
    p = b;<span class="hljs-comment">//初始化必须为某个函数的函数名</span>
    p();<span class="hljs-comment">//打印i am b func</span>
&#125;

</code></pre>

<h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p> <strong>1、函数声明，定义，及调用</strong></p>
<p>​    通常将程序内容分别放在若干个源文件中，再由若干原程序文件组成一个C程序，便于<strong>分别编写，分别编译，提高调试效率</strong></p>
<p>点击’运行’即代表增量编译，如果之前运行过，则在运行的基础上进行编译(耗时很短)</p>
<p>右键–&gt;重新生成 则代表重新编译一次(但意义并不大，运行也慢)</p>
<p>函数不能嵌套定义</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14_1.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs C"><span class="hljs-comment">//main.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//函数调用</span>
    printStar();
    printMessage();
&#125;
<span class="hljs-comment">//func.h</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-comment">//函数声明,作用：对函数的形参和返回值类型进行检查</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;


<span class="hljs-comment">//fun.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span>
<span class="hljs-comment">//函数定义</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****&quot;</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;how are you?&quot;</span>);
&#125;
</code></pre>

<p>2、函数的分类</p>
<blockquote>
<p>(1)标准函数，即库函数，系统提供的</p>
<p>(2) 用户自己定义的函数</p>
</blockquote>
<p>不同函数之间传递数据：</p>
<p>​    参数：通过形参和实参(调用完，空间则释放掉)</p>
<p>​    返回值：用return语句返回计算结果</p>
<p>​    全局变量：外部变量(不好，因为会一直占用着空间，也导致阅读困难)</p>
<p>3、函数的嵌套调用</p>
<pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span>
<span class="hljs-comment">//嵌套函数直接回到主函数，main调用a，a调用b，b直接回到main</span>
<span class="hljs-comment">// 函数将系统栈保存于envbuf中，以供以后调用longjmp()。当第一次调用setjmp(),它的返回值为零。</span>
<span class="hljs-comment">//之后调用longjmp(),longjmp()的第二个参数即为setjmp()的返回值</span>
jmp_buf envbuf;<span class="hljs-comment">//全局变量</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am func b\n&quot;</span>);
    longjmp(envbuf,<span class="hljs-number">5</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before,i am func a\n&quot;</span>);
    b();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after,i am func a\n&quot;</span>);<span class="hljs-comment">//此时这一句不会打印</span>
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> ret;
    ret = setjmp(envbuf);
    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == ret) &#123;
        a();
&#125;
</code></pre>

<p> 4、函数的递归调用</p>
<pre><code class="hljs C"><span class="hljs-comment">//爬楼梯，一次只能爬1或者2层</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span>( <span class="hljs-number">1</span> == n) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">if</span> ( <span class="hljs-number">2</span> == n) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-2</span>) + f(n<span class="hljs-number">-1</span>);
&#125;
</code></pre>

<p>5、变量及函数的作用域</p>
<p>​    局部变量和全局变量(内部变量和外部变量)</p>
<p><strong>变量在离自己最近的大括号内有效</strong></p>
<p>static—&gt;修饰局部变量，全局变量，函数</p>
<p><code>static int i = 0;</code>//静态变量只会初始化一次</p>
<pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;
<span class="hljs-comment">//局部变量加static</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//若没有static，则会多次执行此条语句</span>
    i++;
    print(<span class="hljs-string">&quot;%d\n&quot;</span>,i);
&#125;
main() &#123;
<span class="hljs-comment">//每调用一次就会增加1</span>
    fun();<span class="hljs-comment">//此时i = 1</span>
    fun();<span class="hljs-comment">//此时i = 2</span>
&#125;

<span class="hljs-comment">//全局变量,以及函数 前加static，则表明不能被其他的文件借用了，只能在此文件中可见 </span>
ps：另一个文件借用全局变量时，借用加<span class="hljs-keyword">extern</span>  
</code></pre>

<h3 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h3><p>不同类型的数据组合成一个有机的整体</p>
<p>为了避免浪费空间，会把小字节的数据放在一起</p>
<pre><code class="hljs C"><span class="hljs-comment">//结构体定义</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> &#123;</span>
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];
    <span class="hljs-keyword">char</span> sex;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">float</span> score;
    <span class="hljs-keyword">char</span> address[<span class="hljs-number">30</span>];
&#125;;
<span class="hljs-comment">//结构体声明</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">s</span> = &#123;</span><span class="hljs-number">1001</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">98</span>,<span class="hljs-string">&quot;heze&quot;</span>&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">sArr</span>[3];</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.address);<span class="hljs-comment">//打印</span>

<span class="hljs-comment">//用户输入数据，scanf里面空格别忘记</span>
<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i ++) &#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s %c%d%f%s &quot;</span>,&amp;sArr[i].num,sArr[i].name,&amp;sArr[i].sex,&amp;sArr[i].age,&amp;sArr[i].score,sArr[i].address);
&#125;

<span class="hljs-comment">/** 用户输入</span>
<span class="hljs-comment">1001 lili M 20 98 heze</span>
<span class="hljs-comment">1002 lele F 22 92 heze</span>
<span class="hljs-comment">1003 hehe M 19 88 heze</span>
<span class="hljs-comment">**/</span>
<span class="hljs-comment">//打印到屏幕</span>
<span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,sArr[i].num,sArr[i].name,sArr[i].sex,sArr[i].age,sArr[i].score,sArr[i].address);
&#125;
</code></pre>

<p>通过<strong>结构体变量名.成员名</strong>来访问结构体成员</p>
<p>1、结构体指针</p>
<p>一个结构体变量的指针就是该变量所占据的内存段的起始地址。</p>
<p>可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址</p>
<pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];
    <span class="hljs-keyword">float</span> score;
&#125;<span class="hljs-keyword">student_t</span>,*pStudent_t;
<span class="hljs-comment">//student_t就是结构体的别名 *pStudent_t等价于struct student*，可以利用这个定义指针</span>

pStudent_t p1,p2;<span class="hljs-comment">//p1，p2均为结构体指针</span>

<span class="hljs-keyword">student_t</span> s = &#123;<span class="hljs-number">101</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">99</span>&#125;;
<span class="hljs-keyword">student_t</span> *p = &amp;s;<span class="hljs-comment">//结构体指针</span>
<span class="hljs-comment">//利用指针访问成员变量</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %0.2f\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;score);
</code></pre>

<p>2、typedef定义变量 </p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE; <span class="hljs-comment">//此时相当于INTERGE为int类型，即int的别名,编译的时候真正产生这个类型</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4<span class="hljs-comment">// 一般是定义常量，而且是在预处理时候直接替换,后面不需要加分号，上面那个需要加</span></span>
</code></pre>

<p>3、共用体与枚举</p>
<pre><code class="hljs C"><span class="hljs-comment">//联合体(共用体) 所有成员公用一块空间，并且不可修改</span>
<span class="hljs-keyword">union</span> data &#123;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span> c;
    <span class="hljs-keyword">float</span> f;
&#125;;
<span class="hljs-comment">//枚举</span>
<span class="hljs-keyword">enum</span> weekday &#123;sun,mon,tue,wed,thus,fir,sat&#125;;
<span class="hljs-comment">//sum = 0，mon = 2,.......</span>
</code></pre>



<h3 id="九、数据结构基础"><a href="#九、数据结构基础" class="headerlink" title="九、数据结构基础"></a>九、数据结构基础</h3><h4 id="1、链表的增删改查"><a href="#1、链表的增删改查" class="headerlink" title="1、链表的增删改查"></a>1、链表的增删改查</h4><p>线性表的两种存储结构：线性结构(<strong>数组</strong>）和链式结构(<strong>链表</strong>)</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/15.png" srcset="/img/loading.gif"></p>
<p>写链表首先先定义结点！</p>
<pre><code class="hljs C"><span class="hljs-comment">//结点定义</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>
    <span class="hljs-keyword">int</span> num;    
    <span class="hljs-keyword">float</span> score;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">pNext</span>;</span> 
&#125;;
</code></pre>

<p>新增：头插法，尾插法，有序插入</p>
<pre><code class="hljs C"><span class="hljs-comment">//结点的声明</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span>
&#125;Student_t,*pStudent_t;

<span class="hljs-comment">//头插法  参数是二级指针</span>
<span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span>
<span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span>
<span class="hljs-comment">//不空==&gt; 新结点的next指针指向原有头结点，新结点作为头结点</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listHeadInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;
    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));
    pNew-&gt;num = val;
    <span class="hljs-comment">//判断链表是否为空</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == *head) &#123;
        *head = pNew;
        *tail = pNew;
    &#125;
    <span class="hljs-comment">//不空，则进行插入</span>
    <span class="hljs-keyword">else</span> &#123;
        pNew-&gt;next = *head;
        *head = pNew;
    &#125;
&#125;

<span class="hljs-comment">//尾插法</span>
<span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span>
<span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span>
<span class="hljs-comment">//不空==&gt; 原来尾结点的next指针指向新结点，再将新结点作为尾结点</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listTailInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;
    pStduent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Stduent_t));
    pNew-&gt;num = val;
    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;
        *head = pNew;
        *tail = pNew;
    &#125;
    <span class="hljs-keyword">else</span> &#123;
        (*tail)-&gt;next = pNew;
        *tail = pNew;
    &#125;
&#125;

<span class="hljs-comment">//有序插入</span>
<span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span>
<span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span>
<span class="hljs-comment">//若不为空，如果头结点的值&gt;要插入结点的值==&gt;头插法;如果没有，则遍历链表，找到比插入值大的结点位置，新结点的next指针指向当前结点位置，前一个结点的next指针指向新结点;未找到插入位置，说明要放到链表尾部，尾插法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listSortInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;
    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));
    pStudent_t pCur,pPre;<span class="hljs-comment">//vs老版本中，定义必须放在前面，不然会错误</span>
    pNew-&gt;num = val; <span class="hljs-comment">//进行初始化，不然结果为0</span>
    pCur = pPre = *head;
    <span class="hljs-comment">//是否为空</span>
    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;
        *head = pNew;
        *tail = pNew;
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( val &lt; pCur-&gt;num ) &#123;
    <span class="hljs-comment">//头插法</span>
        pNew-&gt;next = *head;
        *head = pNew;
    &#125;
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">while</span>( <span class="hljs-literal">NULL</span> != pCur) &#123;
        <span class="hljs-comment">//找到了结点比要插入的结点大，这说明插入这中间</span>
            <span class="hljs-keyword">if</span>( pCur-&gt;num &gt; val ) &#123;
                pPre-&gt;next = pNew;
                pNew-&gt;next = pCur;<span class="hljs-comment">//在这一步之前，要保证前一个结点不能丢失</span>
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">//保证pCur向前走，而pPre跟在pCur之后那个位置，即:pPre先赋值成pCur(保存好位置),pCur再走</span>
            pPre = pCur;
            pCur = pCur-&gt;next;
        &#125;
        <span class="hljs-comment">//没有插入到中间，则pCur == NULL,则插入到最后</span>
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;
            pPre-&gt;next = pNew;
            *tail = pNew;
        &#125;
    &#125;
&#125;
<span class="hljs-comment">//主函数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    pStduent_t phead = <span class="hljs-literal">NULL</span>,pTail = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) != EOF) &#123;
        listHeadInsert(&amp;pHead,&amp;pTail,<span class="hljs-keyword">int</span> num);<span class="hljs-comment">//要将地址进行传入</span>
    &#125;

&#125;
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//删除链表中的结点</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">    判断是否为空==&gt;为空打印，链表为空</span>
<span class="hljs-comment">    判断删除值是不是头结点==&gt;是的话==&gt;头结点的pNext赋值给头结点，free删除的结点空间，如果删除结点后链表为空，设置尾指针为NULL</span>
<span class="hljs-comment">    不是的话==&gt;遍历链表，找到要删除的值，将前一个结点的pNext的指针指向删除结点的下一个结点，判断删除结点地址值是否等于尾指针，相等==&gt;说明删除为尾结点，尾指针指向前一个结点，之后free删除的结点；若没有找到删除的结点，打印没有发现删除结点的值</span>
<span class="hljs-comment">    </span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> deleteNum)</span> </span>&#123;
    <span class="hljs-comment">//pCur用来指向被删除的结点，一直遍历，pPre指向pCur的前一个结点</span>
    pStudent_t pCur = *head,pPre;
    pPre = pCur;
    <span class="hljs-comment">//判断是否为空</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pCur) &#123;
        print(<span class="hljs-string">&quot;list is empty\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">//删除头部结点</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pCur-&gt;num == deleteNum) &#123;
        *head = pCur-&gt;next;
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head ) &#123;
            *tail = <span class="hljs-literal">NULL</span>;
        &#125;
    &#125;
    <span class="hljs-comment">//删除头部或尾部</span>
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">while</span>( *head != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">if</span> ( pCur-&gt;next == deleteNum) &#123;
                pPre-&gt;next = pCur-&gt;next;
                <span class="hljs-keyword">break</span>;
            &#125;
            pPre = pCur;
            pCur = pCur-&gt;next;
        &#125;
        <span class="hljs-comment">//没有找到对应结点</span>
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find deleteNum\n&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (pCur == *tail) &#123;
            *tail = pPre;
        &#125;
    &#125;
    <span class="hljs-built_in">free</span>(pCur);
    pCur = <span class="hljs-literal">NULL</span>;
&#125;
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//修改链表中的元素</span>
<span class="hljs-comment">//并不需要修改头指针，所以传入一级指针就行</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listModify</span><span class="hljs-params">(pStudent head,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">float</span> score)</span> </span>&#123;
    <span class="hljs-keyword">while</span> ( head != <span class="hljs-literal">NULL</span> ) &#123;
        <span class="hljs-keyword">if</span>( head-&gt;num = num) &#123;
            head-&gt;socre = socre;
        &#125;
        head = head-&gt;next;
    &#125;
    <span class="hljs-keyword">if</span> ( head == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find modify num\n&quot;</span>);
    &#125;
&#125;
</code></pre>

<h4 id="2、常用数据结构和算法"><a href="#2、常用数据结构和算法" class="headerlink" title="2、常用数据结构和算法"></a>2、常用数据结构和算法</h4><p>设计数据结构，就是为了高效管理数据。</p>
<p>有效的存取方法可提高我们访问数据的效率，即算法</p>
<p>需要掌握的数据结构</p>
<p><strong>数组，栈，队列，链表，树，堆，散列表，图…..</strong></p>
<h5 id="1-、栈-stack"><a href="#1-、栈-stack" class="headerlink" title="(1)、栈(stack)"></a>(1)、栈(stack)</h5><p>后进先出</p>
<pre><code class="hljs C"><span class="hljs-comment">//栈的定义</span>
<span class="hljs-comment">//结点</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span>
    <span class="hljs-keyword">int</span> val;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> *<span class="hljs-title">pNext</span>;</span>
&#125;Node_t,*pNode_t ;
<span class="hljs-comment">//利用链，栈的结构体</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
    pNode_t head;
    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈的大小</span>
&#125;Stack_t,pStack_t;
<span class="hljs-comment">//一系列接口</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//初始化栈</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//入栈</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//出栈</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//返回栈顶元素</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//返回栈的大小</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//确定栈是否为空</span>
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//初始化</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;
    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">stack</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Stack_t));<span class="hljs-comment">//系统内置接口，在&lt;string.h&gt;中，用于将内存初始化某值</span>
    <span class="hljs-comment">//是将Stack_t中的分量设置为0的快捷的方法</span>
    <span class="hljs-comment">//void *memset( void *buffer, int ch, size_t count );</span>
    <span class="hljs-comment">// 拷贝ch到buffer从头开始的count个字符里，并返回buffer指针</span>
&#125;
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//入栈，头插法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>,<span class="hljs-keyword">int</span> val)</span> </span>&#123;
    <span class="hljs-comment">//既然是入栈，肯定是要申请结点空间</span>
    pNode_t pNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));
    pNew-&gt;val = val;
    pNew-&gt;pNext = <span class="hljs-built_in">stack</span>-&gt;head;
    <span class="hljs-built_in">stack</span>-&gt;head = pNew;
    <span class="hljs-built_in">stack</span>-&gt;size ++;
&#125;
<span class="hljs-comment">//出栈，头部删除法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;
    <span class="hljs-comment">//先判断是否栈为空</span>
    pNode_t pCur;<span class="hljs-comment">//因为要删除结点，肯定要free,所以必须要个pCur</span>
    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">//之后进行pop</span>
    pCur = <span class="hljs-built_in">stack</span>-&gt;head;
    <span class="hljs-comment">//stack-&gt;head = stack-&gt;head-&gt;pNext;</span>
    <span class="hljs-built_in">stack</span>-&gt;head = pCur = pCur-&gt;pnext;
    <span class="hljs-built_in">free</span>(pCur);
    pCur = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//防止野指针</span>
    <span class="hljs-built_in">stack</span>-&gt;size --;
&#125;
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//返回栈顶元素</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;head-&gt;val;
&#125;
<span class="hljs-comment">//返回栈的元素个数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;size;
&#125;
<span class="hljs-comment">//判断是否为空</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;
    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">stack</span>-&gt;size;
&#125;
</code></pre>

<h5 id="2-、队列"><a href="#2-、队列" class="headerlink" title="(2)、队列"></a>(2)、队列</h5><p>循环队列</p>
<pre><code class="hljs C"><span class="hljs-comment">//循环队列的定义，利用数组实现</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 5</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
    ElemType data[MaxSize];
    <span class="hljs-keyword">int</span> front,rear;
&#125;SqQueue_t;
<span class="hljs-comment">//系列接口</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *)</span></span>;<span class="hljs-comment">//初始化队列</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *,ElemType )</span></span>;<span class="hljs-comment">//入队</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t *,ElemType* )</span></span>;<span class="hljs-comment">//出队,利用了传出参数</span>
</code></pre>

<pre><code class="hljs C"><span class="hljs-comment">//初始化循环队列</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>)</span> </span>&#123;
    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-rear = <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">//入队</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>,ElemType x)</span> </span>&#123;
    <span class="hljs-comment">//判断队列是否满了</span>
    <span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; queue is full\n&quot;</span>);
    &#125;
    <span class="hljs-comment">//入队，放入x</span>
    <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;rear] = x;
    <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize;<span class="hljs-comment">//rear向前走</span>
&#125;
<span class="hljs-comment">//出队</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t* <span class="hljs-built_in">queue</span>,ElemType *x)</span> </span>&#123;
    <span class="hljs-comment">//判断队列是否为空</span>
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty\n&quot;</span>);
    &#125;
    <span class="hljs-comment">//出队</span>
    *x = <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;front];
    <span class="hljs-built_in">queue</span>-&gt;front = ((<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize)
&#125;
</code></pre>

<h5 id="3-、二叉树"><a href="#3-、二叉树" class="headerlink" title="(3)、二叉树"></a>(3)、二叉树</h5><p><strong>每个结点最多有两个子树的树结构！</strong></p>
<p>二叉树常用于实现 <strong>二叉查找树 和 二叉堆</strong></p>
<p><strong>层次建树==&gt;辅助队列</strong></p>
<p>k层，总节点数 2^k - 1</p>
<p>完全二叉树：只允许最后一层有空缺且在右边。对任一结点，其右子树的深度为j，则左子树深度必为j或j+1,度为1的点只有1个或0个</p>
<pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;
<span class="hljs-comment">//结点声明</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span></span>
<span class="hljs-class">&#123;</span>
    ElemType c;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pleft</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pright</span>;</span>
&#125;Node_t,*pNode_t;

<span class="hljs-comment">//2、利用辅助队列进行层次建树</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span></span>
<span class="hljs-class">&#123;</span>
    pNode_t insertPos; <span class="hljs-comment">//要插入结点的位置</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span> *<span class="hljs-title">pNext</span>;</span>
&#125;Queue_t,*pQueue_t;

<span class="hljs-comment">//接口声明</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//前序遍历==&gt;根左右</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//中序遍历==&gt;左根右</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//后序遍历===&gt;左右根</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t*,pQueue_t*,pQueue_t *,<span class="hljs-keyword">int</span> )</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t root)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span> ) 
    &#123;
        <span class="hljs-built_in">putchar</span>(root-&gt;c);
        preOrder(root-&gt;pleft);
        preOrder(root-&gt;pright);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOreder</span><span class="hljs-params">(pNode_t root)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)
    &#123;
        preOrder(root-&gt;pleft);
        <span class="hljs-built_in">putchar</span>(root-&gt;c);
        preOrder(root-&gt;pright);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOreder</span><span class="hljs-params">(pNode_t root)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)
    &#123;
        preOrder(root-&gt;pleft);
        preOrder(root-&gt;pright);
        <span class="hljs-built_in">putchar</span>(root-c);
    &#125;
&#125;
<span class="hljs-comment">//2、层次建树</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t *treeRoot,pQueue_t *queHead,pQueue_t *queTail,<span class="hljs-keyword">int</span> val)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">//申请结点</span>
    pNode_t treeNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));
    pQueue_t queNew = (pQueue_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Queue_t));
    pQueue_t queCur = *queHead;<span class="hljs-comment">//指向给哪个元素结点放孩子 </span>
    treeNew-&gt;c = val;
    queNew-&gt;insertPos = treeNew;
    <span class="hljs-comment">//判断是否有根节点</span>
    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *treeRoot )
    &#123;
        *treeRoot = treeNew;
        *queHead = queNew;
        *queTail = queNew;
    &#125;
    <span class="hljs-comment">//根节点不为空，找插入位置</span>
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-comment">//队列操作，把元素放入队列===&gt;尾插法</span>
        (*queTail)-&gt;pNext = queNew;
        *queTail = queNew;
        <span class="hljs-comment">//判断左子树是否空</span>
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pleft )
        &#123;
            queCur-&gt;inSertPos-&gt;pleft = treeNew;
        &#125;
        <span class="hljs-comment">//判断右子树是否为空</span>
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pright )
        &#123;
            queCur-&gt;insertPos-&gt;pright = treeNew;
            <span class="hljs-comment">//先保存后释放,某个结点左右孩子都有了之后，出队</span>
            *queHead = queCur-&gt;pNext;
            <span class="hljs-built_in">free</span>(queCur);
            queCur = <span class="hljs-literal">NULL</span>;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//1、可利用数组进行层次建树</span>
    ElemType c[] = <span class="hljs-string">&quot;ABCDEFJHI&quot;</span>;
    pNode_t p[N];<span class="hljs-comment">//p为指针数组</span>
    <span class="hljs-keyword">int</span> i,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j记住往哪个结点放数据</span>
    <span class="hljs-comment">//为每个结点申请空间，同时把结点值放进去</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;N;i++)
    &#123;
        p[i] = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));
        p[i]-&gt;c = c[i];
    &#125;
    <span class="hljs-comment">//第一个结点A不需要建立，即A自己也是。故从1开始进入</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;N;i++)<span class="hljs-comment">//外层控制进入的元素</span>
    &#123;
        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p[j]-&gt;pleft )<span class="hljs-comment">//内层比较，找位置</span>
        &#123;
            p[j]-&gt;pleft = p[i];<span class="hljs-comment">//为空，则放入</span>
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( NUll == p[j]-&gt;pright )
        &#123;
            p[j]-&gt;pright = p[i];
            j++;<span class="hljs-comment">//插入完之后，跑到B位置等待左右孩子插入其中(j初始为0)</span>
        &#125;
    &#125;

    <span class="hljs-comment">//2、辅助队列进行层次建树</span>
    ElemType val;
    pNode_t treeRoot = <span class="hljs-literal">NULL</span>;
    pQueue_t queHead = <span class="hljs-literal">NULL</span>,queTail = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%c&quot;</span>,&amp;val) != EOF)
    &#123;
        <span class="hljs-keyword">if</span>( val == <span class="hljs-string">&#x27;\n&#x27;</span> ) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        BuildBinaryTree(&amp;treeRoot,&amp;queHead,&amp;queTail,val);
    &#125;
&#125;
</code></pre>



<h5 id="4-、排序算法"><a href="#4-、排序算法" class="headerlink" title="(4)、排序算法"></a>(4)、排序算法</h5><p>时间复杂度和空间复杂 </p>
<p>时间复杂度====&gt;大O符号表示</p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/16.png" srcset="/img/loading.gif"></p>
<p><strong>掌握八种算法：冒泡，选择，插入，希尔，快排，堆排，归并，基排</strong>.  </p>
<blockquote>
<p>插入类：插入排序，希尔排序</p>
<p>选择类：选择排序，堆排序</p>
<p>交换类：冒泡排序，快速排序</p>
<p>归并类：归并排序</p>
<p>分配类：基数排序、计数排序、桶排序，同额外的空间来分配和收集，继而实现排序</p>
</blockquote>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/17.png" srcset="/img/loading.gif"> </p>
<p><strong>qsort重点掌握！！！</strong></p>
<h5 id="lt-1-gt-冒泡"><a href="#lt-1-gt-冒泡" class="headerlink" title="&lt;1&gt;冒泡"></a>&lt;1&gt;冒泡</h5><pre><code class="hljs C"><span class="hljs-comment">/*</span>
<span class="hljs-comment">2001 li 45.5 96.5 70.4</span>
<span class="hljs-comment">2009 liu 98.5 78.5 98.6</span>
<span class="hljs-comment">2003 lin 78 83.5 79.6</span>
<span class="hljs-comment">2004 zhang 95 93.5 80.5</span>
<span class="hljs-comment">2005 wang 88.5 75.7 40.6</span>
<span class="hljs-comment">*/</span>
<span class="hljs-comment">/* 冒泡排序</span>
<span class="hljs-comment">1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span>
<span class="hljs-comment">2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span>
<span class="hljs-comment">3、针对所有的元素重复以上的步骤，除了最后一个。</span>
<span class="hljs-comment">4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  SWAP(a,b) &#123;int tmp;tmp = a; a = b;b = tmp;&#125;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> i,j;
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; N;i++)
    &#123;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>;i &lt; N - <span class="hljs-number">1</span> - i;j++)
        &#123;
            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])
            &#123;
                SWAP(arr[j],arr[j+<span class="hljs-number">1</span>])
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>

<h5 id="lt-2-gt-选择"><a href="#lt-2-gt-选择" class="headerlink" title="&lt;2&gt;选择"></a>&lt;2&gt;选择</h5><pre><code class="hljs C"><span class="hljs-comment">/*选择排序</span>
<span class="hljs-comment">首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</span>
<span class="hljs-comment">然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span>
<span class="hljs-comment">以此类推，直到所有元素均排序完毕</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> i,j,maxPos;
    <span class="hljs-keyword">for</span>(i = N;i&gt;<span class="hljs-number">0</span>;i++)
    &#123;
        maxPos = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>( j = <span class="hljs-number">1</span>;j &lt; i;j++)
        &#123;
            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[maxPos])
            &#123;
                maxPos = j;
            &#125;
        &#125;
        SWAP(arr[maxPos,arr[i<span class="hljs-number">-1</span>]);
    &#125;
&#125;
</code></pre>

<h5 id="lt-3-gt-插入"><a href="#lt-3-gt-插入" class="headerlink" title="&lt;3&gt;插入"></a>&lt;3&gt;插入</h5><pre><code class="hljs C"><span class="hljs-comment">/*认为零号元素自然有序,从1号元素开始插入</span>
<span class="hljs-comment">先存储插入元素的值，从后向前，依次拿有序序列的值，依次与插入元素的值进行比较</span>
<span class="hljs-comment">如果有序序列值大于插入元素值，有序序列值向后移动一位，找到插入元素值的位置，将插入元素值放入对应位置</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i,j,InsertVal;<span class="hljs-comment">//保存要插入的值</span>
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>;i &lt; N;i++) 
    &#123;
        InsertVal = arr[i];
        <span class="hljs-keyword">for</span> (j = i <span class="hljs-number">-1</span>;j &gt;= <span class="hljs-number">0</span>; j--) 
        &#123;
            <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal ) 
            &#123;
                arr[j + <span class="hljs-number">1</span>] = arr[j];
            &#125;
            <span class="hljs-keyword">else</span> 
            &#123;
                <span class="hljs-keyword">break</span>;
            &#125;    
        &#125;
        arr[j + <span class="hljs-number">1</span>] = InsertVal;    
    &#125;
&#125;
</code></pre>

<h5 id="lt-4-gt-希尔"><a href="#lt-4-gt-希尔" class="headerlink" title="&lt;4&gt;希尔"></a>&lt;4&gt;希尔</h5><pre><code class="hljs C"><span class="hljs-comment">//希尔排序,需要一个步长,步长以长度的1/2开始，每次步长除2减少</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrShell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i,j,InsertVal,gap;<span class="hljs-comment">//保存要插入的值</span>
    <span class="hljs-keyword">for</span>(gap = N &gt;&gt; <span class="hljs-number">1</span>;gap &gt;<span class="hljs-number">0</span>;gap &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-comment">//gap 除以2 ,利用移位可调高效率</span>
    &#123;
        <span class="hljs-keyword">for</span>( i = gap;i &lt; N;i++) 
        &#123;
            InsertVal = arr[i];
            <span class="hljs-keyword">for</span> (j = i -gap;j &gt;= <span class="hljs-number">0</span>; j= j - gap) 
            &#123;
                <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal ) 
                &#123;
                    arr[j + gap] = arr[j];
                &#125;
                <span class="hljs-keyword">else</span> 
                &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;    
            &#125;
            arr[j + gap] = InsertVal;    
        &#125;
    &#125;

&#125;
</code></pre>

<h5 id="lt-5-gt-快排"><a href="#lt-5-gt-快排" class="headerlink" title="&lt;5&gt;快排"></a>&lt;5&gt;快排</h5><pre><code class="hljs C"><span class="hljs-comment">/*递归进行，开始进行partition划分，选择最后一个元素作为分割值，将比分隔值小的放在分隔值的左边，比分隔值大的放在分隔值的右边，此时分隔值的位置就确定了，故返回分隔值的下标。此时数组一分为二，对前半部分和后半部分继续进行分割，重复操作，进行递归</span>
<span class="hljs-comment">*/</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;
    <span class="hljs-keyword">int</span> i,k;<span class="hljs-comment">//i遍历数组，k记录比右边小的数的位置</span>
    <span class="hljs-keyword">for</span>(i = left,k = left;i &lt; right;i++) 
    &#123;
        <span class="hljs-comment">//进行交换</span>
        <span class="hljs-keyword">if</span>(arr[right] &gt;  arr[i])
        &#123;
            SWAP(arr[i],arr[k]);
            k++;
        &#125;
    &#125;
    SWAP(arr[k],arr[right]);
    <span class="hljs-keyword">return</span> k;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrQuick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;
    <span class="hljs-keyword">if</span>( left &lt; right )
    &#123;
        <span class="hljs-keyword">int</span> pivot;
        pivot = partition(arr,left,right);
        arrQuick(arr,left,pivot - <span class="hljs-number">1</span>);
        arrQuick(arr,pivot + <span class="hljs-number">1</span>,right);
    &#125;
&#125;

</code></pre>

<h5 id="lt-6-gt-堆排"><a href="#lt-6-gt-堆排" class="headerlink" title="&lt;6&gt;堆排"></a>&lt;6&gt;堆排</h5><p>什么是堆===&gt;用数组去存一棵树</p>
<p>左孩子 son = 2 * dad + 1 (位置而言)</p>
<p><strong>大根堆(大顶堆)：若父结点的值恒大于等于子结点的值</strong>，若从小到大排序，需要建立大顶堆</p>
<p><strong>小根堆(小顶堆)：若父结点的值小于等于子结点的值</strong></p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/18.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs C"><span class="hljs-comment">/*</span>
<span class="hljs-comment">    堆排序</span>
<span class="hljs-comment">*/</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_max_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> adjust_pos,<span class="hljs-keyword">int</span> len)</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> dad = adjust_pos;
    <span class="hljs-keyword">int</span> son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子</span>
    <span class="hljs-keyword">while</span>( son &lt; len)
    &#123;
        <span class="hljs-comment">//可能没右孩子，先判断右孩子是存在及右孩子是否大于左孩子</span>
        <span class="hljs-keyword">if</span>( son + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) &#123;
            son ++;
        &#125;
        <span class="hljs-keyword">if</span>(arr[son] &gt; arr[dad]) &#123;
            SWAP(arr[son],arr[dad]);
            <span class="hljs-comment">//因为一个调整后，可能或影响其他的，导致其他的需要再次调整，所以进行循环调整</span>
            <span class="hljs-comment">//把交换完的重新作为dad，再次判断</span>
            dad = son;
            son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr)</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-comment">//倒着从最后一个父结点开始调整</span>
    <span class="hljs-keyword">for</span>( i = N/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> ; i--) &#123;
        adjust_max_heap(arr,i,N);
    &#125;
    <span class="hljs-comment">//接着需要进行有序化</span>
    <span class="hljs-comment">//把最后一个结点和根节点交换，接着最后一个结点是最大的，去除！再进行调整</span>
    SWAP(arr[<span class="hljs-number">0</span>],arr[N<span class="hljs-number">-1</span>]); 
    <span class="hljs-keyword">for</span>( i = N - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">1</span> ; i--) &#123;
        <span class="hljs-comment">//因为只破坏了根部，所以只需一直调整根部为大根堆</span>
        adjust_max_heap(arr,<span class="hljs-number">0</span>,i);
        SWAP(arr[<span class="hljs-number">0</span>],arr[i<span class="hljs-number">-1</span>]);
    &#125;
&#125;
</code></pre>

<h5 id="lt-7-gt-归并"><a href="#lt-7-gt-归并" class="headerlink" title="&lt;7&gt;归并"></a>&lt;7&gt;归并</h5><pre><code class="hljs C"><span class="hljs-comment">//归并</span>
<span class="hljs-comment">//合并两个有序数组</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> high)</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> b[N];
    <span class="hljs-keyword">int</span> i,j,k;
    <span class="hljs-keyword">for</span>(i = low;i &lt;= high;i++)
    &#123;
        b[i] = arr[i];
    &#125;
    <span class="hljs-keyword">for</span>(k = low,i = low,j = mid + <span class="hljs-number">1</span>;i &lt;= mid &amp;&amp; j&lt;= high;)
    &#123;
        <span class="hljs-keyword">if</span>(b[i] &lt; b[j])
        &#123;
            arr[k] = b[i];
            k++;
            i++;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            arr[k] = b[j];
            k++;
            j++;
        &#125;
    &#125;
    <span class="hljs-keyword">while</span>(i &lt;= mid)
    &#123;
        arr[k] = b[i];
        k++;
        i++;
    &#125;
    <span class="hljs-keyword">while</span>(j &lt;= high)
    &#123;
        arr[k] = b[j];
        k++;
        j++;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> mid;
    <span class="hljs-keyword">if</span>(low &lt; high) 
    &#123;
        mid = (low + high) / <span class="hljs-number">2</span>;
        arr_merge(arr,low,mid);
        arr_merge(arr,mid + <span class="hljs-number">1</span>,high);
        merge(arr,low,mid,high);
    &#125;
&#125;
</code></pre>

<h5 id="lt-8-gt-计数排序"><a href="#lt-8-gt-计数排序" class="headerlink" title="&lt;8&gt;计数排序"></a>&lt;8&gt;计数排序</h5><p>空间换时间！====  数据的范围必须是有限的</p>
<pre><code class="hljs C"><span class="hljs-comment">//申请一个被排序数的范围大小的空间arr_count,遍历数组，统计数组中每个值出现的次数</span>
<span class="hljs-comment">//遍历arr_count，根据每个值出现的次数，对要排序的数组进行填充</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>     M 100</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> i,j,k;
    <span class="hljs-keyword">int</span> arr_count[M] = &#123;<span class="hljs-number">0</span>&#125;;

    <span class="hljs-comment">//统计出arr数组中，每个值出现的次数</span>
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++)
    &#123;
        arr_count[arr[i]]++;
    &#125;
    k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; M;i++)
    &#123;
        <span class="hljs-keyword">for</span>(j= <span class="hljs-number">0</span> ;j&lt;arr_count[i];j++)
        &#123;
            arr[k] = i;
            k++;
        &#125;
    &#125;
&#125;
</code></pre>

<h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/19.png" srcset="/img/loading.gif"> </p>
<p>涉及到磁盘的===&gt;尽可能少读磁盘，速度太慢</p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/20.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/21.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/22.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/23.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/24.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/25.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/26.png" srcset="/img/loading.gif"> </p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>针对有序数组~</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high,<span class="hljs-keyword">int</span> target)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> mid;
    <span class="hljs-keyword">while</span>(low &lt;= high)
    &#123;
        mid = (low + high) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>( arr[mid ] &gt; target)
        &#123;
            high = mid <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( arr[mid ] &lt; target)
        &#123;
            low = mid + <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">else</span> 
            <span class="hljs-keyword">return</span> mid;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
&#125;
</code></pre>



<h5 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h5><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/27.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28.png" srcset="/img/loading.gif"> </p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28_1.png" srcset="/img/loading.gif"></p>
<p><strong>哈希冲突</strong></p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29.png" srcset="/img/loading.gif"> </p>
<p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29_1.png" srcset="/img/loading.gif"></p>
<p>建议用链表法</p>
<pre><code class="hljs C"><span class="hljs-comment">//哈希查找：通过哈希函数对要找的字符串进行哈希计算，得到key值(数组下标)，通过key去哈希表中得到对应的元素</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxKey 1000</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *key)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">//ELF hash函数</span>
    <span class="hljs-comment">//下面是公式！冲突会比较少，经验！</span>
    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>,g;
    <span class="hljs-keyword">while</span>( *key )
    &#123;
        h = (h &lt;&lt; <span class="hljs-number">4</span>) + *key++;
        g = h &amp; <span class="hljs-number">0xf0000000</span>;
        <span class="hljs-keyword">if</span>(g) 
        &#123;
            h ^= g &gt;&gt; <span class="hljs-number">24</span>;
        &#125;
        h &amp;= ~g;
    &#125;
    <span class="hljs-keyword">return</span> h % MaxKey;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_hash</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">char</span> *pStr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;xiongda&quot;</span>,<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;wangdao &quot;</span>,<span class="hljs-string">&quot;fenghua&quot;</span>&#125;;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span> *pHash_table[MaxKey] = &#123;<span class="hljs-literal">NULL</span>&#125;;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is key = %d\n&quot;</span>,pStr[i],hash(pStr[i]));
        pHash_table[hash(pStr[i])] = pStr[i];
    &#125;
&#125;
</code></pre>

<h3 id="十、文件操作"><a href="#十、文件操作" class="headerlink" title="十、文件操作"></a>十、文件操作</h3><p><strong>程序执行时成为进程</strong>，进程运行过程中的数据均在内存中。需要存储运算后的数据时，就需要使用文件</p>
<p>文件是指存储在外部介质(磁盘或磁带)上的数据集合。操作系统是以文件为单位对数据进行管理的</p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/30.png" srcset="/img/loading.gif"> </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/31.png" srcset="/img/loading.gif"> </p>
<p>1、文件的打开、读写、关闭  </p>
<p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/32.png" srcset="/img/loading.gif">  </p>
<pre><code class="hljs C"><span class="hljs-comment">//从文件中读</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">char</span> c;
    FILE *fp;<span class="hljs-comment">//是结构体指针，系统定义好的</span>
    fp = fopen(<span class="hljs-string">&quot;text.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//r表示只读</span>
    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == fp )
    &#123;
        perror(<span class="hljs-string">&quot;fopen&quot;</span>);<span class="hljs-comment">//如果指针错误，则利用perror定位错误信息</span>
        <span class="hljs-keyword">goto</span> error;
    &#125;
    <span class="hljs-comment">//把text.txt文件的内容打印到屏幕上</span>
    <span class="hljs-keyword">while</span>( (c = fgetc(fp)) != EOF)
    &#123;
        <span class="hljs-built_in">putchar</span>(c);
    &#125;
error:
    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                      <a class="hover-with-bg" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/18/html/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">html</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/">
                        <span class="hidden-mobile">博客的搭建-hexo-github</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    function loadGitalk() {
      addScript('https://cdn.staticfile.org/blueimp-md5/2.13.0/js/md5.min.js');
      addScript('https://cdn.staticfile.org/gitalk/1.6.2/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: 'a6ecdddb59c8bed4c4e0',
          clientSecret: 'deecdd08fa166e81db2222df7514d6c2d2f357a0',
          repo: 'codeheng.github.io',
          owner: 'codeheng',
          admin: ["codeheng"],
          id: md5(location.pathname),
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: false
        });
        gitalk.render('gitalk-container');
      });
    }
    waitElementVisible('gitalk-container', loadGitalk);
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="http://cslearner.cn/" target="_blank" rel="nofollow noopener"><span>CSlearner</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/" target="_blank" rel="nofollow noopener">
        <span>GitHub</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>



    我在次已等候你:
<span id="momk"></span>
<script language=javascript>
function show_date_time(){
  window.setTimeout("show_date_time()", 1000);
  BirthDay=new Date("08-09-2020 20:00:00");//建站日期
  today=new Date();
  timeold=(today.getTime()-BirthDay.getTime());
  sectimeold=timeold/1000
  secondsold=Math.floor(sectimeold);
  msPerDay=24*60*60*1000
  e_daysold=timeold/msPerDay
  daysold=Math.floor(e_daysold);
  e_hrsold=(daysold-e_daysold)*-24;
  hrsold=Math.floor(e_hrsold);
  e_minsold=(hrsold-e_hrsold)*-60;
  minsold=Math.floor((hrsold-e_hrsold)*-60);
  seconds=Math.floor((minsold-e_minsold)*-60);
  momk.innerHTML=daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒" ;
}
show_date_time();
</script>
<style>
#momk{animation:change 10s infinite;font-weight:800; }
@keyframes change{0%{color:#5cb85c;}25%{color:#556bd8;}50%{color:#e40707;}75%{color:#66e616;}100% {color:#67bd31;}}
</style>

    <i class="fa fa-area-chart"></i>
    <span class="post-count">总字数统计：78.5k</span>

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "c语言学习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>

<script type="text/javascript" src="/js/clicklove.js"></script>
<script type="text/javascript" src="\js\FunnyTitle.js"></script>