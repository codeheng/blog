<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker命令</title>
    <link href="/2022/01/04/docker%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/04/docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre><code class="hljs shell">docker version #显示docker版本信息docker info #显示docker的系统信息，包括镜像和容器docker 命令 --help # 帮助命令</code></pre><p><a href="https://docs.docker.com/reference/">docker命令文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><pre><code class="hljs shell">docker images # 查看所有本机的主机上的镜像[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY:镜像的仓库源TAG ： 镜像标签IMAGE ID  ： 镜像idCREATED ： 创建时间SIZE ： 镜像大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images)  -q, --quiet           Only show image IDs</code></pre><p><strong>搜索镜像</strong></p><pre><code class="hljs shell">docker search xxxUsage:  docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions:  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print search using a Go template      --limit int       Max number of search results (default 25)      --no-trunc        Don&#x27;t truncate output<span class="hljs-meta">#</span><span class="bash">例如：找出mysql中stars大于3000的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker search mysql --filter=STARS=3000NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql     MySQL is a widely used, open-source relation…   11931     [OK]mariadb   MariaDB Server is a high performing open sou…   4561      [OK]</code></pre><p><strong>下载镜像</strong></p><pre><code class="hljs shell">docker pull xxx[:tag]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output<span class="hljs-meta">#</span><span class="bash">下载mysql</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql72a69066d2fe: Pull complete #分成下载，docker images的核心==&gt;联合文件系统93619dbc5b36: Pull complete99da31dd6142: Pull complete626033c43d70: Pull complete37d5d7efb64e: Pull completeac563158d721: Pull completed2ba16033dad: Pull complete688ba7d5c01a: Pull complete00e060b6d11d: Pull complete1c04857f594f: Pull complete4d7cfa90e6ea: Pull completee0431212d27d: Pull completeDigest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址<span class="hljs-meta">#</span><span class="bash">指定版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Already exists #此时不用再重新下载，已经存在相同部分93619dbc5b36: Already exists99da31dd6142: Already exists626033c43d70: Already exists37d5d7efb64e: Already existsac563158d721: Already existsd2ba16033dad: Already exists0ceb82207cd7: Pull complete37f2405cae96: Pull completee2482e017e53: Pull complete70deed891d42: Pull completeDigest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash">查看</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEmysql         5.7       c20987f18b13   2 weeks ago    448MBmysql         latest    3218b38490ce   2 weeks ago    516MBhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>删除镜像</strong></p><pre><code class="hljs shell">docker rmi xxxRemove one or more imagesOptions:  -f, --force      Force removal of the image      --no-prune   Do not delete untagged parentsdocker rmi -f 容器id #删除指定的容器docker rmi -f $(docker images -aq) #删除所有的容器</code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>有了镜像才能创建容器，必须先下载镜像，以centos为例 </p></blockquote><pre><code class="hljs shell">docker pull centos</code></pre><p><strong>新建容器并启动</strong></p><pre><code class="hljs shell">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new container<span class="hljs-meta">#</span><span class="bash">参数 </span>--name=&quot;Name&quot;  #容器名字-d #后台运行-it #使用交互方式运行-p  #指定容器端口    -p ip 主机端口:容器端口    -p 主机端口:容器端口(常用)    -p 容器端口    容器端口-P  #随机指定端口<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#测试===&gt; 启动并进入容器</span></span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker run -it centos /bin/bash  [root@bea475e51bda /]# <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看容器内的centos</span></span>[root@bea475e51bda /]#  lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#从容器中退到主机</span></span>[root@bea475e51bda /]# exitexit[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsinstall.sh[root@iZ2ze9nu608mhi5at5aufaZ ~]# cd ..[root@iZ2ze9nu608mhi5at5aufaZ /]# lsbin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  patch  proc  root  run  sbin  srv  sys  tmp  usr  var  www</code></pre><p><strong>列出所有的容器</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker ps 命令</span>       #列出当前正在运行的容器    -a #列出当前正在运行的容器+带出历史运行过的容器    -n=？ #显示最近创建的容器    -q    #只显示容器的编号[root@iZ2ze9nu608mhi5at5aufaZ /]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@iZ2ze9nu608mhi5at5aufaZ /]# docker ps -aCONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMESbea475e51bda   centos        &quot;/bin/bash&quot;   4 minutes ago   Exited (127) 2 minutes ago             keen_rhodes537a7100443f   hello-world   &quot;/hello&quot;      5 days ago      Exited (0) 5 days ago                  jovial_thompson</code></pre><p> <strong>退出容器</strong></p><pre><code class="hljs shell">exit  #直接容器停止并退出ctrl + P + Q # 容器不停止退出[root@iZ2ze9nu608mhi5at5aufaZ /]#  docker run  -it centos  /bin/bash[root@25c39385df34 /]# [root@iZ2ze9nu608mhi5at5aufaZ /]#</code></pre><p><strong>删除容器</strong></p><pre><code class="hljs shell">docker rm 容器id     #删除指定的容器，不能删除正在运行的容器，如果要强制 rm -fdocker rm -f $(docker ps -aq) #删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器</code></pre><p><strong>启动和停止容器</strong></p><pre><code class="hljs shell">docker start 容器iddocker restart iddocker stop iddocker kill id</code></pre><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2022/01/04/JavaWeb/"/>
    <url>/2022/01/04/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a>java web</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>(1)web开发 ：即网页开发</p><ul><li>静态web ：html + css 提供给人看的数据不会发生变化</li><li>动态web：给人看的数据会变化，每个人看的信息各不相同！(几乎所有网站全是！ <ul><li>技术栈：Servlet/JSP ,ASP, PHP</li></ul></li></ul><p>在java中，动态web资源开发的技术成为Java web</p><p>(2)web应用程序</p><p>可以提供浏览器访问的程序，访问的任何页面或资源，均存在于世界上的某个地方的计算机上 ===&gt; URL</p><p>这个统一的web资源会被放在同一个文件夹下，即web应用服务器中===&gt; <strong>tomcat服务器</strong></p><ul><li>一个web文件多部分组成<ul><li>html + css，js</li><li>jsp ，servlet</li><li>java程序</li><li>jar包</li><li>配置文件(properties)</li></ul></li></ul><p>静态web</p><p><img src="/2022/01/04/JavaWeb/01.png" alt="image-20211231201024786"></p><p>缺点：</p><ul><li>无法动态更新，所有用户看的一样 === &gt; javaScript</li><li>无法和数据库交互，数据无法持久化</li></ul><p>动态web</p><p><img src="/2022/01/04/JavaWeb/02.png" alt="image-20211231201034766"></p><p>缺点：</p><ul><li>加入服务器的动态web资源出现了错误，需要重新编写<strong>后台程序</strong>，重新发布==&gt; 停机维护</li></ul><h2 id="2-WEB服务器"><a href="#2-WEB服务器" class="headerlink" title="2.WEB服务器"></a>2.WEB服务器</h2><h3 id="2-1技术"><a href="#2-1技术" class="headerlink" title="2.1技术"></a>2.1技术</h3><p><strong>ASP</strong> (微软–&gt; 最早流行)</p><ul><li>在HTML中嵌入了VB ==&gt; asp + COM</li><li>在asp中，基本一个页面就有几千行代码，页面很混乱，维护高！</li><li>asp里面主要用C#</li><li>IIS服务器 (windows 里面) </li></ul><p><strong>PHP</strong></p><ul><li>开发速度很快，功能很强，跨平台，代码简单</li><li>无法承载访问大的情况</li></ul><p><strong>JSP/servlet</strong>：</p><p>B/S ==&gt; 浏览器和服务器  C/S 客户端和服务器</p><ul><li>sun公司推出的B/S架构</li><li>基于java，可以承载三高（高并发，高可用，高性能</li></ul><h3 id="2-2-web服务器"><a href="#2-2-web服务器" class="headerlink" title="2.2 web服务器"></a>2.2 web服务器</h3><blockquote><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息</p></blockquote><p><strong>IIS</strong></p><ul><li>微软==&gt;windows 自带  </li></ul><p><strong>tomcat</strong></p><ul><li><p><strong>Tomcat</strong>是由Apache软件基金会属下<a href="https://zh.wikipedia.org/wiki/Jakarta%E9%A1%B9%E7%9B%AE">Jakarta项目</a>开发的<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>容器，实现了对<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>和<a href="https://zh.wikipedia.org/wiki/JavaServer_Page">JavaServer Page</a>（<a href="https://zh.wikipedia.org/wiki/JSP">JSP</a>）的支持，并提供了作为一些特有功能</p><blockquote><p>ps:工作3-5年后可以尝试手写tomcat服务器</p></blockquote><blockquote><p>下载东西的三部曲:</p><p>1.安装&amp;解压</p><p>2.了解配置文件和目录结构</p><p>3.这个东西的作用</p></blockquote><p>补充： java 内部的类，比如String 都来自于<strong>rt.jar包</strong>中</p></li></ul><p><img src="/2022/01/04/JavaWeb/03.png" alt="image-20220101085618516"></p><h2 id="3-tomcat"><a href="#3-tomcat" class="headerlink" title="3.tomcat"></a>3.tomcat</h2><h3 id="3-1下载"><a href="#3-1下载" class="headerlink" title="3.1下载"></a>3.1下载</h3><p><a href="https://tomcat.apache.org/">tomcat官网</a></p><p><img src="/2022/01/04/JavaWeb/04.png" alt="image-20220101090211230"></p><h3 id="3-2tomcat启动和配置"><a href="#3-2tomcat启动和配置" class="headerlink" title="3.2tomcat启动和配置"></a>3.2tomcat启动和配置</h3><p>文件夹结构:</p><p><img src="/2022/01/04/JavaWeb/05.png" alt="image-20220101090524114"></p><p><strong>启动和关闭</strong></p><p> <img src="/2022/01/04/JavaWeb/06.png" alt="image-20220101090649862"></p><p>点击即可</p><p>可看到命令行弹出 <strong>若闪退==&gt; 配置环境变量，检查是否错误！</strong></p><p><img src="/2022/01/04/JavaWeb/07.png" alt="image-20220101091655200"></p><p>在网页中输入：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>若页面显示，则正确</p><h3 id="3-3配置"><a href="#3-3配置" class="headerlink" title="3.3配置"></a>3.3配置</h3><p>服务器核心配置文件</p><p><img src="/2022/01/04/JavaWeb/08.png" alt="image-20220101091932529"></p><p>可以配置启动的端口号</p><ul><li>tomcat 默认端口号：8080</li><li>mysql ==&gt; 3306</li><li>http ==&gt; 80</li><li>https ==&gt; 443</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre><p>配置主机名</p><ul><li>默认主机名：localhost &lt;==&gt; 127.0.0.1</li><li>默认网站应用存在的位置==&gt;webapps</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span></code></pre><blockquote><p>面试题： 网站如何进行访问的！</p><ol><li>输入域名 ==&gt; 回车 </li><li>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件，看一下有无这个域名的映射<ol><li>有==&gt;直接返回对应ip，直接访问</li><li>无==&gt; 去DNS服务器找，找到就返回</li></ol></li></ol></blockquote><p><img src="/2022/01/04/JavaWeb/09.png" alt="image-20220101093806748"></p><p>可进行配置环境变量，方便启动</p><h3 id="3-4-发布一个web网站"><a href="#3-4-发布一个web网站" class="headerlink" title="3.4 发布一个web网站"></a>3.4 发布一个web网站</h3><p>模仿</p><ul><li><p>将自己写的网站，放在服务器tomcat指定的web文件夹下(webapps) ，就可以访问了</p></li><li><pre><code>--webapps: tomcat 服务器的web目录    -ROOT    -HUANGYIHENG 网站的目录        -WEB-INF            -classes :java 程序            -lib:web应用所依赖的包            -web.xml        -index.html 默认的首页        -static            -css                -style.ss            -js            -img        -...&lt;!--hexoPostRenderEscape:&lt;pre&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;## 4.HTTP&lt;/span&gt;</code></pre></li></ul><p><span class="hljs-section">### 4.1 什么是http</span></p><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在[<span class="hljs-string">TCP</span>](<span class="hljs-link"><a href="https://baike.baidu.com/item/TCP/33012">https://baike.baidu.com/item/TCP/33012</a></span>)之上。</p><p><span class="hljs-bullet">-</span> 文本：html，字符串<br><span class="hljs-bullet">-</span> 超文本：图片，音乐，视频，定位，地图<br><span class="hljs-bullet">-</span> 端口：80</p><p><span class="hljs-section">### 4.2两个时代</span></p><p><span class="hljs-bullet">-</span> http1.0<br><span class="hljs-bullet">  -</span> http/1.0 : 客户端对web服务器连接后，只能获得一个web资源，断开连接<br><span class="hljs-bullet">-</span> http2.0<br><span class="hljs-bullet">  -</span> http/1.1：客户端对web服务器连接后，可以获得多个web资源，</p><p><span class="hljs-section">### 4.3 http请求</span></p><p><span class="hljs-bullet">-</span> 客服端–&gt;发请求(request) –&gt; 服务器</p><p>百度：</p><p><span class="hljs-code">```java</span><br><span class="hljs-code">Request URL: <a href="https://www.baidu.com/">https://www.baidu.com/</a> </span><br><span class="hljs-code">Request method: GET    </span><br><span class="hljs-code">Status code: 200 OK</span><br><span class="hljs-code">Remote address: 127.0.0.1:7890</span>:hexoPostRenderEscape–&gt;</p><pre><code class="hljs java">Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=<span class="hljs-number">0.9</span>Cache-Control: max-age=<span class="hljs-number">0</span>Connection: keep-alive</code></pre><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<strong>请求行</strong></h4><ul><li>请求方式：get / post<ul><li>get:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li><li>post：请求能够携带的参数和大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效</li></ul></li></ul><h4 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2.消息头"></a>2.消息头</h4><pre><code class="hljs java">Accept: 告诉浏览器，支持的数据类型Accept-Encoding: 支持哪种编码格式 gbk utf-<span class="hljs-number">8</span> GB2312 ISO8859-<span class="hljs-number">1</span>Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接host: 主机</code></pre><h3 id="4-4-http响应"><a href="#4-4-http响应" class="headerlink" title="4.4 http响应"></a>4.4 http响应</h3><pre><code class="hljs java">Cache-Control: <span class="hljs-keyword">private</span>Connection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-<span class="hljs-number">8</span> </code></pre><h4 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1.响应体"></a>1.<strong>响应体</strong></h4><pre><code class="hljs groovy"><span class="hljs-attr">Accept:</span> 告诉浏览器，支持的数据类型Accept-<span class="hljs-attr">Encoding:</span> 支持哪种编码格式 gbk utf<span class="hljs-number">-8</span> GB2312 ISO8859<span class="hljs-number">-1</span>Accept-<span class="hljs-attr">Language:</span> 告诉浏览器，他的语言环境Cache-<span class="hljs-attr">Control:</span> 缓存控制<span class="hljs-attr">Connection:</span> 告诉浏览器，请求完是断开还是保持连接<span class="hljs-attr">host:</span> 主机<span class="hljs-attr">refresh :</span> 告诉客户端，多久刷新一次location ： 让网页重新定位 </code></pre><h4 id="2-响应状态码"><a href="#2-响应状态码" class="headerlink" title="2.响应状态码"></a>2.响应状态码</h4><ul><li>200 ：请求相应成功</li><li>3xx : 请求重定向 （你重新到我给你的新位置去</li><li>4xx：找不到资源 404 </li><li>5xx: 服务器代码错误  502 网关错误</li></ul><blockquote><p>面试题：当浏览器输入网址并回车一瞬间到页面显示出来，经历了什么？！</p></blockquote><h2 id="5-Maven"><a href="#5-Maven" class="headerlink" title="5 Maven"></a>5 Maven</h2><p>为何要学习Maven</p><blockquote><p>1.在javaweb开发中，需要使用大量的jar包，我们手动去导入</p><p>2.如何才能让一个东西自动帮我导入和配置这些jar包</p><p>于是  maven就诞生了！</p></blockquote><h3 id="5-1-maven项目管理工具"><a href="#5-1-maven项目管理工具" class="headerlink" title="5.1 maven项目管理工具"></a>5.1 maven项目管理工具</h3><p>方便导入jar包</p><p><strong>核心思想: 约定大于配置</strong></p><ul><li>有约束，不要去违反</li></ul><p>他会规定你如何去编写java代码，必须安装这个规范</p><h3 id="5-2-下载maven"><a href="#5-2-下载maven" class="headerlink" title="5.2 下载maven"></a>5.2 下载maven</h3><p><a href="https://maven.apache.org/">maven官网 </a>下载完解压即可</p><p><img src="/2022/01/04/JavaWeb/10.png" alt="image-20220101144018665"></p><h3 id="5-3配置maven"><a href="#5-3配置maven" class="headerlink" title="5.3配置maven"></a>5.3配置maven</h3><p>环境变量</p><ul><li>M2_HOME : maven目录下的bin目录</li><li>MAVEN_HOME ：maven 的目录</li><li>在系统的path中配置%MAVEN_HOME%\bin </li></ul><h3 id="5-4-阿里云镜像"><a href="#5-4-阿里云镜像" class="headerlink" title="5.4 阿里云镜像"></a>5.4 阿里云镜像</h3><p>mirrors(镜像)</p><ul><li>加速我们的下载</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span></code></pre><h3 id="5-5本地仓库"><a href="#5-5本地仓库" class="headerlink" title="5.5本地仓库"></a>5.5本地仓库</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:\environment\apache-maven-3.8.4\maven_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h3 id="5-6在idea中使用IDEA"><a href="#5-6在idea中使用IDEA" class="headerlink" title="5.6在idea中使用IDEA"></a>5.6在idea中使用IDEA</h3><p>创建maven web项目 如图</p><p><img src="/2022/01/04/JavaWeb/11.png" alt="image-20220101192126444"></p><p><img src="/2022/01/04/JavaWeb/12.png" alt="image-20220101192357597"></p><p><img src="/2022/01/04/JavaWeb/13.png" alt="image-20220101192825075"></p><p>成功后  若报错==&gt; 上述直接弄成idea的默认，然后新创建maven项目</p><p>进行疯狂下东西</p><p><img src="/2022/01/04/JavaWeb/14.png" alt="image-20220101194550504"></p><p>出现 BUILD SUCESS 代表成功</p><p><img src="/2022/01/04/JavaWeb/15.png" alt="image-20220101201841681"></p><p>在文件中多了文件</p><p><img src="/2022/01/04/JavaWeb/16.png" alt="image-20220101195042365"></p><p>也没配置本地仓库，比如在d盘。而这个.m2文件是系统默认的，自动生成的</p><p>在maven web程序下</p><p><img src="/2022/01/04/JavaWeb/17.png" alt="image-20220102085500377"></p><h3 id="5-7-创建普通的maven项目"><a href="#5-7-创建普通的maven项目" class="headerlink" title="5.7 创建普通的maven项目"></a>5.7 创建普通的maven项目</h3><p>不勾选模板<img src="/2022/01/04/JavaWeb/18.png" alt="image-20220102084704298"></p><p> 干净的maven项目 <img src="/2022/01/04/JavaWeb/19.png" alt="image-20220102085250133"></p><h3 id="5-8标记文件夹功能"><a href="#5-8标记文件夹功能" class="headerlink" title="5.8标记文件夹功能"></a>5.8标记文件夹功能</h3><p>在idea中对文件夹右键 </p><p><img src="/2022/01/04/JavaWeb/20.png" alt="image-20220102085749308"></p><h3 id="5-9配置tomcat"><a href="#5-9配置tomcat" class="headerlink" title="5.9配置tomcat"></a>5.9配置tomcat</h3><p><img src="/2022/01/04/JavaWeb/21.png" alt="image-20220102090742277"></p><p><img src="/2022/01/04/JavaWeb/22.png" alt="image-20220102090805674"></p><p><img src="/2022/01/04/JavaWeb/23.png" alt="image-20220102091333094"></p><p><img src="/2022/01/04/JavaWeb/24.png" alt="image-20220102091453659"></p><p><img src="/2022/01/04/JavaWeb/25.png" alt="image-20220102091629517"></p><p>进行启动</p><p><img src="/2022/01/04/JavaWeb/26.png" alt="image-20220102092343654"></p><p>成功会进行弹出！</p><p><img src="/2022/01/04/JavaWeb/27.png" alt="image-20220102092357538"></p><p>显示出的hello world 就是index.jsp中的内容</p><p><img src="/2022/01/04/JavaWeb/28.png" alt="image-20220102092513473"></p><p>此时成功！</p><p><strong>maven结构</strong></p><p><img src="/2022/01/04/JavaWeb/29.png" alt="image-20220102092717582"></p><h3 id="5-10-pom-xml文件"><a href="#5-10-pom-xml文件" class="headerlink" title="5.10 pom.xml文件"></a>5.10 pom.xml文件</h3> <pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-comment">&lt;!--maven版本和头文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-comment">&lt;!--  下面这是我们配置的GAV--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--  package 项目的打包方式jar：java应用war：javaweb应用--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-comment">&lt;!--name url 可删除--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>untitled Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!--配置--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--    项目的默认构建编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-comment">&lt;!--    编码版本--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--项目依赖--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--    具体依赖的jar包配置文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--  项目构建用的--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><strong>maven高级之处就在于他帮你导入这个jar包所依赖的其他jar包</strong></p><p><a href="https://mvnrepository.com/">maven仓库</a></p><p>只需加上dependency。在maven仓库中，选择自己需要的即可，maven将自己导入</p><p><img src="/2022/01/04/JavaWeb/30.png" alt="image-20220102095217578"></p><p>由于maven 约定大于配置 的规定，所以再之后写的配置文件，<strong>会出现无法导出或生效的问题</strong>，解决方法：</p><p>在mybatis 会遇到</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><p>若每次都需要重新配置，修改全局配置</p><p><img src="/2022/01/04/JavaWeb/31.png" alt="image-20220102102303101"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础</title>
    <link href="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/04/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1.综述"></a>1.综述</h2><blockquote><p>docker学习</p></blockquote><ul><li>概述</li><li>安装</li><li>命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li>docker镜像</li><li>容器数据卷</li><li>dockerFile</li><li>docker网络原理</li><li>idea整合docker</li><li>docker Compose</li><li>docker swarm</li><li>CI/CD jenkins</li></ul><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="Docker为何会出现？"><a href="#Docker为何会出现？" class="headerlink" title="Docker为何会出现？"></a>Docker为何会出现？</h3><p>一款产品：开发==&gt; 上线  应用环境，应用配置</p><p>即开发 &amp; 运维。但常常有一个问题：在我的电脑可以运行，版本更新以及其他问题导致服务不可以，对于运维，考验就很大</p><p>而且环境配置是十分麻烦的，每一个机器都要部署环境（集群Redis，ES，hadoop）===&gt; 费事费力！</p><p>发布一个项目jar包（需要redis，mysql，jdk，es等环境）===&gt; 如果等<strong>带着jar包 和 环境</strong>一起发布岂不妙！</p><p>docker的作用就是如此！</p><blockquote><p>传统：开发jar，其余运维来做</p><p>现在，开发打包部署上线，一套流程</p></blockquote><p>类比: </p><p>java — 开发apk—-发布(到应用商店) —- 使用的话只需下载apk—-安装即可</p><p>java — jar(环境) —- 打包项目带上环境(<strong>镜像</strong>) — 放到docker仓库(即上述的商店) —  下载发布的镜像 — 直接可以运行</p><blockquote><p>docker的思想来自于 集装箱 ！</p><p>jre – 多个应用，可能会产生端口冲突</p><p>隔离 ===&gt; docker的核心思想，打包装箱，每个箱子是互相隔离的</p><p>故docker利用隔离机制，可以将服务器利用到极致！</p></blockquote><h3 id="docker历史"><a href="#docker历史" class="headerlink" title="docker历史"></a>docker历史</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/01.png" alt="image-20220102155224157"></p><p><a href="https://www.docker.com/">Docker官网</a></p><p><a href="https://docs.docker.com/">docker官网文档</a> 超级详细！</p><p><a href="https://hub.docker.com/">docker仓库地址</a> 类似于github</p><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F/1574">镜像</a>中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>操作系统的机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318">沙箱</a>机制，相互之间不会有任何接口。</p></blockquote><h2 id="3-docker安装"><a href="#3-docker安装" class="headerlink" title="3.docker安装"></a>3.docker安装</h2><h3 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h3><p>架构图</p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/2.png" alt="docker"></p><p><strong>镜像(image)</strong>:</p><blockquote><p>​    docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像===&gt; run ===&gt; tomcat01容器(提供服务器)，</p><p>可以通过这个镜像创建多个容器（最终服务运行或项目运行就在容器</p></blockquote><p><strong>容器(container)</strong></p><blockquote><p>docker利用容器技术，独立运行一个或一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令</p><p>目前可以把容器理解成一个简单的linux系统</p></blockquote><p><strong>仓库(repository)</strong></p><blockquote><p>仓库就是存放镜像的地方，分为共有仓库和私有仓库</p><p>docker hub(默认是国外的)</p><p>阿里云….也有容器服务器(需要配置镜像加速，类似于maven一样需要配置)</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>环境准备：</strong></p><blockquote><p>​    1、会linux命令</p><p>​    2、CentOS</p><p>​    3、使用ssh(例如xshell等….)</p></blockquote><p><strong>环境查看</strong>：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统内核是3.10以上的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# uname -r3.10.0-1062.18.1.el7.x86_64</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre><p> <strong>安装</strong> ===&gt; 根据官方文档</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、Uninstall old versions</span>sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span class="hljs-meta">#</span><span class="bash"> 2.安装需要的安装包</span> sudo yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo # 默认是从国外下载<span class="hljs-meta">#</span><span class="bash"> 更新一下yum索引</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4安装docker相关内容</span> sudo yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta"> #</span><span class="bash"> 5 启动docker</span> sudo systemctl start docker<span class="hljs-meta"> #</span><span class="bash"> 6 查看是否安装成功</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker versionClient: Docker Engine - Community Version:           20.10.12 API version:       1.41 Go version:        go1.16.12 Git commit:        e91ed57 Built:             Mon Dec 13 11:45:41 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.12  API version:      1.41 (minimum version 1.12)  Go version:       go1.16.12  Git commit:       459d0df  Built:            Mon Dec 13 11:44:05 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.4.12  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d runc:  Version:          1.0.2  GitCommit:        v1.0.2-0-g52b36a2 docker-init:  Version:          0.19.0  GitCommit:        de40ad0</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7 测试hello world</span>sudo docker run hello-world</code></pre><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/03.png" alt="image-20220103095017939"></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8 查看安装的镜像是否存在</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>卸载</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1卸载依赖</span>sudo yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2 删除资源</span> sudo rm -rf /var/lib/docker #docker的默认工作路径 sudo rm -rf /var/lib/containerd</code></pre><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/04.png" alt="image-20220103095749769"></p><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://0wtfvcv1.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h3 id="HelloWorld运行的原理"><a href="#HelloWorld运行的原理" class="headerlink" title="HelloWorld运行的原理"></a>HelloWorld运行的原理</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/05.png" alt="image-20220103100328777"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>docker如何工作的？</strong></p><blockquote><p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令</p></blockquote><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/06.png" alt="image-20220103101049775"></p><p><strong>docker为何比虚拟机快？</strong></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/07.png" alt="image-20220103101338942"></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/08.png" alt="image-20220103101646104"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2022/01/03/leetcode01/"/>
    <url>/2022/01/03/leetcode01/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/two-sum/"> leetcode 第一题</a></p><p>day1</p><blockquote><p>给定一个<strong>整数数组 nums</strong> 和一个<strong>整数目标值 target</strong></p><p>请你在该数组中找出 和为目标值 target  的那 两个 整数，并<strong>返回它们的数组下标。</strong></p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><p><strong>示例 1：</strong></p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p><strong>示例 2：</strong></p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p><strong>示例 3：</strong></p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力算法 ===&gt; </p><ul><li>i 和 j 双重遍历==&gt; 依次找对应数组元素两者之和是否等于target</li><li>新建数组，长度为2。若上述找到，则将数组内的值赋值为 i 和 j</li><li>将新数组作为最终结果进行return</li></ul><pre><code class="hljs c"><span class="hljs-comment">//c语言实现</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;        *returnSize = <span class="hljs-number">2</span>;<span class="hljs-comment">//因为要返回的数组大小为2</span>        <span class="hljs-comment">//新开辟数组，作为返回结果</span>       <span class="hljs-keyword">int</span> *result = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (*returnSize));       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numsSize; i++) &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; numsSize;j++) &#123;               <span class="hljs-keyword">if</span>( *(nums + i) + *(nums + j) == target ) &#123;                    *result = i;                    *(result + <span class="hljs-number">1</span>) = j;               &#125;           &#125;       &#125;       <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//返回最终结果</span>       <span class="hljs-built_in">free</span>(result);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//java实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> result[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; nums.length;j++) &#123;                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;                    result[<span class="hljs-number">0</span>] = i;                    result[<span class="hljs-number">1</span>] = j;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>效率太低了，时间复杂度高</li></ul><p><strong>如何才能把复杂度降到 0(n^2)以下？</strong></p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>利用<strong>哈希查找</strong></p><ul><li>遍历nums,记 <strong>i 为当前的下标</strong>，看 i 对应nums中的值 是否 map中存在**target - nums[i]**的key值</li><li>若存在，则找到了两个值，不存在则将当前**(num[i],i)** 放入map</li><li>一直遍历至结束</li></ul><p>比如：nums = [2,7,11,15]</p><blockquote><p>1、开始i = 0 找2，target-num[0] = 13-2 = 11 ,该值不存在，即map表中记上 key-value==&gt; (2,0)</p><p>2、此时i = 1 找到7 ，target - num[1] = 13 - 7 = 6 ,也不在，继续记上key-value===&gt;( 7, 1)</p><p>3、此时 i = 2 ,找 11，target - num[2] = 13 - 11 = 2 , 此时key在表中，找到，进行返回 对应下标0和2</p></blockquote><p>map:</p><table><thead><tr><th>key</th><th>2</th><th>7</th><th></th><th></th></tr></thead><tbody><tr><td>value</td><td>0</td><td>1</td><td></td><td></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-comment">//java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;         HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();         <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>( map.containsKey( target-nums[i]) ) &#123;                res[<span class="hljs-number">0</span>] = map.get(target - nums[i]);                res[<span class="hljs-number">1</span>] = i;            &#125;            <span class="hljs-keyword">else</span> &#123;                map.put(nums[i],i);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>法二好好学习 体会 ！哈希表写法</p><p>也可以不创建res数组，直接进行返回，减少空间复杂度</p><pre><code class="hljs java">Class HashMap&lt;K,V&gt;<span class="hljs-comment">// K -钥匙的Map保持型    V -映射的值的类型</span>Interface Map&lt;K,V&gt;<span class="hljs-comment">//以下均是map接口中的方法</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function"><span class="hljs-comment">//返回 `true`如果这Map包含一个指定的键映射。更正式地说，返回  `true`当且仅当这个图中包含了一个关键的 `k`这样 `(key==null ? k==null :  key.equals(k))`映射。（最多可以有一个这样的映射。） </span></span><span class="hljs-function"></span><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function">返回指定的键映射的值，或 <span class="hljs-keyword">null</span>如果这个Map不包含的键映射。 </span><span class="hljs-function">    </span><span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key,V value)</span></span><span class="hljs-function">将指定的值与此映射中的指定键关联（可选操作）。如果映射以前包含一个键的映射，旧值将被指定的值替换</span></code></pre><p><img src="/2022/01/03/leetcode01/01.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希映射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html</title>
    <link href="/2021/07/18/html/"/>
    <url>/2021/07/18/html/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5-一"><a href="#HTML5-一" class="headerlink" title="HTML5(一)"></a>HTML5(一)</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Hyper Text Markup Language(超文本标记语言)</p><p>W3C  =  World Wide Web Consortium（万维网联盟)</p><p><a href="https://www.w3.org/">万维网联盟</a></p><p>标准： <strong>结构化</strong>标准语言(html,xml)、<strong>表现</strong>标准语言(css)、<strong>行为</strong>标准(dom，ECMASript)</p><p>利用intelliJ IDEA 进行开发  如图</p><p><img src="/2021/07/18/html/1.png"></p><h3 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--我是注释 --&gt;</span><span class="hljs-comment">&lt;!--DOCTYPE 告诉浏览器，使用什么规范 --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--head网页头部--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--meta 描述性信息 ，一般用于做SEO=搜索引擎优化--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--body网页主体--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="2、网页的基本标签"><a href="#2、网页的基本标签" class="headerlink" title="2、网页的基本标签"></a>2、网页的基本标签</h2><p>输入某个关键字，按tab键，快速生成</p><p>1、标题标签</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标题标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre><p>2、段落便签</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--段落标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>跑的快 跑得快<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>一直没有耳朵 一直没有尾巴<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>3、换行标签</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--换行标签--&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>跑的快 跑得快 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>一直没有耳朵 一直没有尾巴 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></code></pre><p>4、水平线标签</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--水平线标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></code></pre><p>5、字体样式标签</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--粗体 斜体--&gt;</span>粗体：<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>i love you！<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>斜体: <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>i love you!<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></code></pre><p>6、注释和特殊符号  </p><p><strong>&amp;开始 ; 结束</strong>  中间部分根据输入的字母提示找对应的符号</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--特殊符号  &amp;提示; --&gt;</span>空       格空<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>格<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-symbol">&amp;gt;</span> 大于<span class="hljs-symbol">&amp;lt;</span> 小于<span class="hljs-symbol">&amp;copy;</span> 版权符号</code></pre><p>7、图片标签</p><p>常见图片格式：JPG、gif、png、bmp…..</p><p>**相对地址(推荐使用)**和绝对地址</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!--img</span><span class="hljs-comment">src:图片地址（必填</span><span class="hljs-comment">../  上一级目录 但本idea需要使用./才可以正常显示</span><span class="hljs-comment">alt：图片名字 (必填</span><span class="hljs-comment">title：在网页上鼠标放上去会显示(可选</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;./resources/image/2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;名校&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;悬停文字&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;700&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>文件结果如图，以后就这样写！规范</p><p><img src="/2021/07/18/html/2.png"></p><h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p>必须掌握</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">a标签</span><span class="hljs-comment">href 必填，表示要跳转到哪个页面</span><span class="hljs-comment">target 表示窗口在哪打开</span><span class="hljs-comment">    _blank 表示在新标签中打开</span><span class="hljs-comment">    _self 表示在自己网页中打开(默认</span><span class="hljs-comment"></span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;1.我的第一个网页.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点击我跳转到页面1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点击我跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--锚链接</span><span class="hljs-comment">1需要一个锚标记</span><span class="hljs-comment">2跳转到此标记</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>功能性标签</p><p>第二个是<a href="https://shang.qq.com/v3/widget.html">qq推广</a>功能  里面自己粘贴过来</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--功能性标签</span><span class="hljs-comment">邮箱链接：mailto</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:1356410594@qq.com&quot;</span>&gt;</span>点击联系我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=1356410594&amp;site=qq&amp;menu=yes&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://wpa.qq.com/pa?p=2:1356410594:53&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>效果如图</p><p><img src="/2021/07/18/html/3.png"></p><h3 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h3><p>块元素：无论内容多少，只占一行 例如p标签</p><p>行内元素:内容撑开宽度，左右都是行内元素的可以排在一行</p><p>css中涉及块元素和行内元素转换</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1、有序列表</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--有序列表 order list ，li = list --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre><p>2、无序列表</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--无序列表--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>3、自定义列表</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--自定义列表</span><span class="hljs-comment">dl:标签</span><span class="hljs-comment">dt 列表名称</span><span class="hljs-comment">dd:列表内容</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>学科<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>位置<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>菏泽<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--表格 table</span><span class="hljs-comment">行 tr</span><span class="hljs-comment">列 td</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!--colspan 跨列 4表示跨4列    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>1-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!-- rowspan跨行 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></code></pre><p>如图</p><p><img src="/2021/07/18/html/4.png"></p><h3 id="视频和音频"><a href="#视频和音频" class="headerlink" title="视频和音频"></a>视频和音频</h3><p>video 和 audio</p><p><img src="/2021/07/18/html/Users\13564\AppData\Roaming\Typora\typora-user-images\image-20210717175509092.png" alt="image-20210717175509092"></p><h2 id="3、页面分析"><a href="#3、页面分析" class="headerlink" title="3、页面分析"></a>3、页面分析</h2><p><img src="/2021/07/18/html/5.png"></p><p>待续。。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言学习</title>
    <link href="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习！"><a href="#C语言再学习！" class="headerlink" title="C语言再学习！"></a>C语言再学习！</h2><p>利用Visual Studio </p><p>vs –debug 将监视窗口、调用堆栈、以及内存变化调整出来！</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2.png"></p><blockquote><p>错误：编译错误&amp;链接错误</p><p>​    编译错误：双击就可以定位到第几行</p><p>​    链接错误：库函数可能写错了！看对应函数符号</p></blockquote><p>​    </p><p>编辑main.c —&gt; 编译main.obj —&gt;和库函数进行链接—&gt;main.exe—-&gt;执行</p><p><strong>写代码——增量编写法，写一点进行测试测试</strong>，<strong>保证正确</strong>，<strong>再继续写</strong></p><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>​    1. <strong>基本类型</strong></p><ul><li>整型 int</li></ul><p>​            表示范围：-2^31 到 2^31 - 1</p><p>​                short 表示范围：-2 ^ 15 到 2 ^ 15 - 1</p><p>​                long 32位机器(4个字节)，64位机器(8个字节)  -2 ^ 63 到 -2 ^63 - 1</p><p>​                unsigned int 变化范围： 0 到 2^32 - 1</p><ul><li>字符型 char</li></ul><p>​                    \n  光标到下一行行首</p><p>​                    \r   光标回到当前行行首</p><p>​                    \b  向前退一格</p><ul><li>实型(浮点型)：</li></ul><p>​                单精度实型float(四个字节)；  有效数字：6-7位</p><p>​                双精度double(八个字节)       有效数字：15-16位</p><p>​    2.<strong>构造类型</strong></p><blockquote><p>数组类型[]</p><p>结构类型struct</p><p>联合类型union</p><p>枚举类型 enum</p></blockquote><p>​    3.*<em>指针类型 **</em></p><ol start="4"><li><strong>空类型(无值类) ：void</strong></li></ol><p>常量：例如 100，3.14，‘a’，“abc”</p><p>变量：代表内存中具有特定属性的一个存储单元，用来存放数据，这就是变量的值，<strong>在程序运行期间，这些值得程序的执行过程是可以改变的。</strong></p><p>符号常量：#define SUN 7</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/3.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/4.png"></p><blockquote><p>熟悉进制的转换</p></blockquote><p>vs采用小端：低位在前，高位在后</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5.png"></p><p>补码：按位取反再+1</p><h3 id="二、scanf原理"><a href="#二、scanf原理" class="headerlink" title="二、scanf原理"></a>二、scanf原理</h3><blockquote><p>输入读取接口：scanf，getchar</p><p>标准输出接口：printf，putchar</p></blockquote><p>1、标准输入缓冲区原理</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">char</span> c;<span class="hljs-comment">//用户输入</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; i = %d\n&quot;</span>,i);<span class="hljs-comment">//正常打印了</span><span class="hljs-comment">//清除缓冲区  ps:vs2013以上版本需要rewind(stdin)  </span>fflush(<span class="hljs-built_in">stdin</span>); <span class="hljs-comment">//如果没有这一句，则c不会等待用户输入，而是直接显示出来c = </span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c); <span class="hljs-comment">//为何？因为输入一个数之后，按回车了，\n在缓冲区里面，读取到了 \n 所以不会等待用户输入 </span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>,c); </code></pre><p><strong>当使用%d的时候，会忽略空格 和 \n</strong></p><p>scanf匹配原理：即是匹配到什么之后，删除什么，没有匹配的仍在缓冲区中</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5_1.png"></p><p>2、scanf循环读取</p><p><code>while( scanf(&quot;%d&quot;,&amp;i) != EOF )</code></p><p>进行完善</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i,ret<span class="hljs-comment">//即便输入的不是整型，也可以提供用户继续输入</span><span class="hljs-keyword">while</span> ( fflush(<span class="hljs-built_in">stdin</span>),(ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i)) != EOF ) </code></pre><p>3、混合读取 </p><pre><code class="hljs c"><span class="hljs-comment">//  %d %c中间加一个空格</span><span class="hljs-comment">//即在读取字符时，在字符前面加上空格</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c%f%lf&quot;</span>,&amp;i,&amp;c,&amp;f,&amp;d);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %5.2f %f &quot;</span>,i,c,f,d);</code></pre><p>getchar() 和 putchar()</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> c;c = getchar();<span class="hljs-built_in">putchar</span>(c);c = getchar();<span class="hljs-comment">//并不会再次阻塞，等待继续输入，而是直接结束，因为缓冲区里有\n,读取到直接退出了</span><span class="hljs-built_in">putchar</span>(c);</code></pre><p>printf()利用占位符进行对其</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-number">21</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;Yiheng&quot;</span>,<span class="hljs-number">5</span>);</code></pre><h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h3><p>*<em>1、算术运算符（ + - * / %）*</em></p><p><strong>2、关系运算符( &gt; ,&lt;, ==, &gt;= ,&lt;= , !=)</strong></p><p><strong>3、逻辑运算符( !,&amp;&amp;,|| )</strong></p><p><strong>4、位运算符( &lt;&lt;, &gt;&gt;, ~, | , ^ , &amp;)</strong></p><p>​            左移&lt;&lt; : 高位丢弃，低位补0，<strong>相当于乘2</strong>，但效率比乘法高</p><p>​            右移&gt;&gt;：**相当于除2 **  正数(unsigned)的话，低位丢弃，高位补0(直接除2);负数的话，低位丢弃，高位补1(减1再除2)</p><p><strong>5、赋值运算符 （ = 及其扩展赋值运算符 ）</strong></p><p><strong>6、条件运算符( ? : )  即三目运算符</strong></p><p><strong>7、逗号运算符 ( , )</strong></p><p>*<em>8、指针运算符 （ * 和 &amp;）*</em></p><p><strong>9、求字节数运算符（ sizeof() )</strong></p><p><strong>10、强制类型转换运算符 （ （类型） ）</strong></p><p><strong>11、分量运算符 (  .  -&gt; )</strong></p><p><strong>12、下标运算符 （ [ ]  ）</strong></p><p><strong>13、其他，如函数调用运算符:()</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6_1.png"></p><p><strong>算术运算符优先级高于关系运算符</strong></p><p><strong>关系运算符高于逻辑与和逻辑或</strong></p><p>a = 5  ==&gt;范围 -6到5</p><p> 0000 0101</p><p>1111 1010 ==&gt; 0000 0110 ==&gt; -6 </p><p>1111 1011 ==&gt;0000 0101 ==&gt; -5</p><p>ps:若要拿到任意一个数的最低位为1的那个数，不利用循环如何实现？<br>     1、若是循环，则此数字每一位和1进行&amp;运算，若为0，则1&lt;&lt;1，再进行下一位比较，为1则找到了<br>        2、利用 i &amp; -i = 最终低位为1的那个数字 ===&gt;该数与其对应补码进行&amp;操作</p><p>异或^：</p><p>​    <strong>任何数与自身异或为 0</strong> </p><p>​    <strong>任何数与0异或为其自身</strong></p><p>可利用异或对两个数进行交换，而不使用中间变量</p><p>交换两个数，三种方法</p><pre><code class="hljs c"><span class="hljs-comment">//1、利用异或，但必须有两个空间，不会出现溢出</span>a = <span class="hljs-number">5</span>,b = <span class="hljs-number">4</span>;a = a ^ b;b = a ^ b; <span class="hljs-comment">// 此时即为 b = (a^b) ^b = a</span>a = a ^ b; <span class="hljs-comment">//此时 a = (a ^ b ) ^ a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//2、利用数学运算对其进行交换,可能会溢出</span>a = a + b;b = a - b;<span class="hljs-comment">// b = (a + b) - b = a </span>a = a - b;<span class="hljs-comment">// a = (a + b) - a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//3、传统的，利用另一个变量temp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">7</span>,temp;temp = a;a = b;b = temp;</code></pre><p>例题：若数组中 101个数，50个数出现两次，1个数出现一次，找出出现一次的这个数的值？**(经典)**</p><p>对数组的的数进行异或操作</p><pre><code class="hljs C"><span class="hljs-comment">//简化版本</span><span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;    <span class="hljs-keyword">int</span> i ,result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); i++) &#123;        result ^= arr[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find value = %d\n&quot;</span>,result); <span class="hljs-comment">//最终输出为7</span></code></pre><p>自增和自减</p><p><code>j = i-- &gt; -2; //等价于j = i &gt; -2;i --</code></p><h3 id="四、选择，循环和数组"><a href="#四、选择，循环和数组" class="headerlink" title="四、选择，循环和数组"></a>四、选择，循环和数组</h3><p>1、if …else</p><p>2、switch</p><pre><code class="hljs angelscript"><span class="hljs-comment">// ( )里面不可以是浮点型表达式 </span><span class="hljs-keyword">switch</span>()&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">break</span>     dafault:<span class="hljs-keyword">break</span>;&#125;</code></pre><p>3、循环</p><p>（1）goto  学校老师讲的不用掌握goto是错误的，<strong>goto才是循环的本质</strong>，对应于汇编中的jmp跳转 </p><pre><code class="hljs C"><span class="hljs-comment">//求前100个数字的和</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;label:    sum += i;    i++;     <span class="hljs-comment">//需要进行判断，小于100才goto，不然一直循环</span>    <span class="hljs-keyword">if</span>( i &lt;= <span class="hljs-number">100</span>)&#123;        <span class="hljs-keyword">goto</span> label;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);</code></pre><p>（2） while  和  do ….while </p><p>（3） for</p><p>4、数组：具有<strong>相同数据</strong>类型的数据的<strong>有序</strong>集合</p><p>(1)、一维数组</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-comment">//定义数组的时候，必须初始化</span>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//arr[0]到arr[4]</span>    <span class="hljs-keyword">sizeof</span>(arr) <span class="hljs-comment">//大小为20个字节 5*4</span>    <span class="hljs-comment">//访问越界，提示stack around arr 代表栈空间访问越界</span>    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">6</span>;    arr[<span class="hljs-number">6</span>] = <span class="hljs-number">7</span>;    arr[<span class="hljs-number">7</span>] = <span class="hljs-number">8</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<span class="hljs-comment">//此时i变为8了，在vs中</span></code></pre><p>访问越界如图所示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/7.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/8.png"></p><p>当作为函数参数传递时，是传递的数组的起始地址，<strong>即数组名存的是数组的起始地址</strong>，不可以修改</p><p>C<strong>语言函数调用是值传递</strong></p><p>(2)、二维数组</p><pre><code class="hljs markdown">int a[<span class="hljs-string">3</span>][<span class="hljs-symbol">4</span>] = &#123;1,3,5,7,2,4,6,8,9,11,13,15&#125;;//范围a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]到a[<span class="hljs-string">2</span>][<span class="hljs-symbol">3</span>]sizeof(a) //48个字节sizeof(a[0])  //16个字节 sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">1</span>]) //4个字节</code></pre><p>(3)、字符数组</p><p>利用%s时scanf(“%s”,d)， 如果输出的有空格，则停止向后读</p><pre><code class="hljs C"><span class="hljs-comment">//这样打印，会出现乱码，因为利用%s打印，遇到\0会停下，并没有存地方\0标志，所以会在内存中打印至\0为止</span><span class="hljs-comment">//  \0代表结束标志 而\0的值即为0</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,c);<span class="hljs-comment">//建议，要有空间保存\0，即长度比字符长度大1</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;ABCDEF&quot;</span>;<span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">sizeof</span>(c); <span class="hljs-comment">// 为10</span><span class="hljs-built_in">strlen</span>(c); <span class="hljs-comment">//是5</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/9.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/10.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/11.png">当利用第二种方法存字符数组时，会在最后添上\0</p><pre><code class="hljs C">gets(c);<span class="hljs-comment">//会在最后添上\0，不会把\n读取到内存中   类似于scanf 也可能不安全，会访问越界</span> <span class="hljs-built_in">puts</span>(c)<span class="hljs-comment">//会在最后打印一个\n</span> <span class="hljs-comment">//等价于printf(&quot;%s\n&quot;,c);</span> <span class="hljs-comment">//循环输入字符串,并打印。按ctrl+z则会退出</span> <span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>]; <span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span> ) &#123;     <span class="hljs-built_in">puts</span>(c); &#125; <span class="hljs-comment">//安全，不会访问越界，当＞sizeof(c)时，系统不允许输入</span> <span class="hljs-comment">//并且会把\n读到内存中</span> fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>);</code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/12.png">例如：输入hello，fgets()会在后面增加\0和\0</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13.png">例：gets()情况，输入hello之后</p><p>str<strong>系列字符串操作函数</strong>   (在头文件#include&lt;string.h&gt;中)</p><pre><code class="hljs C"><span class="hljs-comment">//如果去除fget()后的最后一个\n呐？</span><span class="hljs-comment">//可以利用strlen获取最后的位置，然后替换成\0</span><span class="hljs-comment">//打印输出，并计算长度(去除\n)</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">size_t</span> len;<span class="hljs-keyword">while</span>( fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;    c[ <span class="hljs-built_in">strlen</span>(c) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//进行替换</span>    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输入什么则进行输出什么</span>    len = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);<span class="hljs-comment">//输出输入的长度</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//复制字符串 不能用于整型数组</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">char</span> d[<span class="hljs-number">50</span>];<span class="hljs-comment">//如果过小，会访问越界</span><span class="hljs-built_in">strcpy</span>(d,c);<span class="hljs-comment">//利用此接口进行赋值，会把c中\0读到d中，之后结束</span><span class="hljs-built_in">puts</span>(d);<span class="hljs-comment">//将字符进行拼接！</span><span class="hljs-built_in">strcat</span>(d,<span class="hljs-string">&quot;Yiheng&quot;</span>); <span class="hljs-comment">//最后会有\0</span></code></pre><p>strn<strong>系列字符串造作函数</strong></p><pre><code class="hljs C"><span class="hljs-comment">//strncpy</span><span class="hljs-keyword">int</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">50</span>];<span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//需要另加一句，保证要拷贝到的数组中元素为0</span>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));<span class="hljs-comment">//内置接口，此时将不会出现错误</span>    <span class="hljs-built_in">strncpy</span>(d,c,<span class="hljs-number">7</span>);<span class="hljs-comment">//将c中的前7个字符拷贝到d中，不会有\0结束符，知道内存中遇到\0才结束输出</span>    <span class="hljs-built_in">puts</span>(d);&#125;<span class="hljs-built_in">strncmp</span>(d,<span class="hljs-string">&quot;李宁&quot;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//判断前二个字节是否相等，即d中输入是否和‘李’相等(汉字占两个字节</span><span class="hljs-built_in">strncat</span>(d,<span class="hljs-string">&quot;牛牛牛&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//会部分拼接，把‘牛’拼到d后面</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> b[<span class="hljs-number">5</span>];<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//可以进行内存拷贝，不可以用strcpy()，因为遇到\0则停止拷贝</span></code></pre><h3 id="五、指针"><a href="#五、指针" class="headerlink" title="五、指针"></a>五、指针</h3><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-comment">//通过指针间接访问变量i</span><span class="hljs-keyword">int</span> *p = &amp;i;<span class="hljs-comment">//把i的地址保存起来，初始化必须是一个变量的取地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<span class="hljs-comment">//取保存起来地址所对应的值</span></code></pre><p>1、指针的使用场景：<strong>传递和偏移</strong></p><p>指针的传递：子函数要改变主函数的变量</p><pre><code class="hljs C"><span class="hljs-comment">//函数调用值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *i)</span></span>&#123;    *i /= <span class="hljs-number">2</span>;&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    change(&amp;i)<span class="hljs-comment">//这是会改变i的值，应该是传递的保存i的地址</span>&#125;</code></pre><p>指针的偏移(服务于数组)：p+1，是偏移的基类型的大小–&gt;sizeof(int)</p><pre><code class="hljs C"><span class="hljs-comment">//借助指针将数组元素输出</span><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> *p = &amp;a;<span class="hljs-comment">//数组名保存了数组的起始地址</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>,*(p + i)); <span class="hljs-comment">//其实a[i] &lt;==&gt; *(a+i)</span>&#125;</code></pre><p>2、指针和自增自减操作符</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> *p = a;<span class="hljs-keyword">int</span> j;j = *p++;<span class="hljs-comment">//==&gt;j = *p ,p ++;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 2 7</span>j = (*p)++ <span class="hljs-comment">//===&gt; j = *p,(*p)++;</span><span class="hljs-comment">//上面可改成j  = p[0] ++ 两者等价，不会有影响</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 7 8</span><span class="hljs-comment">//通过上述(*p)++,把数组中第二个元素7变成了8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[1] = %d\n&quot;</span>,a[<span class="hljs-number">1</span>]); <span class="hljs-comment">//8</span></code></pre><p>3、指针与一维数组</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>&#123;    *p = <span class="hljs-string">&#x27;H&#x27;</span>;    p[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;E&#x27;</span>;    *(p+<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;L&#x27;</span>;&#125;main()&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;hello&quot;</span>;    change(c);    <span class="hljs-built_in">puts</span>(c) <span class="hljs-comment">//输出  HELlo</span>&#125;</code></pre><p> (1)动态内存申请</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> needSize;<span class="hljs-keyword">char</span> *pStart;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;needStart);pStart = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(needSize);<span class="hljs-comment">//使用malloc动态申请堆空间</span><span class="hljs-comment">//向申请的空间填入数据</span><span class="hljs-built_in">strcpy</span>(pStart,<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-built_in">puts</span>(pStart);<span class="hljs-built_in">free</span>(pStart);<span class="hljs-comment">//最后用完进行释放</span><span class="hljs-comment">//释放完之后要将此指针赋值为NULL,不然就成了野指针</span>pStart = <span class="hljs-literal">NULL</span>;</code></pre><p>（2）野指针</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> *p1,*p2,*p3;p1 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p1 = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p1 = %d\n&quot;</span>,*p1);<span class="hljs-comment">//1</span>p2 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p2 = <span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p2 = %d\n&quot;</span>,*p2);<span class="hljs-comment">//2</span><span class="hljs-built_in">free</span>(p2);<span class="hljs-comment">//要加上p2 = NULL</span>p2 = <span class="hljs-literal">NULL</span>;p3 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p3 = <span class="hljs-number">3</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//3</span>*p2 = <span class="hljs-number">100</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//不加p2 = NULL ，会输出100</span><span class="hljs-comment">//由于p2被free了，但是后来p3申请空间不知道，p3申请会用p2释放的空间。之后又用了p2所以造成p3出现错误</span><span class="hljs-comment">//在free后面添加p2 = NULL;，如果再次使用p2则会产生错误为何</span></code></pre><p>(3)都是内存空间，为何分栈和堆？</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13_1.png"></p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>windows中栈空间有上限的，单个函数<span class="hljs-number">1</span>M，如果超过，则会Stack Overflow<span class="hljs-regexp">//</span>函数递归调用也有一个上限<span class="hljs-comment">#define N 500000</span>int a[N]<span class="hljs-regexp">//</span>执行到这里则会出现栈溢出</code></pre><p>(4)栈空间和堆空间的差异</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printStack</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;i am stack&quot;</span>;    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输出i am stack</span>    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printMalloc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;i am malloc&quot;</span>);    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出i am malloc</span>    <span class="hljs-keyword">return</span> p; &#125;main() &#123;    <span class="hljs-keyword">char</span> *p;    p = printStack();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//会出现乱码</span>    <span class="hljs-comment">//因为函数执行进行压栈，执行完之后弹栈</span>    <span class="hljs-comment">//之后执行puts的时候把原来函数的栈空间给占了</span>    <span class="hljs-comment">//应该怎么办，利用堆！</span>    p = printMalloc();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出 i am malloc</span>    <span class="hljs-built_in">free</span>(p);    p = <span class="hljs-literal">NULL</span>;&#125;</code></pre><p>(5)realloc动态扩容</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 20</span><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(MAX);<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,max = MAX;<span class="hljs-comment">//对其进行循环输入字符</span><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c) != EOF ) &#123;<span class="hljs-comment">//因为最后要放&#x27;\0&#x27;，故是max -1</span>    <span class="hljs-keyword">if</span>( i == max - <span class="hljs-number">1</span>) &#123;        p = (<span class="hljs-keyword">char</span> *)reallloc(p, max * <span class="hljs-number">2</span>);<span class="hljs-comment">//如果达到最后，利用realloc进行扩容</span>    &#125;    p[i] = c;<span class="hljs-comment">//每次输入的保存起来</span>    i++;&#125;p[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//将最后弄成结束标志，按下ctrl+z则会显示结果</span><span class="hljs-built_in">puts</span>(p);<span class="hljs-built_in">free</span>(p);p = <span class="hljs-literal">NULL</span>;</code></pre><p>（6）字符指针与字符数组初始化</p><p>申请完空间之后，为何<code>strcpy(p,&quot;i am malloc&quot;);</code>而不是 <code>p = &quot;i am malloc&quot;;</code></p><pre><code class="hljs C"><span class="hljs-keyword">char</span> *p = <span class="hljs-string">&quot;helloworld&quot;</span>; <span class="hljs-comment">//字符串存放在数据段的字符串常量区，是不可以修改的！p指向了首地址</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-comment">//这个是在代码段，可以修改</span>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 正确！ </span>p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 错误！！</span>p = <span class="hljs-string">&quot;how are you&quot;</span><span class="hljs-comment">//正确</span>c = <span class="hljs-string">&quot;how are you!&quot;</span><span class="hljs-comment">//错误！！因为c是起始地址，是只读的</span><span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;helloworld!&quot;</span>)<span class="hljs-comment">//错误，因为strcpy会对p[0]=&#x27;h&#x27;进行逐一赋值，但p空间此时不可以修改</span><span class="hljs-comment">//strcpy必须是可读可写的，即malloc申请的堆空间,或让p指向堆空间，指向可以修改的空间</span><span class="hljs-comment">//例如：</span>p = c;<span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;Yiheng&quot;</span>);<span class="hljs-comment">//此时正确</span></code></pre><p>(7)数组指针（服务于二维数组）</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> b[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//b数组名是保存了数组的起始地址 </span><span class="hljs-comment">//&amp;b也是保存了数组的起始地址，但&amp;b类型是数组指针，而b里面的类型为整型指针</span><span class="hljs-comment">//b+1 偏移的是数组类型的一个字节的大小，例如b + 1之后所对应地址的那个变量的值为2</span><span class="hljs-comment">//&amp;b+1 偏移的是整个数组字节大小，此时将跑到数组外面那个地址区域</span><span class="hljs-built_in">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<span class="hljs-comment">//a+1 指向2的起始地址</span><span class="hljs-comment">//&amp;a+1 指向15之后那个地方的地址(相当于&amp;a是一个二维数组指针,偏移整个数组的大小)</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14.png"></p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[][<span class="hljs-number">4</span>],<span class="hljs-keyword">int</span> row)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; row; i ++) &#123;         <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-keyword">sizeof</span>(*p) /<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> );j++)&#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*(*(p+i)+j));             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,p[i][j]);</span>             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,*(p[i]+ j));</span>         &#125;     &#125;&#125;main() &#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;    <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>];<span class="hljs-comment">//数组指针，指向一个长度为4的一维数组</span>    p = a;<span class="hljs-comment">//不会报错</span>    print(p,<span class="hljs-number">3</span>);&#125; <span class="hljs-comment">//动态二维数组</span>p = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">4</span>])<span class="hljs-built_in">malloc</span>( <span class="hljs-number">16</span> * <span class="hljs-number">100</span>);</code></pre><p> (7)二级指针  (<strong>只服务于一级指针的传递和偏移</strong>)</p><p>子函数内需要修改主函数某个一级指针的值，需要二级指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p1,<span class="hljs-keyword">int</span> **p2)</span> </span>&#123;    *p1 = *p2&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>,j = <span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> *p1 = &amp;i,*p2 = &amp;j;<span class="hljs-comment">//此时*p1 = 10,*p2 = 5;</span>    <span class="hljs-comment">//想改变*p1 = 5,*p2 = 10 </span>    change(&amp;p1,&amp;p2);<span class="hljs-comment">//此时利用二级指针成了交换</span>&#125;</code></pre><p>二级指针的初始化必须是某个一级指针变量的取地址</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">10</span>])</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPointerArr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;main()&#123;    <span class="hljs-keyword">char</span> b[N][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&quot;lilei&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;zhousi&quot;</span>&#125;;    <span class="hljs-keyword">char</span> **p = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * N);    print(b);<span class="hljs-comment">//打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>    printPointerArr(b);<span class="hljs-comment">//同样打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>&#125;</code></pre><p>(8)函数指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am b func&quot;</span>);&#125;main() &#123;    <span class="hljs-keyword">void</span> (*p) () <span class="hljs-comment">//p为函数指针</span>    p = b;<span class="hljs-comment">//初始化必须为某个函数的函数名</span>    p();<span class="hljs-comment">//打印i am b func</span>&#125;</code></pre><h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p> <strong>1、函数声明，定义，及调用</strong></p><p>​    通常将程序内容分别放在若干个源文件中，再由若干原程序文件组成一个C程序，便于<strong>分别编写，分别编译，提高调试效率</strong></p><p>点击’运行’即代表增量编译，如果之前运行过，则在运行的基础上进行编译(耗时很短)</p><p>右键–&gt;重新生成 则代表重新编译一次(但意义并不大，运行也慢)</p><p>函数不能嵌套定义</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14_1.png"></p><pre><code class="hljs C"><span class="hljs-comment">//main.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//函数调用</span>    printStar();    printMessage();&#125;<span class="hljs-comment">//func.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">//函数声明,作用：对函数的形参和返回值类型进行检查</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//fun.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-comment">//函数定义</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;how are you?&quot;</span>);&#125;</code></pre><p>2、函数的分类</p><blockquote><p>(1)标准函数，即库函数，系统提供的</p><p>(2) 用户自己定义的函数</p></blockquote><p>不同函数之间传递数据：</p><p>​    参数：通过形参和实参(调用完，空间则释放掉)</p><p>​    返回值：用return语句返回计算结果</p><p>​    全局变量：外部变量(不好，因为会一直占用着空间，也导致阅读困难)</p><p>3、函数的嵌套调用</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><span class="hljs-comment">//嵌套函数直接回到主函数，main调用a，a调用b，b直接回到main</span><span class="hljs-comment">// 函数将系统栈保存于envbuf中，以供以后调用longjmp()。当第一次调用setjmp(),它的返回值为零。</span><span class="hljs-comment">//之后调用longjmp(),longjmp()的第二个参数即为setjmp()的返回值</span>jmp_buf envbuf;<span class="hljs-comment">//全局变量</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am func b\n&quot;</span>);    longjmp(envbuf,<span class="hljs-number">5</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before,i am func a\n&quot;</span>);    b();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after,i am func a\n&quot;</span>);<span class="hljs-comment">//此时这一句不会打印</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ret;    ret = setjmp(envbuf);    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == ret) &#123;        a();&#125;</code></pre><p> 4、函数的递归调用</p><pre><code class="hljs C"><span class="hljs-comment">//爬楼梯，一次只能爬1或者2层</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-number">1</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> ( <span class="hljs-number">2</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-2</span>) + f(n<span class="hljs-number">-1</span>);&#125;</code></pre><p>5、变量及函数的作用域</p><p>​    局部变量和全局变量(内部变量和外部变量)</p><p><strong>变量在离自己最近的大括号内有效</strong></p><p>static—&gt;修饰局部变量，全局变量，函数</p><p><code>static int i = 0;</code>//静态变量只会初始化一次</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//局部变量加static</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//若没有static，则会多次执行此条语句</span>    i++;    print(<span class="hljs-string">&quot;%d\n&quot;</span>,i);&#125;main() &#123;<span class="hljs-comment">//每调用一次就会增加1</span>    fun();<span class="hljs-comment">//此时i = 1</span>    fun();<span class="hljs-comment">//此时i = 2</span>&#125;<span class="hljs-comment">//全局变量,以及函数 前加static，则表明不能被其他的文件借用了，只能在此文件中可见 </span>ps：另一个文件借用全局变量时，借用加<span class="hljs-keyword">extern</span>  </code></pre><h3 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h3><p>不同类型的数据组合成一个有机的整体</p><p>为了避免浪费空间，会把小字节的数据放在一起</p><pre><code class="hljs C"><span class="hljs-comment">//结构体定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">char</span> sex;    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">float</span> score;    <span class="hljs-keyword">char</span> address[<span class="hljs-number">30</span>];&#125;;<span class="hljs-comment">//结构体声明</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">s</span> = &#123;</span><span class="hljs-number">1001</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">98</span>,<span class="hljs-string">&quot;heze&quot;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">sArr</span>[3];</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.address);<span class="hljs-comment">//打印</span><span class="hljs-comment">//用户输入数据，scanf里面空格别忘记</span><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i ++) &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s %c%d%f%s &quot;</span>,&amp;sArr[i].num,sArr[i].name,&amp;sArr[i].sex,&amp;sArr[i].age,&amp;sArr[i].score,sArr[i].address);&#125;<span class="hljs-comment">/** 用户输入</span><span class="hljs-comment">1001 lili M 20 98 heze</span><span class="hljs-comment">1002 lele F 22 92 heze</span><span class="hljs-comment">1003 hehe M 19 88 heze</span><span class="hljs-comment">**/</span><span class="hljs-comment">//打印到屏幕</span><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,sArr[i].num,sArr[i].name,sArr[i].sex,sArr[i].age,sArr[i].score,sArr[i].address);&#125;</code></pre><p>通过<strong>结构体变量名.成员名</strong>来访问结构体成员</p><p>1、结构体指针</p><p>一个结构体变量的指针就是该变量所占据的内存段的起始地址。</p><p>可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址</p><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">float</span> score;&#125;<span class="hljs-keyword">student_t</span>,*pStudent_t;<span class="hljs-comment">//student_t就是结构体的别名 *pStudent_t等价于struct student*，可以利用这个定义指针</span>pStudent_t p1,p2;<span class="hljs-comment">//p1，p2均为结构体指针</span><span class="hljs-keyword">student_t</span> s = &#123;<span class="hljs-number">101</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">99</span>&#125;;<span class="hljs-keyword">student_t</span> *p = &amp;s;<span class="hljs-comment">//结构体指针</span><span class="hljs-comment">//利用指针访问成员变量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %0.2f\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;score);</code></pre><p>2、typedef定义变量 </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE; <span class="hljs-comment">//此时相当于INTERGE为int类型，即int的别名,编译的时候真正产生这个类型</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4<span class="hljs-comment">// 一般是定义常量，而且是在预处理时候直接替换,后面不需要加分号，上面那个需要加</span></span></code></pre><p>3、共用体与枚举</p><pre><code class="hljs C"><span class="hljs-comment">//联合体(共用体) 所有成员公用一块空间，并且不可修改</span><span class="hljs-keyword">union</span> data &#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">float</span> f;&#125;;<span class="hljs-comment">//枚举</span><span class="hljs-keyword">enum</span> weekday &#123;sun,mon,tue,wed,thus,fir,sat&#125;;<span class="hljs-comment">//sum = 0，mon = 2,.......</span></code></pre><h3 id="九、数据结构基础"><a href="#九、数据结构基础" class="headerlink" title="九、数据结构基础"></a>九、数据结构基础</h3><h4 id="1、链表的增删改查"><a href="#1、链表的增删改查" class="headerlink" title="1、链表的增删改查"></a>1、链表的增删改查</h4><p>线性表的两种存储结构：线性结构(<strong>数组</strong>）和链式结构(<strong>链表</strong>)</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/15.png"></p><p>写链表首先先定义结点！</p><pre><code class="hljs C"><span class="hljs-comment">//结点定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;        <span class="hljs-keyword">float</span> score;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">pNext</span>;</span> &#125;;</code></pre><p>新增：头插法，尾插法，有序插入</p><pre><code class="hljs C"><span class="hljs-comment">//结点的声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span>&#125;Student_t,*pStudent_t;<span class="hljs-comment">//头插法  参数是二级指针</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 新结点的next指针指向原有头结点，新结点作为头结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listHeadInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pNew-&gt;num = val;    <span class="hljs-comment">//判断链表是否为空</span>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-comment">//不空，则进行插入</span>    <span class="hljs-keyword">else</span> &#123;        pNew-&gt;next = *head;        *head = pNew;    &#125;&#125;<span class="hljs-comment">//尾插法</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 原来尾结点的next指针指向新结点，再将新结点作为尾结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listTailInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStduent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Stduent_t));    pNew-&gt;num = val;    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        (*tail)-&gt;next = pNew;        *tail = pNew;    &#125;&#125;<span class="hljs-comment">//有序插入</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//若不为空，如果头结点的值&gt;要插入结点的值==&gt;头插法;如果没有，则遍历链表，找到比插入值大的结点位置，新结点的next指针指向当前结点位置，前一个结点的next指针指向新结点;未找到插入位置，说明要放到链表尾部，尾插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listSortInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pStudent_t pCur,pPre;<span class="hljs-comment">//vs老版本中，定义必须放在前面，不然会错误</span>    pNew-&gt;num = val; <span class="hljs-comment">//进行初始化，不然结果为0</span>    pCur = pPre = *head;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( val &lt; pCur-&gt;num ) &#123;    <span class="hljs-comment">//头插法</span>        pNew-&gt;next = *head;        *head = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( <span class="hljs-literal">NULL</span> != pCur) &#123;        <span class="hljs-comment">//找到了结点比要插入的结点大，这说明插入这中间</span>            <span class="hljs-keyword">if</span>( pCur-&gt;num &gt; val ) &#123;                pPre-&gt;next = pNew;                pNew-&gt;next = pCur;<span class="hljs-comment">//在这一步之前，要保证前一个结点不能丢失</span>                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//保证pCur向前走，而pPre跟在pCur之后那个位置，即:pPre先赋值成pCur(保存好位置),pCur再走</span>            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有插入到中间，则pCur == NULL,则插入到最后</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            pPre-&gt;next = pNew;            *tail = pNew;        &#125;    &#125;&#125;<span class="hljs-comment">//主函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    pStduent_t phead = <span class="hljs-literal">NULL</span>,pTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) != EOF) &#123;        listHeadInsert(&amp;pHead,&amp;pTail,<span class="hljs-keyword">int</span> num);<span class="hljs-comment">//要将地址进行传入</span>    &#125;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//删除链表中的结点</span><span class="hljs-comment">/*</span><span class="hljs-comment">    判断是否为空==&gt;为空打印，链表为空</span><span class="hljs-comment">    判断删除值是不是头结点==&gt;是的话==&gt;头结点的pNext赋值给头结点，free删除的结点空间，如果删除结点后链表为空，设置尾指针为NULL</span><span class="hljs-comment">    不是的话==&gt;遍历链表，找到要删除的值，将前一个结点的pNext的指针指向删除结点的下一个结点，判断删除结点地址值是否等于尾指针，相等==&gt;说明删除为尾结点，尾指针指向前一个结点，之后free删除的结点；若没有找到删除的结点，打印没有发现删除结点的值</span><span class="hljs-comment">    </span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> deleteNum)</span> </span>&#123;    <span class="hljs-comment">//pCur用来指向被删除的结点，一直遍历，pPre指向pCur的前一个结点</span>    pStudent_t pCur = *head,pPre;    pPre = pCur;    <span class="hljs-comment">//判断是否为空</span>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pCur) &#123;        print(<span class="hljs-string">&quot;list is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//删除头部结点</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pCur-&gt;num == deleteNum) &#123;        *head = pCur-&gt;next;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head ) &#123;            *tail = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-comment">//删除头部或尾部</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( *head != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span> ( pCur-&gt;next == deleteNum) &#123;                pPre-&gt;next = pCur-&gt;next;                <span class="hljs-keyword">break</span>;            &#125;            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有找到对应结点</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find deleteNum\n&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (pCur == *tail) &#123;            *tail = pPre;        &#125;    &#125;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//修改链表中的元素</span><span class="hljs-comment">//并不需要修改头指针，所以传入一级指针就行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listModify</span><span class="hljs-params">(pStudent head,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">float</span> score)</span> </span>&#123;    <span class="hljs-keyword">while</span> ( head != <span class="hljs-literal">NULL</span> ) &#123;        <span class="hljs-keyword">if</span>( head-&gt;num = num) &#123;            head-&gt;socre = socre;        &#125;        head = head-&gt;next;    &#125;    <span class="hljs-keyword">if</span> ( head == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find modify num\n&quot;</span>);    &#125;&#125;</code></pre><h4 id="2、常用数据结构和算法"><a href="#2、常用数据结构和算法" class="headerlink" title="2、常用数据结构和算法"></a>2、常用数据结构和算法</h4><p>设计数据结构，就是为了高效管理数据。</p><p>有效的存取方法可提高我们访问数据的效率，即算法</p><p>需要掌握的数据结构</p><p><strong>数组，栈，队列，链表，树，堆，散列表，图…..</strong></p><h5 id="1-、栈-stack"><a href="#1-、栈-stack" class="headerlink" title="(1)、栈(stack)"></a>(1)、栈(stack)</h5><p>后进先出</p><pre><code class="hljs C"><span class="hljs-comment">//栈的定义</span><span class="hljs-comment">//结点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> *<span class="hljs-title">pNext</span>;</span>&#125;Node_t,*pNode_t ;<span class="hljs-comment">//利用链，栈的结构体</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    pNode_t head;    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈的大小</span>&#125;Stack_t,pStack_t;<span class="hljs-comment">//一系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//初始化栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//入栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//返回栈的大小</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//确定栈是否为空</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">stack</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Stack_t));<span class="hljs-comment">//系统内置接口，在&lt;string.h&gt;中，用于将内存初始化某值</span>    <span class="hljs-comment">//是将Stack_t中的分量设置为0的快捷的方法</span>    <span class="hljs-comment">//void *memset( void *buffer, int ch, size_t count );</span>    <span class="hljs-comment">// 拷贝ch到buffer从头开始的count个字符里，并返回buffer指针</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//入栈，头插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-comment">//既然是入栈，肯定是要申请结点空间</span>    pNode_t pNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pNew-&gt;val = val;    pNew-&gt;pNext = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-built_in">stack</span>-&gt;head = pNew;    <span class="hljs-built_in">stack</span>-&gt;size ++;&#125;<span class="hljs-comment">//出栈，头部删除法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-comment">//先判断是否栈为空</span>    pNode_t pCur;<span class="hljs-comment">//因为要删除结点，肯定要free,所以必须要个pCur</span>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//之后进行pop</span>    pCur = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-comment">//stack-&gt;head = stack-&gt;head-&gt;pNext;</span>    <span class="hljs-built_in">stack</span>-&gt;head = pCur = pCur-&gt;pnext;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//防止野指针</span>    <span class="hljs-built_in">stack</span>-&gt;size --;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;head-&gt;val;&#125;<span class="hljs-comment">//返回栈的元素个数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;size;&#125;<span class="hljs-comment">//判断是否为空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">stack</span>-&gt;size;&#125;</code></pre><h5 id="2-、队列"><a href="#2-、队列" class="headerlink" title="(2)、队列"></a>(2)、队列</h5><p>循环队列</p><pre><code class="hljs C"><span class="hljs-comment">//循环队列的定义，利用数组实现</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 5</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType data[MaxSize];    <span class="hljs-keyword">int</span> front,rear;&#125;SqQueue_t;<span class="hljs-comment">//系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *)</span></span>;<span class="hljs-comment">//初始化队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *,ElemType )</span></span>;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t *,ElemType* )</span></span>;<span class="hljs-comment">//出队,利用了传出参数</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化循环队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>)</span> </span>&#123;    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-rear = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>,ElemType x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否满了</span>    <span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; queue is full\n&quot;</span>);    &#125;    <span class="hljs-comment">//入队，放入x</span>    <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;rear] = x;    <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize;<span class="hljs-comment">//rear向前走</span>&#125;<span class="hljs-comment">//出队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t* <span class="hljs-built_in">queue</span>,ElemType *x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty\n&quot;</span>);    &#125;    <span class="hljs-comment">//出队</span>    *x = <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;front];    <span class="hljs-built_in">queue</span>-&gt;front = ((<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize)&#125;</code></pre><h5 id="3-、二叉树"><a href="#3-、二叉树" class="headerlink" title="(3)、二叉树"></a>(3)、二叉树</h5><p><strong>每个结点最多有两个子树的树结构！</strong></p><p>二叉树常用于实现 <strong>二叉查找树 和 二叉堆</strong></p><p><strong>层次建树==&gt;辅助队列</strong></p><p>k层，总节点数 2^k - 1</p><p>完全二叉树：只允许最后一层有空缺且在右边。对任一结点，其右子树的深度为j，则左子树深度必为j或j+1,度为1的点只有1个或0个</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<span class="hljs-comment">//结点声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span></span><span class="hljs-class">&#123;</span>    ElemType c;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pleft</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pright</span>;</span>&#125;Node_t,*pNode_t;<span class="hljs-comment">//2、利用辅助队列进行层次建树</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span></span><span class="hljs-class">&#123;</span>    pNode_t insertPos; <span class="hljs-comment">//要插入结点的位置</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span> *<span class="hljs-title">pNext</span>;</span>&#125;Queue_t,*pQueue_t;<span class="hljs-comment">//接口声明</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//前序遍历==&gt;根左右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//中序遍历==&gt;左根右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//后序遍历===&gt;左右根</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t*,pQueue_t*,pQueue_t *,<span class="hljs-keyword">int</span> )</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span> )     &#123;        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);        <span class="hljs-built_in">putchar</span>(root-c);    &#125;&#125;<span class="hljs-comment">//2、层次建树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t *treeRoot,pQueue_t *queHead,pQueue_t *queTail,<span class="hljs-keyword">int</span> val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//申请结点</span>    pNode_t treeNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pQueue_t queNew = (pQueue_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Queue_t));    pQueue_t queCur = *queHead;<span class="hljs-comment">//指向给哪个元素结点放孩子 </span>    treeNew-&gt;c = val;    queNew-&gt;insertPos = treeNew;    <span class="hljs-comment">//判断是否有根节点</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *treeRoot )    &#123;        *treeRoot = treeNew;        *queHead = queNew;        *queTail = queNew;    &#125;    <span class="hljs-comment">//根节点不为空，找插入位置</span>    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//队列操作，把元素放入队列===&gt;尾插法</span>        (*queTail)-&gt;pNext = queNew;        *queTail = queNew;        <span class="hljs-comment">//判断左子树是否空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pleft )        &#123;            queCur-&gt;inSertPos-&gt;pleft = treeNew;        &#125;        <span class="hljs-comment">//判断右子树是否为空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pright )        &#123;            queCur-&gt;insertPos-&gt;pright = treeNew;            <span class="hljs-comment">//先保存后释放,某个结点左右孩子都有了之后，出队</span>            *queHead = queCur-&gt;pNext;            <span class="hljs-built_in">free</span>(queCur);            queCur = <span class="hljs-literal">NULL</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1、可利用数组进行层次建树</span>    ElemType c[] = <span class="hljs-string">&quot;ABCDEFJHI&quot;</span>;    pNode_t p[N];<span class="hljs-comment">//p为指针数组</span>    <span class="hljs-keyword">int</span> i,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j记住往哪个结点放数据</span>    <span class="hljs-comment">//为每个结点申请空间，同时把结点值放进去</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        p[i] = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));        p[i]-&gt;c = c[i];    &#125;    <span class="hljs-comment">//第一个结点A不需要建立，即A自己也是。故从1开始进入</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;N;i++)<span class="hljs-comment">//外层控制进入的元素</span>    &#123;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p[j]-&gt;pleft )<span class="hljs-comment">//内层比较，找位置</span>        &#123;            p[j]-&gt;pleft = p[i];<span class="hljs-comment">//为空，则放入</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( NUll == p[j]-&gt;pright )        &#123;            p[j]-&gt;pright = p[i];            j++;<span class="hljs-comment">//插入完之后，跑到B位置等待左右孩子插入其中(j初始为0)</span>        &#125;    &#125;    <span class="hljs-comment">//2、辅助队列进行层次建树</span>    ElemType val;    pNode_t treeRoot = <span class="hljs-literal">NULL</span>;    pQueue_t queHead = <span class="hljs-literal">NULL</span>,queTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%c&quot;</span>,&amp;val) != EOF)    &#123;        <span class="hljs-keyword">if</span>( val == <span class="hljs-string">&#x27;\n&#x27;</span> ) &#123;            <span class="hljs-keyword">break</span>;        &#125;        BuildBinaryTree(&amp;treeRoot,&amp;queHead,&amp;queTail,val);    &#125;&#125;</code></pre><h5 id="4-、排序算法"><a href="#4-、排序算法" class="headerlink" title="(4)、排序算法"></a>(4)、排序算法</h5><p>时间复杂度和空间复杂 </p><p>时间复杂度====&gt;大O符号表示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/16.png"></p><p><strong>掌握八种算法：冒泡，选择，插入，希尔，快排，堆排，归并，基排</strong>.  </p><blockquote><p>插入类：插入排序，希尔排序</p><p>选择类：选择排序，堆排序</p><p>交换类：冒泡排序，快速排序</p><p>归并类：归并排序</p><p>分配类：基数排序、计数排序、桶排序，同额外的空间来分配和收集，继而实现排序</p></blockquote><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/17.png"> </p><p><strong>qsort重点掌握！！！</strong></p><h5 id="lt-1-gt-冒泡"><a href="#lt-1-gt-冒泡" class="headerlink" title="&lt;1&gt;冒泡"></a>&lt;1&gt;冒泡</h5><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">2001 li 45.5 96.5 70.4</span><span class="hljs-comment">2009 liu 98.5 78.5 98.6</span><span class="hljs-comment">2003 lin 78 83.5 79.6</span><span class="hljs-comment">2004 zhang 95 93.5 80.5</span><span class="hljs-comment">2005 wang 88.5 75.7 40.6</span><span class="hljs-comment">*/</span><span class="hljs-comment">/* 冒泡排序</span><span class="hljs-comment">1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><span class="hljs-comment">2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><span class="hljs-comment">3、针对所有的元素重复以上的步骤，除了最后一个。</span><span class="hljs-comment">4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  SWAP(a,b) &#123;int tmp;tmp = a; a = b;b = tmp;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; N;i++)    &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>;i &lt; N - <span class="hljs-number">1</span> - i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])            &#123;                SWAP(arr[j],arr[j+<span class="hljs-number">1</span>])            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="lt-2-gt-选择"><a href="#lt-2-gt-选择" class="headerlink" title="&lt;2&gt;选择"></a>&lt;2&gt;选择</h5><pre><code class="hljs C"><span class="hljs-comment">/*选择排序</span><span class="hljs-comment">首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</span><span class="hljs-comment">然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span><span class="hljs-comment">以此类推，直到所有元素均排序完毕</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,maxPos;    <span class="hljs-keyword">for</span>(i = N;i&gt;<span class="hljs-number">0</span>;i++)    &#123;        maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>( j = <span class="hljs-number">1</span>;j &lt; i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[maxPos])            &#123;                maxPos = j;            &#125;        &#125;        SWAP(arr[maxPos,arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-3-gt-插入"><a href="#lt-3-gt-插入" class="headerlink" title="&lt;3&gt;插入"></a>&lt;3&gt;插入</h5><pre><code class="hljs C"><span class="hljs-comment">/*认为零号元素自然有序,从1号元素开始插入</span><span class="hljs-comment">先存储插入元素的值，从后向前，依次拿有序序列的值，依次与插入元素的值进行比较</span><span class="hljs-comment">如果有序序列值大于插入元素值，有序序列值向后移动一位，找到插入元素值的位置，将插入元素值放入对应位置</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>;i &lt; N;i++)     &#123;        InsertVal = arr[i];        <span class="hljs-keyword">for</span> (j = i <span class="hljs-number">-1</span>;j &gt;= <span class="hljs-number">0</span>; j--)         &#123;            <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )             &#123;                arr[j + <span class="hljs-number">1</span>] = arr[j];            &#125;            <span class="hljs-keyword">else</span>             &#123;                <span class="hljs-keyword">break</span>;            &#125;            &#125;        arr[j + <span class="hljs-number">1</span>] = InsertVal;        &#125;&#125;</code></pre><h5 id="lt-4-gt-希尔"><a href="#lt-4-gt-希尔" class="headerlink" title="&lt;4&gt;希尔"></a>&lt;4&gt;希尔</h5><pre><code class="hljs C"><span class="hljs-comment">//希尔排序,需要一个步长,步长以长度的1/2开始，每次步长除2减少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrShell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal,gap;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>(gap = N &gt;&gt; <span class="hljs-number">1</span>;gap &gt;<span class="hljs-number">0</span>;gap &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-comment">//gap 除以2 ,利用移位可调高效率</span>    &#123;        <span class="hljs-keyword">for</span>( i = gap;i &lt; N;i++)         &#123;            InsertVal = arr[i];            <span class="hljs-keyword">for</span> (j = i -gap;j &gt;= <span class="hljs-number">0</span>; j= j - gap)             &#123;                <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )                 &#123;                    arr[j + gap] = arr[j];                &#125;                <span class="hljs-keyword">else</span>                 &#123;                    <span class="hljs-keyword">break</span>;                &#125;                &#125;            arr[j + gap] = InsertVal;            &#125;    &#125;&#125;</code></pre><h5 id="lt-5-gt-快排"><a href="#lt-5-gt-快排" class="headerlink" title="&lt;5&gt;快排"></a>&lt;5&gt;快排</h5><pre><code class="hljs C"><span class="hljs-comment">/*递归进行，开始进行partition划分，选择最后一个元素作为分割值，将比分隔值小的放在分隔值的左边，比分隔值大的放在分隔值的右边，此时分隔值的位置就确定了，故返回分隔值的下标。此时数组一分为二，对前半部分和后半部分继续进行分割，重复操作，进行递归</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,k;<span class="hljs-comment">//i遍历数组，k记录比右边小的数的位置</span>    <span class="hljs-keyword">for</span>(i = left,k = left;i &lt; right;i++)     &#123;        <span class="hljs-comment">//进行交换</span>        <span class="hljs-keyword">if</span>(arr[right] &gt;  arr[i])        &#123;            SWAP(arr[i],arr[k]);            k++;        &#125;    &#125;    SWAP(arr[k],arr[right]);    <span class="hljs-keyword">return</span> k;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrQuick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span>( left &lt; right )    &#123;        <span class="hljs-keyword">int</span> pivot;        pivot = partition(arr,left,right);        arrQuick(arr,left,pivot - <span class="hljs-number">1</span>);        arrQuick(arr,pivot + <span class="hljs-number">1</span>,right);    &#125;&#125;</code></pre><h5 id="lt-6-gt-堆排"><a href="#lt-6-gt-堆排" class="headerlink" title="&lt;6&gt;堆排"></a>&lt;6&gt;堆排</h5><p>什么是堆===&gt;用数组去存一棵树</p><p>左孩子 son = 2 * dad + 1 (位置而言)</p><p><strong>大根堆(大顶堆)：若父结点的值恒大于等于子结点的值</strong>，若从小到大排序，需要建立大顶堆</p><p><strong>小根堆(小顶堆)：若父结点的值小于等于子结点的值</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/18.png"></p><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">    堆排序</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_max_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> adjust_pos,<span class="hljs-keyword">int</span> len)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dad = adjust_pos;    <span class="hljs-keyword">int</span> son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子</span>    <span class="hljs-keyword">while</span>( son &lt; len)    &#123;        <span class="hljs-comment">//可能没右孩子，先判断右孩子是存在及右孩子是否大于左孩子</span>        <span class="hljs-keyword">if</span>( son + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) &#123;            son ++;        &#125;        <span class="hljs-keyword">if</span>(arr[son] &gt; arr[dad]) &#123;            SWAP(arr[son],arr[dad]);            <span class="hljs-comment">//因为一个调整后，可能或影响其他的，导致其他的需要再次调整，所以进行循环调整</span>            <span class="hljs-comment">//把交换完的重新作为dad，再次判断</span>            dad = son;            son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">//倒着从最后一个父结点开始调整</span>    <span class="hljs-keyword">for</span>( i = N/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> ; i--) &#123;        adjust_max_heap(arr,i,N);    &#125;    <span class="hljs-comment">//接着需要进行有序化</span>    <span class="hljs-comment">//把最后一个结点和根节点交换，接着最后一个结点是最大的，去除！再进行调整</span>    SWAP(arr[<span class="hljs-number">0</span>],arr[N<span class="hljs-number">-1</span>]);     <span class="hljs-keyword">for</span>( i = N - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">1</span> ; i--) &#123;        <span class="hljs-comment">//因为只破坏了根部，所以只需一直调整根部为大根堆</span>        adjust_max_heap(arr,<span class="hljs-number">0</span>,i);        SWAP(arr[<span class="hljs-number">0</span>],arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-7-gt-归并"><a href="#lt-7-gt-归并" class="headerlink" title="&lt;7&gt;归并"></a>&lt;7&gt;归并</h5><pre><code class="hljs C"><span class="hljs-comment">//归并</span><span class="hljs-comment">//合并两个有序数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> high)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> b[N];    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i = low;i &lt;= high;i++)    &#123;        b[i] = arr[i];    &#125;    <span class="hljs-keyword">for</span>(k = low,i = low,j = mid + <span class="hljs-number">1</span>;i &lt;= mid &amp;&amp; j&lt;= high;)    &#123;        <span class="hljs-keyword">if</span>(b[i] &lt; b[j])        &#123;            arr[k] = b[i];            k++;            i++;        &#125;        <span class="hljs-keyword">else</span>        &#123;            arr[k] = b[j];            k++;            j++;        &#125;    &#125;    <span class="hljs-keyword">while</span>(i &lt;= mid)    &#123;        arr[k] = b[i];        k++;        i++;    &#125;    <span class="hljs-keyword">while</span>(j &lt;= high)    &#123;        arr[k] = b[j];        k++;        j++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">if</span>(low &lt; high)     &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        arr_merge(arr,low,mid);        arr_merge(arr,mid + <span class="hljs-number">1</span>,high);        merge(arr,low,mid,high);    &#125;&#125;</code></pre><h5 id="lt-8-gt-计数排序"><a href="#lt-8-gt-计数排序" class="headerlink" title="&lt;8&gt;计数排序"></a>&lt;8&gt;计数排序</h5><p>空间换时间！====  数据的范围必须是有限的</p><pre><code class="hljs C"><span class="hljs-comment">//申请一个被排序数的范围大小的空间arr_count,遍历数组，统计数组中每个值出现的次数</span><span class="hljs-comment">//遍历arr_count，根据每个值出现的次数，对要排序的数组进行填充</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>     M 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">int</span> arr_count[M] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">//统计出arr数组中，每个值出现的次数</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        arr_count[arr[i]]++;    &#125;    k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; M;i++)    &#123;        <span class="hljs-keyword">for</span>(j= <span class="hljs-number">0</span> ;j&lt;arr_count[i];j++)        &#123;            arr[k] = i;            k++;        &#125;    &#125;&#125;</code></pre><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/19.png"> </p><p>涉及到磁盘的===&gt;尽可能少读磁盘，速度太慢</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/20.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/21.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/22.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/23.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/24.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/25.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/26.png"> </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>针对有序数组~</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high,<span class="hljs-keyword">int</span> target)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(low &lt;= high)    &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>( arr[mid ] &gt; target)        &#123;            high = mid <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( arr[mid ] &lt; target)        &#123;            low = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><h5 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h5><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/27.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28_1.png"></p><p><strong>哈希冲突</strong></p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29_1.png"></p><p>建议用链表法</p><pre><code class="hljs C"><span class="hljs-comment">//哈希查找：通过哈希函数对要找的字符串进行哈希计算，得到key值(数组下标)，通过key去哈希表中得到对应的元素</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxKey 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *key)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//ELF hash函数</span>    <span class="hljs-comment">//下面是公式！冲突会比较少，经验！</span>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>,g;    <span class="hljs-keyword">while</span>( *key )    &#123;        h = (h &lt;&lt; <span class="hljs-number">4</span>) + *key++;        g = h &amp; <span class="hljs-number">0xf0000000</span>;        <span class="hljs-keyword">if</span>(g)         &#123;            h ^= g &gt;&gt; <span class="hljs-number">24</span>;        &#125;        h &amp;= ~g;    &#125;    <span class="hljs-keyword">return</span> h % MaxKey;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_hash</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *pStr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;xiongda&quot;</span>,<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;wangdao &quot;</span>,<span class="hljs-string">&quot;fenghua&quot;</span>&#125;;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *pHash_table[MaxKey] = &#123;<span class="hljs-literal">NULL</span>&#125;;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is key = %d\n&quot;</span>,pStr[i],hash(pStr[i]));        pHash_table[hash(pStr[i])] = pStr[i];    &#125;&#125;</code></pre><h3 id="十、文件操作"><a href="#十、文件操作" class="headerlink" title="十、文件操作"></a>十、文件操作</h3><p><strong>程序执行时成为进程</strong>，进程运行过程中的数据均在内存中。需要存储运算后的数据时，就需要使用文件</p><p>文件是指存储在外部介质(磁盘或磁带)上的数据集合。操作系统是以文件为单位对数据进行管理的</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/30.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/31.png"> </p><p>1、文件的打开、读写、关闭  </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/32.png">  </p><pre><code class="hljs C"><span class="hljs-comment">//从文件中读</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> c;    FILE *fp;<span class="hljs-comment">//是结构体指针，系统定义好的</span>    fp = fopen(<span class="hljs-string">&quot;text.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//r表示只读</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == fp )    &#123;        perror(<span class="hljs-string">&quot;fopen&quot;</span>);<span class="hljs-comment">//如果指针错误，则利用perror定位错误信息</span>        <span class="hljs-keyword">goto</span> error;    &#125;    <span class="hljs-comment">//把text.txt文件的内容打印到屏幕上</span>    <span class="hljs-keyword">while</span>( (c = fgetc(fp)) != EOF)    &#123;        <span class="hljs-built_in">putchar</span>(c);    &#125;error:    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客的搭建-hexo-github</title>
    <link href="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/"/>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/</url>
    
    <content type="html"><![CDATA[<h2 id="1前提介绍："><a href="#1前提介绍：" class="headerlink" title="1前提介绍："></a>1前提介绍：</h2><p>​    我用的是win10，下面会从win10来介绍，不过mac应该也差别不大</p><p>正式搭建之前，我们先要做好提前的准备</p><h2 id="2需要提前安装的软件："><a href="#2需要提前安装的软件：" class="headerlink" title="2需要提前安装的软件："></a>2需要提前安装的软件：</h2><h3 id="1-、node-js"><a href="#1-、node-js" class="headerlink" title="(1)、node.js"></a><strong>(1)、node.js</strong></h3><p>官网 ：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> </p><p>image-20200811072015514</p><p>点击12.18.3 LTS 根据步骤安装即可，记得勾选添加到环境变量</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-10-24.png" alt="Snipaste_2020-08-11_08-10-24"></p><p>安装之后，打开命令行，即win+r 敲入cmd，进入命令行</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-08-40.png"></p><p>输入：<code>node -v</code> 和 <code>npm -v</code></p><p>​    如图所示</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-05-46.png" alt="Snipaste_2020-08-11_08-05-46"></p><h3 id="2-、git"><a href="#2-、git" class="headerlink" title="(2)、git"></a>(2)、<strong>git</strong></h3><p>(也可以用别的命令行工具，但需要带git，我就用的cmder也可以)</p><p>git官网： <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-12-37.png" alt="Snipaste_2020-08-11_08-12-37"></p><p>cmder官网： <a href="https://cmder.net/">https://cmder.net/</a>    (选择Download  Full)</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-13-33.png" alt="Snipaste_2020-08-11_08-13-33"></p><p>安装完毕之后，就可以在开始菜单看到所安装的东西了</p><p><code>tips：git bash/cmder其实就是相当于linux下的终端窗口，之后就用它来代替win10里面的cmd就行啦</code></p><p>下面正式开始！！！</p><h2 id="3安装hexo"><a href="#3安装hexo" class="headerlink" title="3安装hexo"></a>3安装hexo</h2><p>首先在电脑某位置建立blog文件</p><p>类似这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-21-08.png" alt="Snipaste_2020-08-11_08-21-08"></p><p>之后的操作都在blog文件里面，如果哪儿不行，就可以把blog文件删掉，重新来</p><p>然后在文件夹内用git bash 或cmder 右键打开终端</p><p>输入：</p><p>​     <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code> </p><p>即借用npm安装cnpm的淘宝源~安装之后下载会更快一些</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-16-35.png" alt="Snipaste_2020-08-11_10-16-35"></p><p>可以利用  <code>cnpm</code> 和 <code>cnpm -v</code>   查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-35.png" alt="Snipaste_2020-08-11_08-48-35"></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-47.png" alt="Snipaste_2020-08-11_08-48-47"></p><p>则说明成功！</p><p>接着利用cnmp安装hexo</p><p> <code>cnpm install -g hexo-cli</code>      等待…….</p><p>再输入</p><p><code>hexo -v</code></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-51-44.png" alt="Snipaste_2020-08-11_08-51-44"></p><p><strong>则hexo安装成功！！</strong></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-54-17.png" alt="Snipaste_2020-08-11_08-54-17"></p><p>利用 <code>pwd</code>  命令查看一下自己所在的文件位置 ，是否在blog下</p><p>如果是ok，进行初始化 <code>hexo init</code>，接着等待 就行啦</p><p>之后blog文件夹会变成这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-06-14.png" alt="Snipaste_2020-08-11_09-06-14"></p><p>可以在source -&gt; _posts中看到博客的内容，在里面进行创建，是Markdown的形式</p><p>大功告成，进行测试，下面这几个命令我们管理博客经常用到的~</p><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> clean <span class="hljs-comment">#用来清理缓存文件</span>hexo g      <span class="hljs-comment">#生成文件</span>hexo  s     <span class="hljs-comment">#运行本地服务器</span>hexo  d   <span class="hljs-comment">#上传到服务器</span></code></pre><p>终端敲入<code>hexo s</code></p><p>就会看到 4000端口的localhost网址，在浏览器输入，就会看到默认landscape主题的博客</p><p>类似于这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-12-33.png"></p><p><strong>本地环境搭建完毕！！！</strong></p><h2 id="4推送到远端"><a href="#4推送到远端" class="headerlink" title="4推送到远端"></a>4推送到远端</h2><p>下面就要推到远端github上，所以需要一个<a href="https://github.com/">github</a>账号</p><p>然后进行注册就好啦~最好name是小写英文，否则好像会出现bug</p><p>可以在account中change name</p><p>创建好之后，create a new repository</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-26-02.png" alt="Snipaste_2020-08-11_09-26-02"></p><p>Repository name 中输入前面Owner的具体名字，再加github.io</p><p>就如：<code>codeheng.github.io</code> 以后就可以利用这个网址访问</p><p>在blog下打开终端，win10输入<code>npm install --save hexo-deployer-git</code></p><p>安装git部署的插件</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-18-46.png" alt="Snipaste_2020-08-11_10-18-46"></p><p>安装完毕后，进行一些设置，博客的基本配置都在<code>_config.yml</code>中，我是用vscode打开的</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-19-37.png" alt="Snipaste_2020-08-11_10-19-37"></p><p>进行如下的修改</p><p>type中内容改为git，<em>注意<strong>冒号后面有一个空格</strong></em></p><p>添加repo：后面是在github中查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-45-07.png" alt="Snipaste_2020-08-11_09-45-07"></p><p>最终如图所示：</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-12-53.png" alt="Snipaste_2020-08-11_10-12-53"></p><p>接着就可以把本地的部署到远端了，利用<code>hexo d</code>命令，之后输入用户名和密码就成功了！</p><p>如果没有用过git，需要提前输入下面这两行命令，设置名字和邮箱，再进行上述输入</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.name&quot;</span>`git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.email&quot;</span></code></pre><p>到此为止基本结束！只不过主题是默认的~根据自己的喜好更好即可</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-56-14.png" alt="Snipaste_2020-08-11_09-56-14"></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
