<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>过滤器和监听器</title>
    <link href="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <url>/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h1><blockquote><p><code>Model</code> 模型：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</p><p><code>View</code> 视图 ： 界面设计人员进行图形界面设计。</p><p><code>Controller控制器</code>:  负责转发请求，对请求进行处理。</p></blockquote><p><strong>以前的架构</strong></p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/01.png" alt="image-20220204091903472"></p><blockquote><p>servlet ==&gt; CRUD ==&gt; 数据库</p><p>不利于维护</p><p>如何解决：再加一层！</p></blockquote><p><strong>如今的架构(微服务之后又变了)</strong></p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/02.png" alt="image-20220204092139132"></p><p><code>Model</code></p><ul><li>业务处理 : 业务相关的逻辑(Service)</li><li>数据持久层: crud （dao)</li></ul><p><code>View</code></p><ul><li>展示数据</li><li>提供链接发起<code>Servlet</code>请求（a标签，form，img….)</li></ul><p><code>Controller</code> (servlet)</p><ul><li>接收用户请求 (请求参数，session信息)</li><li>交给业务层处理对应的代码</li><li>控制视图的跳转</li></ul><blockquote><p>登陆 ==&gt; 接收用户的登陆请求 ==&gt; 处理用的请求(获取登陆参数:用户名和密码) ==&gt; 交给业务层处理登陆业务(判断是否正确：事务) </p><p>===&gt; Dao层查询用户和密码是否做正确  ==&gt; 数据库</p></blockquote><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><blockquote><p>  <strong>Filter</strong>是一个可重复使用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一资源的响应。</p></blockquote><p><code>Filter</code> 过滤网站的数据</p><ul><li>处理乱码</li><li>登陆验证….</li></ul><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/03.png" alt="image-20220204103114809"></p><p><strong>1.添加<code>maven</code>依赖，导包</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Servlet依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-comment">&lt;!-- jsp依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- JSTL表达式依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- standard标签库依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- JDBC依赖 mysql此时版本8.026--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p><strong>2、重写方法，并配置</strong></p><p>​    <code>Filter01.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.filter;<span class="hljs-keyword">import</span> javax.servlet.*; <span class="hljs-comment">//是servlet中的 Filter</span><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">//过滤 ==&gt; 编码均设为utf-8</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filter01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-comment">//初始化，web服务器一启动就初始化，随时等待过滤</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        System.out.println(<span class="hljs-string">&quot;初始化....&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//设置编码</span>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);        System.out.println(<span class="hljs-string">&quot;执行前!!!&quot;</span>);        filterChain.doFilter(servletRequest,servletResponse);<span class="hljs-comment">//此时才执行，不写则无效，将停止</span>        System.out.println(<span class="hljs-string">&quot;执行后！！！&quot;</span>);    &#125;    <span class="hljs-comment">//销毁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;销毁....&quot;</span>);    &#125;&#125;</code></pre><p><code>ShowServlet.java</code> 提供页面文字，让过滤器过滤成正确文本</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        resp.getWriter().write(<span class="hljs-string">&quot;你好！世界&quot;</span>);<span class="hljs-comment">//中文，若不设置编码，则出现乱码</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>showServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/show<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>showServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/show<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.heng.filter.Filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--        只要/servlet下任何请求，将经过过滤器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/show</code>时，则出现乱码</p><p>当访问<code>http://localhost:8080/servlet/show</code>时，则正确输出，进行了过滤</p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><blockquote><p>​    <strong>Listener</strong>是监听器，通过Listener可以监听Web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的来说就是在Application，Session，Request三个对象创建、消亡或者往其中添加、修改、删除属性时自动执行代码功能的组件。</p></blockquote><p>先导包(和上面同)</p><p>创建<code>Listener01.java</code></p><pre><code class="hljs java"><span class="hljs-comment">//统计网站在线人数</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;    <span class="hljs-comment">//创建session监听,一旦创建session就会触发</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        ServletContext context = se.getSession().getServletContext();        System.out.println(se.getSession().getId());<span class="hljs-comment">//打印session的id</span>        Integer count = (Integer) context.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) &#123;            count = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            count = <span class="hljs-keyword">new</span> Integer( count.intValue() + <span class="hljs-number">1</span>);        &#125;        context.setAttribute(<span class="hljs-string">&quot;count&quot;</span>,count);    &#125;    <span class="hljs-comment">//销毁session监听</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        ServletContext context = se.getSession().getServletContext();        Integer count = (Integer) context.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) &#123;            count = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            count = <span class="hljs-keyword">new</span> Integer( count.intValue() - <span class="hljs-number">1</span>);        &#125;        context.setAttribute(<span class="hljs-string">&quot;count&quot;</span>,count);    &#125;&#125;</code></pre><p><code>index.jsp</code>中添加</p><pre><code class="hljs jsp">&lt;h1&gt; 当前有 &lt;span&gt; &lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;count&quot;)%&gt; 人&lt;/span&gt; &lt;/h1&gt;</code></pre><p>配置<code>web.xml </code>添加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.heng.listener.Listener01<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre><p>运行可能会显示<code>3</code>个,再重新<code>redeploy部署</code>一下，此时将成为1人，当开启多个浏览器打开此页面时，人数将会变多，不同id打印输出</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/04.png" alt="image-20220204121053597"></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p><strong>权限拦截</strong></p><ul><li>用户登陆正确才可以进入主页，进入之后可以注销，注销了就不可以直接再进入了，除非再登陆，输入不对，则返回错误页面</li><li>进入主页要判断是否已经登陆 (过滤器)</li></ul><p><code>login.jsp</code> 登陆页面</p><pre><code class="hljs jsp">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;/servlet/login&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> &gt;    用户:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt; &lt;br&gt;    密码:&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>LoginServlet.java</code></p><p> 对登陆页面进入处理，若输入用户名<code>root</code>和密码<code>123</code>则登陆成功，进行跳转重定向到<code>success.jsp</code>，否则到<code>error.jsp</code>中</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/servlet/login&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);        <span class="hljs-comment">//登陆成功</span>        <span class="hljs-keyword">if</span> (username.equals(<span class="hljs-string">&quot;root&quot;</span>) &amp;&amp; password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;            req.getSession().setAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>,req.getSession().getId());            resp.sendRedirect(<span class="hljs-string">&quot;/sys/success.jsp&quot;</span>);        &#125;        <span class="hljs-comment">//失败</span>        <span class="hljs-keyword">else</span> &#123;            resp.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>success.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登陆成功！&lt;/h1&gt;&lt;p&gt; &lt;a href=&quot;/servlet/logout&quot;&gt;注销&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>error.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;a href=&quot;/login.jsp&quot;&gt;返回登陆页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>LogoutServlet.java</code> 登陆成功后，可进行注销，点击<strong>注销</strong>到此处进行处理</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/servlet/logout&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogoutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        Object user_session = req.getSession().getAttribute(Constant.USER_SESSION);<span class="hljs-comment">//取得信息</span>        <span class="hljs-keyword">if</span> (user_session != <span class="hljs-keyword">null</span>) &#123;            req.getSession().removeAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>);<span class="hljs-comment">//移除session的信息</span>            resp.sendRedirect(<span class="hljs-string">&quot;/login.jsp&quot;</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            resp.sendRedirect(<span class="hljs-string">&quot;/login.jsp&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>由于文件中多次使用<code>&quot;USER_SESSION&quot;</code> 故可以保存到一文件<code>Constant.java</code>中，作为常量，便于取出</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.util;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Constant</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String USER_SESSION = <span class="hljs-string">&quot;USER_SESSION&quot;</span>; <span class="hljs-comment">//用户保存常量</span>&#125;</code></pre><p><code>SysFilter.java</code> 实现过滤，没有登陆的信息，不可以登陆！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.filter;<span class="hljs-keyword">import</span> javax.servlet.*;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletRequest request = (HttpServletRequest) servletRequest; <span class="hljs-comment">//强转为HttpServletRequest</span>        HttpServletResponse response = (HttpServletResponse) servletResponse;        <span class="hljs-keyword">if</span> ( request.getSession().getAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>) == <span class="hljs-keyword">null</span> ) &#123;            response.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);        &#125;        filterChain.doFilter(request,response); <span class="hljs-comment">//必须要有</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><p>配置 <code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>sysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.heng.filter.SysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>sysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/sys/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><p>访问<code>http://localhost:8080/login.jsp</code> 输入正确账号密码</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/05.png" alt="image-20220204172704815"></p><p>点击提交，进行跳转 <img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/06.png" alt="image-20220204172717608"></p><p>注销之后，若直接访问<code>http://localhost:8080/sys/success.jsp</code> 跳转至错误页面，被拦截</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/07.png" alt="image-20220204172824426"></p><p>结构如图：</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/08.png" alt="image-20220204172935107"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>过滤器</tag>
      
      <tag>监听器</tag>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie和session</title>
    <link href="/2022/02/03/cookie%E5%92%8Csession/"/>
    <url>/2022/02/03/cookie%E5%92%8Csession/</url>
    
    <content type="html"><![CDATA[<blockquote><p>会话是指一个终端用户与交互系统进行通讯的过程。</p></blockquote><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><strong>客户端技术</strong></p><blockquote><p> 当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？</p></blockquote><p>HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。</p><p>为了跟踪用户状态，服务器可以<strong>向浏览器分配一个唯一ID</strong>，并以<code>Cookie</code>的形式发送到浏览器，浏览器在后续访问时总是附带此<code>Cookie</code>，这样，服务器就可以识别用户身份。     </p><blockquote><p><code>cookie</code>实际上是一小段的<strong>文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户的状态，就使用<code>response</code>向客户端浏览器颁发一个<code>cookie</code>。客户端浏览器会把<code>cookie</code>保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和<code>cookie</code>一同给服务器。服务器检查该<code>cookie</code>，从而判断用户的状态。服务器还可以根据需要修改<code>cookie</code>的内容。</p></blockquote><p><img src="/2022/02/03/cookie%E5%92%8Csession/03.png" alt="image-20220203185519600"></p><p>例子：保存用户上次访问的时间</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/c1&quot;)</span> <span class="hljs-comment">//利用注解配置访问路径</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cookie01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//设置编码</span>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        PrintWriter out = resp.getWriter();        <span class="hljs-comment">//服务端获取cookie</span>        Cookie[] cookies = req.getCookies();<span class="hljs-comment">//返回数组，可能有多个</span>        <span class="hljs-comment">//判断是否存在</span>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) &#123;            out.write(<span class="hljs-string">&quot;Time : &quot;</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cookies.length; i++) &#123;                <span class="hljs-keyword">if</span> ( cookies[i].getName().equals(<span class="hljs-string">&quot;lastTime&quot;</span>)) &#123;                    <span class="hljs-comment">//获取值</span>                    <span class="hljs-keyword">long</span> l = Long.parseLong(cookies[i].getValue());<span class="hljs-comment">//string ==&gt; long</span>                    Date date = <span class="hljs-keyword">new</span> Date(l); <span class="hljs-comment">//利用时间类操作，转为时间</span>                    out.write(date.toLocaleString());                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            out.write(<span class="hljs-string">&quot;这是第一次访问！&quot;</span>);        &#125;        <span class="hljs-comment">//服务端相应cookie</span>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastTime&quot;</span>,System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-comment">//设置有效期</span>        cookie.setMaxAge(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>); <span class="hljs-comment">//cookie有效期一天！</span>        resp.addCookie(cookie);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><blockquote><p>设置默认Tomcat8080端口访问</p></blockquote><p>当访问第一次访问<code>http://localhost:8080/c1</code>时，并无cookie相应，再次访问此时将有</p><p><img src="/2022/02/03/cookie%E5%92%8Csession/01.png" alt="image-20220203175754579"></p><p><img src="/2022/02/03/cookie%E5%92%8Csession/02.png" alt="image-20220203175850394"></p><h1 id="session-重点"><a href="#session-重点" class="headerlink" title="session(重点)"></a>session(重点)</h1><p><strong>服务端技术</strong></p><p>利用此技术可以保存用户的会话信息，把信息或数据放到<code>session</code>中,把这种基于<strong>唯一ID识别用户身份的机制</strong>称为Session。</p><p>每个用户第一次访问服务器后，会自动获得一个<code>Session ID</code>。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的<code>Session ID</code>访问，服务器也认为这是一个新用户，会分配新的Session ID。</p><blockquote><p><code>session</code>是另一种记录客户状态的机制。不同的是<code>cookie</code>保存在<strong>客户端浏览器</strong>中，而<code>session</code>保存在<strong>服务器</strong>上。</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是<code>session</code>。客户端浏览器再次访问时只需要从该<code>session</code>中查找该客户的状态就可以了。<br>如果说<code>cookie</code>机制是通过检查客户身上的“通信证”，那么<code>session</code>机制就是通过 检查服务器上的“ 客户明细表”来确认客户身份</p></blockquote><p><img src="/2022/02/03/cookie%E5%92%8Csession/04.png" alt="image-20220203185701027"></p><p> <code>Session01.java中 </code> 获得<code>session ID</code></p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/ss1&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>); <span class="hljs-comment">//浏览器上的格式</span>        <span class="hljs-comment">//得到session</span>        HttpSession session = req.getSession();        <span class="hljs-comment">//给session存东西</span>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;一恒&quot;</span>);        <span class="hljs-comment">//获取id</span>        String id = session.getId();        <span class="hljs-keyword">if</span> ( session.isNew() ) &#123;            resp.getWriter().write(<span class="hljs-string">&quot;session创建成功！id = &quot;</span>+ id);        &#125;        <span class="hljs-keyword">else</span> &#123;            resp.getWriter().write(<span class="hljs-string">&quot;session已存在！id = &quot;</span> + id);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>Session02.java</code>中，获取<code>session</code>中信息</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/ss2&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);        <span class="hljs-comment">//获取session01中的值</span>        HttpSession session = req.getSession();        resp.getWriter().write( (String) session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>) ); <span class="hljs-comment">//打印到浏览器窗口</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>Session03.java</code> 删除session信息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);        HttpSession session = req.getSession();        session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//删除session中的值</span>        session.invalidate();<span class="hljs-comment">//注销session，此时再次访问出现新的id</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>也可以在<code>web.xml</code>中配置会话自动过期</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>    <span class="hljs-comment">&lt;!--    可设置失效时间，单位为分钟--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre><p><strong>使用场景</strong></p><ul><li>保存登陆用户的信息</li><li>购物车信息</li><li>网站中经常使用的数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>session</tag>
      
      <tag>cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/01/29/JDBC/"/>
    <url>/2022/01/29/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JDBC简介"><a href="#1-JDBC简介" class="headerlink" title="1.JDBC简介"></a>1.JDBC简介</h1><p>​    <code>Java DataBase Connectivity</code>（Java语言连接数据库）</p><p>JDBC的本质是什么？</p><ul><li><p>JDBC是SUN公司制定的一套接口（<code>interface</code>)</p><p>在包 <code>java.sql.*;</code>中 </p></li></ul><blockquote><p>接口都有调用者和实现者。<br>面向接口调用、面向接口写实现类，这都属于<strong>面向接口编程</strong>。</p><p><strong>为什么要面向接口编程？</strong><br>    解耦合：降低程序的耦合度，提高程序的扩展力。<br>    多态机制就是非常典型的：面向抽象编程。（不要面向具体编程）</p></blockquote><pre><code class="hljs java">建议：    Animal a = <span class="hljs-keyword">new</span> Cat();    Animal a = <span class="hljs-keyword">new</span> Dog();<span class="hljs-comment">// 喂养的方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Animal a)</span></span>&#123; <span class="hljs-comment">// 面向父类型编程。</span>&#125;不建议：    Dog d = <span class="hljs-keyword">new</span> Dog();    Cat c = <span class="hljs-keyword">new</span> Cat();思考：为什么SUN制定一套JDBC接口呢？    因为每一个数据库的底层实现原理都不一样。    Oracle数据库有自己的原理。    MySQL数据库也有自己的原理。    MS SqlServer数据库也有自己的原理。    ....    每一个数据库产品都有自己独特的实现原理。JDBC的本质到底是什么？    一套接口。</code></pre><h1 id="2-JDBC六步"><a href="#2-JDBC六步" class="headerlink" title="2.JDBC六步"></a>2.JDBC六步</h1><p>（背会）</p><blockquote><p>第一步：<strong>注册驱动</strong>（作用：告诉Java程序，即将要连接的是哪个品牌的数据库）</p><p>第二步：<strong>获取连接</strong>（表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完之后一定要关闭通道。）</p><p>第三步：<strong>获取数据库操作对象</strong>（专门执行sql语句的对象）</p><p>第四步：<strong>执行SQL语句</strong>（DQL DML….）</p><p>第五步：<strong>处理查询结果集</strong>（只有当第四步执行的是select语句的时候，才有这第五步处理查询结果集。）</p><p>第六步：<strong>释放资源</strong>（使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭。）</p></blockquote><p><strong>示例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.jdbc;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Statement statement = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.注册驱动</span>            Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver();            DriverManager.registerDriver(driver);            <span class="hljs-comment">//2.获取连接(需要知道url,用户名,密码)</span>            String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;            String username = <span class="hljs-string">&quot;root&quot;</span>;            String pwd = <span class="hljs-string">&quot;123&quot;</span>;            connection = DriverManager.getConnection(url,username,pwd);            System.out.println(<span class="hljs-string">&quot;数据库对象&quot;</span> + connection);<span class="hljs-comment">//打印查看sql对象 </span>            <span class="hljs-comment">//结果：数据库对象com.mysql.cj.jdbc.ConnectionImpl@587c290d</span>            <span class="hljs-comment">//3.获取sql对象</span>            statement = connection.createStatement();            <span class="hljs-comment">//4执行sql语句</span>            String sql = <span class="hljs-string">&quot;insert into class(class_no,class_name) value(&#x27;5&#x27;,&#x27;数学班&#x27;)&quot;</span>;            <span class="hljs-comment">//执行,为(insert,delete,update)提供的方法</span>            <span class="hljs-comment">//返回值是 影响数据库中的记录条数</span>            <span class="hljs-keyword">int</span> count = statement.executeUpdate(sql);            System.out.println( count == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;sql success!&quot;</span> : <span class="hljs-string">&quot;Not！&quot;</span>);               <span class="hljs-comment">//5.处理sql结果集，因为没有查询，</span>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">/*6.关闭连接</span><span class="hljs-comment">                遵循从大到小的依次关闭</span><span class="hljs-comment">                connection开启的statement,所以statement先关闭</span><span class="hljs-comment">                分别try..catch</span><span class="hljs-comment">            * */</span>            <span class="hljs-keyword">if</span> (statement != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    statement.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    connection.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>结果如图</p><p><img src="/2022/01/29/JDBC/01.png" alt="image-20220130154506756"></p><p>(上述方式不常用)</p><p><strong>类加载的方式注册驱动</strong>(常用)</p><blockquote><p>为何常用===&gt; 因为参数是一个字符串，可以写到<code>xxx.properties</code>文件中！</p></blockquote><p>看源码</p><p><img src="/2022/01/29/JDBC/02.png" alt="image-20220130173422726"></p><pre><code class="hljs java"><span class="hljs-comment">//注册驱动的第二种方式 </span><span class="hljs-keyword">package</span> com.heng.jdbc;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2.连接</span>            Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);            System.out.println(conn); <span class="hljs-comment">//成功</span>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>将数据库文件放到<strong>配置文件</strong>中<code>jdbc.properties</code></p><p>如图，必须同一级目录</p><p>而且要求mysql版本和导入的jar包版本类似</p><p>此电脑</p><blockquote><p>Server version: <strong>8.0.26 MySQL</strong> Community Server - GPL</p><p>故若导入mysql5的包则会出现错误！</p></blockquote><p><img src="/2022/01/29/JDBC/03.png" alt="image-20220130190259222"></p><p><code>jdbc.properties</code>文件中</p><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">123</span></code></pre><p><code>JDBCtest03.java</code>文件</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">import</span> java.util.ResourceBundle;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//通过资源绑定器绑定配置文件</span>        ResourceBundle bundle = ResourceBundle.getBundle(<span class="hljs-string">&quot;jdbc&quot;</span>);        String driver = bundle.getString(<span class="hljs-string">&quot;driver&quot;</span>);        String url = bundle.getString(<span class="hljs-string">&quot;url&quot;</span>);        String username = bundle.getString(<span class="hljs-string">&quot;username&quot;</span>);        String password = bundle.getString(<span class="hljs-string">&quot;password&quot;</span>);        Connection conn = <span class="hljs-keyword">null</span>;        Statement state = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Class.forName(driver);<span class="hljs-comment">//1</span>            conn = DriverManager.getConnection(url,username,password);<span class="hljs-comment">//2</span>            state = conn.createStatement();     <span class="hljs-comment">//3</span>            String sql = <span class="hljs-string">&quot;insert into class(class_no,class_name) value(&#x27;6&#x27;,&#x27;外语班&#x27;)&quot;</span>;<span class="hljs-comment">//4</span>            <span class="hljs-keyword">int</span> count = state.executeUpdate(sql);            System.out.println(count == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;sql success!&quot;</span> : <span class="hljs-string">&quot;Not！&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//6</span>            <span class="hljs-keyword">if</span> (state != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    state.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>完成查询</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcExec</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        Statement state = <span class="hljs-keyword">null</span>;        ResultSet rs = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//查询出来的结果集合</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2.获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3.获取sql对象</span>            state = conn.createStatement();            <span class="hljs-comment">//4执行sql语句，此时执行查询语句</span>            String sql = <span class="hljs-string">&quot;select *from class&quot;</span>;            rs = state.executeQuery(sql);            <span class="hljs-comment">//5.处理sql结果集</span>            <span class="hljs-keyword">while</span> ( rs.next() != <span class="hljs-keyword">false</span>) &#123;                <span class="hljs-comment">//next()相当于光标，持续下移，若有数据返回true</span>                <span class="hljs-comment">//jdbc中下标中1开始，此时表示取光标第一行第一列 也可以用 最终查询表的列名(推荐)</span>                <span class="hljs-comment">//String no = rs.getString(1);</span>                String no = rs.getString(<span class="hljs-string">&quot;class_no&quot;</span>);                String name = rs.getString(<span class="hljs-string">&quot;class_name&quot;</span>);<span class="hljs-comment">//第一行第二列</span>                System.out.println(no + <span class="hljs-string">&quot;,&quot;</span> + name);            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;         <span class="hljs-comment">//释放资源，先查询结果集==&gt;再数据库操作对象===&gt;最后连接</span>        <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                        rs.close();                    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                        e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (state != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    state.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p><code>statement = connection.createStatement();</code></p><p>增删改：<code>statement.executeUpdate(sql);</code> 返回<code>int</code></p><p> 查询： <code>statement.executeUpdate(sql);</code> 返回<code>ResultSet</code></p></blockquote><h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h1><blockquote><p><strong>简单模仿登陆</strong></p><p>1让用户输入 账号密码</p><p>2 和sql中的数据，进行比较，若存在相同，则登陆成功，否则失败</p></blockquote><p>创建表</p><p><img src="/2022/01/29/JDBC/04.png" alt="image-20220131095024031"></p><p>编写<code>JdbcLogin.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcLogin</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1提供用户输入,初始化 返回 账号和密码</span>        Map&lt;String,String&gt; rs = init();        System.out.println(rs);        <span class="hljs-comment">//2.jdbc操作判断是否相等</span>        System.out.println(login(rs) == <span class="hljs-keyword">true</span> ? <span class="hljs-string">&quot;登陆成功&quot;</span> : <span class="hljs-string">&quot;失败!&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Map&lt;String, String&gt; rs)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        Statement statement = <span class="hljs-keyword">null</span>;        ResultSet result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> flagSuccess = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//标志是否登陆成功</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2 获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3获得sql对象</span>            statement = conn.createStatement();            <span class="hljs-comment">//4执行sql </span>            String sql = <span class="hljs-string">&quot;select name,password from t_user where name=&#x27;&quot;</span>+rs.get(<span class="hljs-string">&quot;inputName&quot;</span>)+<span class="hljs-string">&quot;&#x27; &quot;</span> +                    <span class="hljs-string">&quot;and password=&#x27;&quot;</span>+rs.get(<span class="hljs-string">&quot;inputPwd&quot;</span>)+<span class="hljs-string">&quot;&#x27;   &quot;</span>;            <span class="hljs-comment">//5 处理结果集</span>            result = statement.executeQuery(sql);            <span class="hljs-keyword">if</span> ( result.next() != <span class="hljs-keyword">false</span> ) &#123;                flagSuccess = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//登陆成功！</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//6 释放资源</span>            <span class="hljs-keyword">if</span> (result !=<span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">try</span> &#123;                            result.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (statement !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    statement.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> flagSuccess;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        Scanner s = <span class="hljs-keyword">new</span> Scanner(System.in);        System.out.print(<span class="hljs-string">&quot;用户名：&quot;</span>);        String inputName = s.nextLine(); <span class="hljs-comment">//获得输入，为字符串</span>        System.out.print(<span class="hljs-string">&quot;密码：&quot;</span>);        String inputPwd = s.nextLine();        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;inputName&quot;</span>,inputName); <span class="hljs-comment">//组装成map(key,value)</span>        map.put(<span class="hljs-string">&quot;inputPwd&quot;</span>,inputPwd);        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre><p>经过测试，当输入数据库存在的数据时，均登陆成功，但存在bug，会导致**SQL注入 ** 如图</p><p><img src="/2022/01/29/JDBC/05.png" alt="image-20220131095833876"></p><p>此时输入<code>qza&#39; or &#39;1&#39;=&#39;1</code>  则会将<code>or</code>参与到sql语句中，导致sql语句查询恒为真   如图<code>debug</code>查看</p><p><img src="/2022/01/29/JDBC/06.png" alt="image-20220131100603852"></p><blockquote><p> 注入原因：输入的信息含sql关键字，并且这些关键字<strong>参与到了sql的编译</strong>，导致原意扭曲</p></blockquote><p>如何解决：</p><p>只要提供的信息，不参与sql语句编译即可！</p><p>利用<code>java.sql.preparedStatement</code> 此接口继承了<code>java.sql.Statement</code></p><p>属于<strong>预编译的数据库操作对象</strong>  (预先对sql语句的框架进行编译，然后再给sql传值)</p><p><strong>改进如下</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Map&lt;String, String&gt; rs)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        PreparedStatement ps = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//采用预编译对象</span>        ResultSet result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> flagSuccess = <span class="hljs-keyword">false</span>;        String name = rs.get(<span class="hljs-string">&quot;inputName&quot;</span>);<span class="hljs-comment">// 获取输入的用户和密码</span>        String pwd = rs.get(<span class="hljs-string">&quot;inputPwd&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2 获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3获得sql对象 ?代表占位符，用来接收一个值</span>            String sql = <span class="hljs-string">&quot;select name,password from t_user where name=? and password=?&quot;</span>;            ps = conn.prepareStatement(sql);            <span class="hljs-comment">//给问号传值，第一个?下标索引1...</span>            ps.setString(<span class="hljs-number">1</span>,name);            ps.setString(<span class="hljs-number">2</span>,pwd);            <span class="hljs-comment">//4执行sql</span>            result = ps.executeQuery();            <span class="hljs-comment">//5 处理结果集</span>            <span class="hljs-keyword">if</span> ( result.next() != <span class="hljs-keyword">false</span> ) &#123;                <span class="hljs-comment">//登陆成功！</span>                flagSuccess = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (result !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    result.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (ps !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    ps.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> flagSuccess;    &#125;</code></pre><p>总结：</p><p><code>Statement</code>存在sql注入问题，并且是编译一次执行一次，因为sql语句根据每次用户输入，都会变化</p><p><code>PreparedStatement</code>解决了sql注入问题，编译一次，可执行N次，效率更好，而且在编译阶段会做安全检查</p><p>故大多数用<code>PreparedStatement</code>，除非业务方面需要sql注入进行拼接，才使用<code>Statement</code>,比如商城按照xx排序即<code>order by desc</code>，则此是需要sql注入</p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>servlet</title>
    <link href="/2022/01/27/servlet/"/>
    <url>/2022/01/27/servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Servlet简介"><a href="#1-Servlet简介" class="headerlink" title="1.Servlet简介"></a>1.Servlet简介</h1><p><strong>Ser</strong>ver App<strong>let</strong></p><p>是用Java编写的<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>端程序。其主要功能在于交互式地浏览和修改数据，<strong>生成动态内容</strong>。</p><p>狭义的Servlet是指Java语言实现的一个<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3">接口</a></p><p>广义的Servlet是指任何实现了这个Servlet接口的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>，一般情况下，人们将Servlet理解为后者。</p><p>Servlet运行于支持Java的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">应用服务器</a>中。</p><p>从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE">协议</a>的<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">Web服务器</a>。</p><p>故这些api中提供的一个接口叫做：<code>servlet</code>。若要开发<code>servlet</code>程序</p><ul><li>1.编写一个类，实现<code>servlet</code>接口</li><li>2.把开发好的java类部署到web服务器中</li></ul><blockquote><p>ps: <strong>Servlet接口</strong>SUN公司定义了两个<strong>默认实现类</strong>，分别为：<strong>GenericServlet、HttpServlet</strong></p></blockquote><h1 id="2-Servlet项目"><a href="#2-Servlet项目" class="headerlink" title="2.Servlet项目"></a>2.Servlet项目</h1><p>(1). 建立<strong>普通的maven项目</strong>，删除里面的src目录，之后再建立项目，就在此项目中建立<code>Model</code>即可，即<strong>主工程</strong></p><p><img src="/2022/01/27/servlet/01.png" alt="image-20220128173531354"></p><p>添加<code>servlet-api</code> 和 <code>jsp-api</code>依赖 ==&gt; <code>setting.xml</code>如图</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span> </code></pre><p>(2).里面可进行<strong>新建web-maven项目</strong>，如图</p><p><img src="/2022/01/27/servlet/02.png" alt="image-20220128173705675"></p><p>创建完成后，<code>setting.xml</code>如图</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">connectors</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">connector</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8888<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">maxIdleTime</span>&gt;</span>30000<span class="hljs-tag">&lt;/<span class="hljs-name">maxIdleTime</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">connector</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">connectors</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">webAppSourceDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;pom.artifactId&#125;-$&#123;pom.version&#125;                    <span class="hljs-tag">&lt;/<span class="hljs-name">webAppSourceDirectory</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">contextPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">contextPath</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--dependency&gt;</span><span class="hljs-comment">      &lt;groupId&gt;com.heng&lt;/groupId&gt;</span><span class="hljs-comment">      &lt;artifactId&gt;[the artifact id of the block to be mounted]&lt;/artifactId&gt;</span><span class="hljs-comment">      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><span class="hljs-comment">    &lt;/dependency--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><img src="/2022/01/27/servlet/03.png" alt="image-20220128174332786"></p><p><strong>两者为父子工程</strong></p><p>父项目中会有</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></code></pre><p> 子项目中有</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>父项目中的jar包 子项目可以直接使用，反之不可以</p><p><strong>(3).maven环境进行优化</strong></p><ul><li>修改web.xml</li><li>将maven结构弄完成 ==&gt;  main下添加<code>java</code> 和 <code>resources文件夹</code></li></ul><p><strong>目录结构</strong></p><p><img src="/2022/01/27/servlet/04.png" alt="image-20220128192003127"></p><p><strong>(4).编写servlet</strong></p><ul><li>创建普通类</li><li>实现<code>servlet</code>接口，可以继承<code>HttpServlet</code></li></ul><p>观察源码</p><p><img src="/2022/01/27/servlet/05.png" alt="image-20220128182305203"></p><p><img src="/2022/01/27/servlet/06.png" alt="image-20220128182336364"></p><p><img src="/2022/01/27/servlet/07.png" alt="image-20220128182420504"></p><p><strong>(5).重写<code>doGet</code>和<code>doPost</code>方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-comment">//进行重写</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        PrintWriter writer = resp.getWriter();        writer.print(<span class="hljs-string">&quot;hello servlet!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><strong>(6).写servlet映射</strong></p><blockquote><p>因为写的是java，但想在浏览器上进行访问，需要连接web服务器</p><p>故需要在web服务中注册<code>servlet</code>,并且给出访问的路径</p></blockquote><p>在<code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--进行映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p><strong>(7)配置Tomcat</strong></p><p><img src="/2022/01/27/servlet/08.png" alt="image-20220128184145818"></p><p><strong>(8)启动</strong></p><p>查看结果</p><p><img src="/2022/01/27/servlet/09.png" alt="image-20220128192055844"></p><p><img src="/2022/01/27/servlet/10.png" alt="image-20220128192111911"></p><h1 id="3-servlet原理-本质"><a href="#3-servlet原理-本质" class="headerlink" title="3.servlet原理/本质"></a>3.servlet原理/本质</h1><blockquote><p>浏览器发送一个HTTP请求，HTTP请求由<strong>Web容器</strong>(比如tomcat)分配给特定的Servlet进行处理<br><strong>Servlet的本质是一个Java对象</strong>，这个对象拥有一系列的方法来处理HTTP请求。常见的方法有**doGet()，doPost()**等。</p><p>Web容器中包含了多个Servlet，特定的HTTP请求该由哪一个Servlet来处理是由Web容器中的<code>web.xml</code>来决定的。</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-1cb5b57ffab54838ad59983a8adbcdc8_720w.jpg?source=1940ef5c" alt="img"></p><p>Servlet工作流程分为三个阶段。init(初始化)，service(运行)，destroy(销毁)</p><p>Servlet没有<a href="https://www.zhihu.com/search?q=main%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:82511153%7D">main方法</a>，所有行为由Container控制。Container就是一个java程序。</p><p>在加载Servlet的.class后，Servlet会由<a href="https://www.zhihu.com/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:82511153%7D">构造函数</a>生成一个实例，然后Container调用<code>init()</code>方法完成参数的初始化，接着调用<code>service()</code>方法，service会根据网页的请求，调用doGet或者doPost方法(<strong>一般需要重写</strong>)，最后调用销毁方法。如图：</p><p><img src="https://pic1.zhimg.com/80/3fdb2abf692cb5edb833e139504ede39_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="1-mapping问题"><a href="#1-mapping问题" class="headerlink" title="1.mapping问题"></a>1.mapping问题</h2><ul><li>一个servlet可以指定一个映射路径</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.一对一映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><ul><li>一个servlet可以指定多个映射路径</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--2 一对多映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当输入<code>http://localhost:8080/s1/hello</code>或 <code>http://localhost:8080/s1/hello1</code>或<code>http://localhost:8080/s1/hello2</code></p><p>均可以访问</p><ul><li>一个servlet可以指定通用映射路径    </li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--3 通用映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>/hello/xxxx</code> xxxx即*  ==&gt; 代指任何均可以访问</p><p>若改为<code>&lt;url-pattern&gt;*&lt;/url-pattern&gt;</code>则报错<br>若改为<code> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code> 则默认启动即相应的页面，<code>index.jsp</code>内容无法看到</p><ul><li><p>可以指定前缀或后缀</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>只要访问是以<code>.heng</code>为后缀则访问成功</p></li></ul><h2 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2.优先级"></a>2.优先级</h2><ul><li><p>指定了固有的路径优先级最高，如果找不到找默认的</p><p>示例：编写<code>ErrorServlet</code>  目的==&gt; 访问错误到自己的页面，显示404</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);        PrintWriter writer = resp.getWriter();        writer.print(<span class="hljs-string">&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;</span>); <span class="hljs-comment">//页面显示404</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>配置<code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.ErrorServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--进行映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>默认访问404,只有当指定<code>/heng</code>时才访问写的<code>HelloServlet.java</code>，然后展示内容</p><h1 id="4-ServletContext"><a href="#4-ServletContext" class="headerlink" title="4.ServletContext"></a>4.ServletContext</h1><p>web容器启动时，为每个web程序都创建了对应的<code>ServletContext</code>对象，代表当前的web应用</p><h2 id="4-1可共享数据"><a href="#4-1可共享数据" class="headerlink" title="4.1可共享数据"></a>4.1可共享数据</h2><p>( 在这个servlet保存的数据，可在另一个servlet中拿到)</p><p><code>HelloServlet02.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();<span class="hljs-comment">//servlet上下文</span>        String myName = <span class="hljs-string">&quot;Yiheng&quot;</span>;        <span class="hljs-comment">//将myName保存到ServletContext中</span>        context.setAttribute(<span class="hljs-string">&quot;Name&quot;</span>,myName);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>GetServlet.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//拿到HelloServlet02中保存的名字</span>        String usrName = (String) context.getAttribute(<span class="hljs-string">&quot;Name&quot;</span>);        resp.getWriter().print(<span class="hljs-string">&quot;Name &quot;</span> + usrName); <span class="hljs-comment">//在浏览器中打印显示</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.HelloServlet02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getName<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello02<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getName<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/Name<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>先访问<code>/s2/hello02</code>获取数据，然后通过<code>http://localhost:8080/s2/Name</code> 拿到数据，则此是进行显示</p><p><img src="/2022/01/27/servlet/11.png" alt="image-20220129103546867"></p><blockquote><p>会用cookie 和 session 替代</p></blockquote><h2 id="4-2可获取初始化参数"><a href="#4-2可获取初始化参数" class="headerlink" title="4.2可获取初始化参数"></a>4.2可获取初始化参数</h2><p><code>web.xml</code>中 新加入参数</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre><p>创建<code>GetParam.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//通过ServletContext获得初始化的参数</span>        String url = context.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>);        resp.getWriter().print(url);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中加入对应配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetParam<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/gp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/gp</code> 则数据已获取，即<code>jdbc:mysql://localhost:3306/mybatis</code>显示出来</p><h2 id="3-可进行转发"><a href="#3-可进行转发" class="headerlink" title="3.可进行转发"></a>3.可进行转发</h2><p>新建<code>Forward_demo.java</code> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Forward_demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//设置转发的请求路径</span>        RequestDispatcher requestDispatcher = context.getRequestDispatcher(<span class="hljs-string">&quot;/gp&quot;</span>);        <span class="hljs-comment">//forward方法进行转发</span>        requestDispatcher.forward(req,resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code> 加入配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.Forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/fd<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/fd</code>时，此是会将<code>/gp</code>映射的内容转发过来，最终显示出来了<code>jdbc:mysql://localhost:3306/mybatis</code></p><h2 id="4-读取资源文件"><a href="#4-读取资源文件" class="headerlink" title="4.读取资源文件"></a>4.读取资源文件</h2><p><img src="/2022/01/27/servlet/12.png" alt="image-20220129143356510"></p><p><code>db.properties</code>内容</p><pre><code class="hljs properties"><span class="hljs-attr">username</span> = <span class="hljs-string">root</span><span class="hljs-attr">password</span> = <span class="hljs-string">123</span></code></pre><p><code>xx.properties</code>内容</p><pre><code class="hljs properties"><span class="hljs-attr">username</span> = <span class="hljs-string">myRoot</span><span class="hljs-attr">password</span> = <span class="hljs-string">123123</span></code></pre><blockquote><p>ps： <code>db.properties</code>默认可以正常在<code>target/classess中</code>到处，而<code>xx.properties</code>则不可以，因为在java内部</p></blockquote><p>需要进行处理，在<code>pom.xml</code>中加入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-comment">&lt;!--主要就是下面这个--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>加入之后，运行，观察可发现</p><p><img src="/2022/01/27/servlet/13.png" alt="image-20220129144057553"></p><p>两个均正常生成</p><p>在<code>GetResources.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetResources</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//找到xx.properties资源目录，输入为流</span>        InputStream stream = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/com/heng/xx.properties&quot;</span>);        <span class="hljs-comment">//找db.properties</span>        <span class="hljs-comment">//InputStream stream = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);</span>        Properties prop = <span class="hljs-keyword">new</span> Properties();        prop.load(stream); <span class="hljs-comment">//加载</span>        String name = prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>);        String pwd = prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>);        resp.getWriter().println(<span class="hljs-string">&quot;name : &quot;</span> + name);        resp.getWriter().println(<span class="hljs-string">&quot;password : &quot;</span> + pwd);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>resources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetResources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>resources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/res<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/res</code>则可看到对应资源被展示出来</p><p><img src="/2022/01/27/servlet/14.png" alt="image-20220129144517696"></p><h1 id="5-Response重定向"><a href="#5-Response重定向" class="headerlink" title="5.Response重定向"></a>5.Response重定向</h1><p>新建<code>RedirectServlet.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedirectServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//重定向</span>        resp.sendRedirect(<span class="hljs-string">&quot;/s2/Name&quot;</span>);     &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>配置<code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>redirect<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.RedirectServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>redirect<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/rs<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当输入<code>http://localhost:8080/s2/rs</code> 直接就跳转至<code>http://localhost:8080/s2/Name</code>进行访问</p><p><img src="/2022/01/27/servlet/15.png" alt="image-20220129150919064"></p><blockquote><p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是<strong>转发给另一个Servlet处理</strong>。</p><p><strong>重定向</strong>是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用<strong>新的URL再重新发送</strong>新请求。</p><p>相同点：页面均会跳转 </p><p>不同：请求转发时，url不会发生变化(307)，而重定向(302)会  </p></blockquote><p><strong>小案例 ==&gt;</strong> </p><p>通过<code>index.jsp</code>上form表单输入账号，密码，进行提交，跳转到另一个页面，显示成功</p><p><strong>需要在表单上指定action具体路径</strong> <code>$&#123;pageContext.request.contextPath&#125;</code>指代当前项目</p><p><code>index.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--此时action找到当前项目，然后在当前项目找到login，进行请求--%&gt;&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;    用户名: &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name = <span class="hljs-string">&quot;username&quot;</span>&gt; &lt;br&gt;    密码 : &lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;pwd&quot;</span>&gt; &lt;br&gt;    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>新建<code>RequestServlet.java</code> 进行处理，当点击提交之后<strong>重定向</strong>到相对页面<code>success.jsp</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>); <span class="hljs-comment">//获取账号密码</span>        String pwd = req.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);        System.out.println(<span class="hljs-string">&quot;账号:&quot;</span> + username); <span class="hljs-comment">//控制台打印对应账号密码</span>        System.out.println(<span class="hljs-string">&quot;密码:&quot;</span> + pwd);        resp.sendRedirect(<span class="hljs-string">&quot;/s2/success.jsp&quot;</span>); <span class="hljs-comment">//重定向到对应页面，显示成功</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>新建<code>success.jsp</code> 和<code>index.jsp</code>同级</p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success!!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>配置<code>web.xml</code> 添加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>request<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.RequestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>request<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/login<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>如图</p><p><img src="/2022/01/27/servlet/16.png" alt="image-20220129154351011"></p><p>点击提交</p><p><img src="/2022/01/27/servlet/17.png" alt="image-20220129154855656"></p><p>控制台<img src="/2022/01/27/servlet/18.png" alt="image-20220129154905692"></p><p>若显示中文乱码，则在Tomcat配置中加入<code>-Dfile.encoding=UTF-8</code>  如图</p><p><img src="/2022/01/27/servlet/19.png" alt="image-20220129154937940"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/study/"/>
    <url>/2022/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/study/</url>
    
    <content type="html"><![CDATA[<p>在<strong>学习该项技术的细节之前</strong>都得知道：</p><p><strong>这项技术是什么，为什么我要学习这项技术，学习了这项技术有什么好处</strong>。</p><p>===&gt; <strong>如果你不知道学习某项技术是干嘛用的，那先不要学</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2022/01/24/http/"/>
    <url>/2022/01/24/http/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是http"><a href="#1-什么是http" class="headerlink" title="1. 什么是http"></a>1. 什么是http</h1><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。</p><ul><li>文本：html，字符串</li><li>超文本：图片，音乐，视频，定位，地图</li><li>端口：80</li></ul><h1 id="2-两个时代"><a href="#2-两个时代" class="headerlink" title="2.两个时代"></a>2.两个时代</h1><ul><li>http1.0<ul><li>http/1.0 : 客户端对web服务器连接后，只能获得一个web资源，断开连接</li></ul></li><li>http2.0<ul><li>http/1.1：客户端对web服务器连接后，可以获得多个web资源，</li></ul></li></ul><h1 id="3-http请求"><a href="#3-http请求" class="headerlink" title="3 .http请求"></a>3 .http请求</h1><ul><li>客服端–&gt;发请求(request) –&gt; 服务器</li></ul><p>百度：</p><blockquote><p>Request URL: <a href="https://www.baidu.com/">https://www.baidu.com/</a><br>Request method: GET<br>Status code: 200 OK<br>Remote address: 127.0.0.1:7890</p><p>Accept: text/html<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9<br>Cache-Control: max-age=0<br>Connection: keep-alive</p></blockquote><h2 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<strong>请求行</strong></h2><ul><li>请求方式：get / post<ul><li>get:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li><li>post：请求能够携带的参数和大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效</li></ul></li></ul><h2 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2.消息头"></a>2.消息头</h2><pre><code class="hljs shell">Accept: 告诉浏览器，支持的数据类型Accept-Encoding: 支持哪种编码格式 gbk utf-8 GB2312 ISO8859-1Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接host: 主机</code></pre><h1 id="4-http响应"><a href="#4-http响应" class="headerlink" title="4. http响应"></a>4. http响应</h1><pre><code class="hljs java">Cache-Control: <span class="hljs-keyword">private</span>Connection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-<span class="hljs-number">8</span> </code></pre><h2 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1.响应体"></a>1.<strong>响应体</strong></h2><pre><code class="hljs groovy"><span class="hljs-attr">Accept:</span> 告诉浏览器，支持的数据类型Accept-<span class="hljs-attr">Encoding:</span> 支持哪种编码格式 gbk utf<span class="hljs-number">-8</span> GB2312 ISO8859<span class="hljs-number">-1</span>Accept-<span class="hljs-attr">Language:</span> 告诉浏览器，他的语言环境Cache-<span class="hljs-attr">Control:</span> 缓存控制<span class="hljs-attr">Connection:</span> 告诉浏览器，请求完是断开还是保持连接<span class="hljs-attr">host:</span> 主机<span class="hljs-attr">refresh :</span> 告诉客户端，多久刷新一次location ： 让网页重新定位 </code></pre><h2 id="2-响应状态码"><a href="#2-响应状态码" class="headerlink" title="2.响应状态码"></a>2.响应状态码</h2><ul><li>200 ：请求相应成功</li><li>3xx : 请求重定向 （你重新到我给你的新位置去</li><li>4xx：找不到资源 404 </li><li>5xx: 服务器代码错误  502 网关错误</li></ul><blockquote><p>面试题：当浏览器输入网址并回车一瞬间到页面显示出来，经历了什么？！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven</title>
    <link href="/2022/01/24/maven/"/>
    <url>/2022/01/24/maven/</url>
    
    <content type="html"><![CDATA[<p>为何要学习Maven</p><blockquote><p>1.在javaweb开发中，需要使用大量的jar包，我们手动去导入</p><p>2.如何才能让一个东西自动帮我导入和配置这些jar包</p><p>于是  maven就诞生了！</p></blockquote><h1 id="1-maven项目管理工具"><a href="#1-maven项目管理工具" class="headerlink" title="1.maven项目管理工具"></a>1.maven项目管理工具</h1><p>方便导入jar包</p><p><strong>核心思想: 约定大于配置</strong></p><ul><li>有约束，不要去违反</li></ul><p>他会规定你如何去编写java代码，必须安装这个规范</p><h1 id="2-下载maven"><a href="#2-下载maven" class="headerlink" title="2. 下载maven"></a>2. 下载maven</h1><p><a href="https://maven.apache.org/">maven官网 </a>下载完解压即可</p><p><img src="/2022/01/24/maven/10.png" alt="image-20220101144018665"></p><h1 id="3-配置maven"><a href="#3-配置maven" class="headerlink" title="3.配置maven"></a>3.配置maven</h1><p>环境变量</p><p><img src="/2022/01/24/maven/10_1.png" alt="image-20220128153722723"></p><ul><li>M2_HOME : maven目录下的bin目录</li><li>MAVEN_HOME ：maven 的目录</li><li>在系统的path中配置%MAVEN_HOME%\bin </li></ul><blockquote><p>命令行输入 <code>mvn -v</code> 进行验证环境变量</p></blockquote><h1 id="4-阿里云镜像"><a href="#4-阿里云镜像" class="headerlink" title="4 .阿里云镜像"></a>4 .阿里云镜像</h1><p>在<code>E:\environment\apache-maven-3.6.2\conf ==&gt;  setting.xml</code>中添加 <strong>镜像和本地仓库</strong></p><p>mirrors(镜像)</p><ul><li>加速我们的下载</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置中央仓库的镜像（改用：阿里云中央仓库镜像）--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun-maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><h1 id="5-本地仓库"><a href="#5-本地仓库" class="headerlink" title="5.本地仓库"></a>5.本地仓库</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:\environment\apache-maven-3.8.4\maven_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h1 id="6-在idea中使用IDEA"><a href="#6-在idea中使用IDEA" class="headerlink" title="6.在idea中使用IDEA"></a>6.在idea中使用IDEA</h1><p>创建maven web项目 如图</p><p><img src="/2022/01/24/maven/11.png" alt="image-20220101192126444"></p><p><img src="/2022/01/24/maven/12.png" alt="image-20220101192357597"></p><p><img src="/2022/01/24/maven/13.png" alt="image-20220101192825075"></p><p>成功后  若报错==&gt; 上述直接弄成idea的默认，然后新创建maven项目</p><p>进行疯狂下东西</p><p><img src="/2022/01/24/maven/14.png" alt="image-20220101194550504"></p><p>出现 BUILD SUCESS 代表成功</p><p><img src="/2022/01/24/maven/15.png" alt="image-20220101201841681"></p><p>在文件中多了文件</p><p><img src="/2022/01/24/maven/16.png" alt="image-20220101195042365"></p><p>也没配置本地仓库，比如在d盘。而这个.m2文件是系统默认的，自动生成的</p><p>在maven web程序下</p><p><img src="/2022/01/24/maven/17.png" alt="image-20220102085500377"></p><h1 id="7-创建普通的maven项目"><a href="#7-创建普通的maven项目" class="headerlink" title="7. 创建普通的maven项目"></a>7. 创建普通的maven项目</h1><p>不勾选模板<img src="/2022/01/24/maven/18.png" alt="image-20220102084704298"></p><p> 干净的maven项目 <img src="/2022/01/24/maven/19.png" alt="image-20220102085250133"></p><h1 id="8-标记文件夹功能"><a href="#8-标记文件夹功能" class="headerlink" title="8.标记文件夹功能"></a>8.标记文件夹功能</h1><p>在idea中对文件夹右键 </p><p><img src="/2022/01/24/maven/20.png" alt="image-20220102085749308"></p><h1 id="9-配置tomcat"><a href="#9-配置tomcat" class="headerlink" title="9.配置tomcat"></a>9.配置tomcat</h1><p><img src="/2022/01/24/maven/21.png" alt="image-20220102090742277"></p><p><img src="/2022/01/24/maven/22.png" alt="image-20220102090805674"></p><p><img src="/2022/01/24/maven/23.png" alt="image-20220102091333094"></p><p><img src="/2022/01/24/maven/24.png" alt="image-20220102091453659"></p><p><img src="/2022/01/24/maven/25.png" alt="image-20220128152412421"></p><p>进行启动</p><p><img src="/2022/01/24/maven/26.png" alt="image-20220102092343654"></p><p>成功会进行弹出！</p><p><img src="/2022/01/24/maven/27.png" alt="image-20220102092357538"></p><p>显示出的<code>hello world</code> 就是<code>index.jsp</code>中的内容</p><p><img src="/2022/01/24/maven/28.png" alt="image-20220102092513473"></p><p>此时成功！</p><p><strong>maven结构</strong></p><p><img src="/2022/01/24/maven/29.png" alt="image-20220102092717582"></p><h1 id="10-pom-xml文件"><a href="#10-pom-xml文件" class="headerlink" title="10. pom.xml文件"></a>10. pom.xml文件</h1> <pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-comment">&lt;!--maven版本和头文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-comment">&lt;!--  下面这是我们配置的GAV--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--  package 项目的打包方式</span><span class="hljs-comment">jar：java应用</span><span class="hljs-comment">war：javaweb应用</span><span class="hljs-comment">--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-comment">&lt;!--name url 可删除--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>untitled Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!--配置--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--    项目的默认构建编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-comment">&lt;!--    编码版本--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--项目依赖--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--    具体依赖的jar包配置文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5-20081211<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--  项目构建用的--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><strong>maven高级之处就在于他帮你导入这个jar包所依赖的其他jar包</strong></p><p><a href="https://mvnrepository.com/">maven仓库</a></p><p>只需加上dependency。在maven仓库中，选择自己需要的即可，maven将自己导入</p><p><img src="/2022/01/24/maven/30.png" alt="image-20220102095217578"></p><p>由于maven 约定大于配置 的规定，所以再之后写的配置文件，<strong>会出现无法导出或生效的问题</strong>，解决方法：</p><p>在mybatis 会遇到</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><p>若每次都需要重新配置，修改<strong>全局配置</strong></p><p><img src="/2022/01/24/maven/31.png" alt="image-20220128151726838"></p><p><img src="/2022/01/24/maven/32.png" alt="image-20220128151823590"></p><p>若maven配置完之后，创建项目出现<code>Error reading file E:/idea_project/Maven_pro/pom.xml</code></p><p>重新安装maven，然后配置环境，则可进行解决</p><h1 id="11-简单编写HelloServlet"><a href="#11-简单编写HelloServlet" class="headerlink" title="11.简单编写HelloServlet"></a>11.简单编写HelloServlet</h1><p>maven app结构</p><p><img src="/2022/01/24/maven/32_1.png" alt="image-20220128152809852"></p><p><code>HelloServlet.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-comment">//重写doGet 和 doPost方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);        response.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);  <span class="hljs-comment">//解决中文乱码！</span>        PrintWriter out = response.getWriter();        out.println(<span class="hljs-string">&quot;&lt;html&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;head&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;title&gt;你好&lt;/title&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/head&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;body&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>index.jsp</code>中</p><pre><code class="hljs jsp">&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>header.html</code>中</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><code>web.xml</code>中</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">web-app</span> <span class="hljs-meta-keyword">PUBLIC</span></span><span class="hljs-meta"> <span class="hljs-meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><span class="hljs-meta"> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>  <span class="hljs-comment">&lt;!--  web.xml是web的核心应用</span><span class="hljs-comment">注册servlet--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>  <span class="hljs-comment">&lt;!--  一个servlet对应一个mapping 映射--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--    映射请求路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><p><strong>结果展示</strong></p><p>默认通过<code>localhost:8080/hello</code> 展示如图，<code>index.jsp</code>文件展示出来</p><p><img src="/2022/01/24/maven/33.png" alt="image-20220128153227229"></p><p>访问<code>header.html</code></p><p><img src="/2022/01/24/maven/34.png" alt="image-20220128153244534"></p><p>通过<code>servlet</code>进行映射访问，编写的<code>HelloServlet</code>展示出来</p><p><img src="/2022/01/24/maven/35.png" alt="image-20220128153300993"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2022/01/21/JavaScript/"/>
    <url>/2022/01/21/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>(行为层)</p><h2 id="1-1什么是JavaScript？"><a href="#1-1什么是JavaScript？" class="headerlink" title="1.1什么是JavaScript？"></a>1.1什么是JavaScript？</h2><p><img src="/2022/01/21/JavaScript/01.png" alt="image-20220121194910154"></p><p><em>合格的后端开发人员必须<strong>精通</strong> JavaScript！</em></p><p><strong>JavaScript框架</strong></p><p><img src="/2022/01/21/JavaScript/02.png" alt="image-20220121194953823"></p><p><strong>主流框架：VUE.js</strong></p><p><img src="/2022/01/21/JavaScript/03.png" alt="image-20220121195301812"></p><h2 id="1-2-js历史"><a href="#1-2-js历史" class="headerlink" title="1.2 js历史"></a>1.2 js历史</h2><p><strong><a href="https://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">JavaScript历史</a></strong></p><h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h1><p><strong>引入js</strong></p><pre><code class="hljs javascript"><span class="hljs-comment">//内部引用 script必须成对出现</span>&lt;script&gt;        alert(<span class="hljs-string">&quot;Hello World!&quot;</span>); <span class="hljs-comment">//弹出HelloWord </span>&lt;/script&gt;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//在index.html同级目录中建立js文件夹，然后里面进行js文件，写入js语句</span><span class="hljs-comment">//外部引用(规范写法) 在index.html中  </span> &lt;script src=<span class="hljs-string">&quot;js/new.js&quot;</span>&gt;&lt;/script&gt; <span class="hljs-comment">//new.js中</span>alert(<span class="hljs-string">&quot;Hello World!&quot;</span>);</code></pre><h2 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a><strong>2.1变量</strong></h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> number = <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;</code></pre><p><img src="/2022/01/21/JavaScript/04.png" alt="image-20220122083505160"></p><p>可在浏览器此处进行输入js代码，观察</p><h2 id="2-2数据类型"><a href="#2-2数据类型" class="headerlink" title="2.2数据类型"></a>2.2<strong>数据类型</strong></h2><p><strong>number</strong></p><pre><code class="hljs js"><span class="hljs-number">123</span> <span class="hljs-comment">//整数123</span><span class="hljs-number">123.1</span> <span class="hljs-comment">//浮点数123.1</span><span class="hljs-number">1.123e3</span> <span class="hljs-comment">//科学计数法</span><span class="hljs-number">-99</span> <span class="hljs-comment">//复数</span><span class="hljs-literal">NaN</span> <span class="hljs-comment">// not a number</span><span class="hljs-literal">Infinity</span> <span class="hljs-comment">//表示无穷大</span></code></pre><p><strong>字符串</strong></p><p>单引号or双引号  注意转义字符</p><pre><code class="hljs js"><span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a\&#x27;&quot;</span>)  <span class="hljs-comment">//打印 a&#x27;</span><span class="hljs-comment">//多行字符串 tab上方键引起来</span><span class="hljs-keyword">var</span> msg = <span class="hljs-string">`</span><span class="hljs-string">hello</span><span class="hljs-string">world</span><span class="hljs-string">你好！</span><span class="hljs-string">`</span><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;heng&quot;</span>;<span class="hljs-keyword">let</span> print = <span class="hljs-string">`你好， <span class="hljs-subst">$&#123;name&#125;</span>`</span>  <span class="hljs-comment">//可以这样引用</span><span class="hljs-comment">//字符串长度,并且可以通过下标进去取字符(java不可以)，但字符串不可变</span>str.length<span class="hljs-comment">//大小写转换</span>student.toUpperCase()student.toLowerCase()</code></pre><p><strong>布尔值</strong></p><p><code>true</code> <code>false</code></p><p><strong>逻辑运算</strong></p><p><code>&amp;&amp; || !</code>  与或非</p><p><strong>比较运算符</strong></p><pre><code class="hljs js">=  <span class="hljs-comment">//赋值</span>==    <span class="hljs-comment">// 等于(类型不一样，值一样，为true)</span>    <span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment">//是true</span>===  <span class="hljs-comment">// 绝对等于(类型一样并且值也要一样)</span></code></pre><blockquote><p>ps: NaN == NaN 为false，即NaN与所有的数值均不等，包括自己</p><p>只能通过isNaN(NaN) 来判断是否为NaN</p></blockquote><p>浮点数问题  (会有精度) </p><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>-(<span class="hljs-number">1</span><span class="hljs-number">-2</span>/<span class="hljs-number">3</span>)) &lt; <span class="hljs-number">0.0000000001</span> <span class="hljs-comment">//此时认为相等</span></code></pre><p><strong>null 和 undefined</strong></p><ul><li>null 表示空     undefined表示未定义</li></ul><p><strong>数组</strong>(关键如何<strong>存和取</strong>)</p><p>js中数组里面不需要相同的类型,可以包含任意类型</p><pre><code class="hljs js"><span class="hljs-comment">//1 推荐使用</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>];<span class="hljs-comment">//2 </span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>);</code></pre><p>若下标越界，则会出现 <code>undefined</code></p><pre><code class="hljs js"><span class="hljs-comment">//可以给arr.length 赋值，此时数组长度会变化</span>arr.indexOf(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2在数组中出现的下标索引</span>slice()  ==&gt; 截取数组的一部分，并返回新数组 类似于字符串中的substringarr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>]arr.slice(<span class="hljs-number">3</span>) <span class="hljs-comment">//[4,5,6,&quot;1&quot;,&quot;2&quot;]</span>arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[2,3,4,5]arr.push(&quot;a&quot;,&quot;b&quot;) </span><span class="hljs-comment">//对数组arr进行添加元素</span>arr.push() <span class="hljs-comment">//&quot;b&quot;被弹出 ，push，pop均 是尾部  若要头部===&gt; unshift(),shift()arr.sort()</span><span class="hljs-comment">//数组排序</span>arr.reverse() <span class="hljs-comment">//数组反转</span>arr.concat([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment">//在arr后面连接上数组[1,2,3],并没有改变数组，只是返回一个新数组</span>arr.join(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">//将数组元素用-连接起来</span></code></pre><p><strong>对象</strong></p><p>大括号括起来，每个属性之间逗号隔开，最后一个不需要加</p><p><strong>js中的所有键均是字符串，值是任意对象</strong></p><p>格式：</p><p><code>var 对象名 = &#123;         属性名: 属性值,         属性名: 属性值,         属性名: 属性值 &#125;</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> person =  &#123;       name: <span class="hljs-string">&quot;heng&quot;</span>,        age : <span class="hljs-number">20</span>,        flag:[<span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;js&#x27;</span>]&#125;可以通过<span class="hljs-keyword">delete</span>删除对象属性也可以直接动态添加属性，直接给属性赋值即可person.id = <span class="hljs-string">&quot;123&quot;</span>;<span class="hljs-comment">//xxx in xxx 可以判断属性值是否在对象中,同时继承父类</span><span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> person <span class="hljs-comment">//true</span><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> person <span class="hljs-comment">//true </span></code></pre><p><strong>Map和Set</strong></p><p>es6新特性</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">100</span>],[<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-number">90</span>],[<span class="hljs-string">&#x27;heng&#x27;</span>,<span class="hljs-string">&#x27;80&#x27;</span>]]);       <span class="hljs-keyword">var</span> s = map.get(<span class="hljs-string">&#x27;jack&#x27;</span>);       <span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">//打印90</span><span class="hljs-comment">//Set 无序不重复的集合</span><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">//只有3,1，可去重</span>set.add(<span class="hljs-number">2</span>);set.delete(<span class="hljs-number">1</span>);<span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">3</span>)); <span class="hljs-comment">//判断set中是否含有3</span></code></pre><h2 id="2-3严格检查格式"><a href="#2-3严格检查格式" class="headerlink" title="2.3严格检查格式"></a>2.3严格检查格式</h2><pre><code class="hljs js"><span class="hljs-comment">/*  idea开启es6语法 ==&gt; settings,javascript version </span><span class="hljs-comment">&#x27;use strict&#x27;; 严格检查模式，必须写第一行，防止js的随意性产生问题</span><span class="hljs-comment">局部变量定义建议用let定义  */</span><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;</code></pre><h2 id="2-4-流程控制"><a href="#2-4-流程控制" class="headerlink" title="2.4 流程控制"></a>2.4 流程控制</h2><p>和java一样</p><pre><code class="hljs js"><span class="hljs-comment">//判断</span><span class="hljs-keyword">if</span>... else <span class="hljs-keyword">if</span>...else... <span class="hljs-comment">//循环</span><span class="hljs-keyword">for</span>，<span class="hljs-keyword">while</span>，<span class="hljs-keyword">do</span>...while <span class="hljs-keyword">var</span> num = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>];<span class="hljs-comment">//forEach调用函数进行遍历</span>num.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span><span class="hljs-function"></span>&#123;        <span class="hljs-built_in">console</span>.log(value)&#125;)<span class="hljs-comment">//iterator迭代器(es6引入)</span><span class="hljs-comment">//for..in ===&gt;  for(var index in object) &#123;&#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> numKey <span class="hljs-keyword">in</span> num) &#123;    <span class="hljs-built_in">console</span>.log(num[numKey]);&#125;<span class="hljs-comment">//for..of </span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sElement <span class="hljs-keyword">of</span> num) &#123;    <span class="hljs-built_in">console</span>.log(sElement);&#125;</code></pre><h1 id="3-函数及面向对象"><a href="#3-函数及面向对象" class="headerlink" title="3.函数及面向对象"></a>3.函数及面向对象</h1><h2 id="3-1-函数定义及变量作用域"><a href="#3-1-函数定义及变量作用域" class="headerlink" title="3.1 函数定义及变量作用域"></a>3.1 函数定义及变量作用域</h2><p><strong>定义函数</strong> </p><pre><code class="hljs js"><span class="hljs-comment">//1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> -x;    &#125;&#125;<span class="hljs-comment">//2</span><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123; ...  &#125;</code></pre><blockquote><p>js函数调用可以传递任意多个参数，也可以不传递参数，不报错，可进行手动定义异常</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//手动定义异常</span><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Not a number&quot;</span>;&#125;<span class="hljs-comment">//可利用arguments获得传递来的参数，是一个数组</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x = &quot;</span>+x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[i]);&#125;</code></pre><p><img src="/2022/01/21/JavaScript/05.png" alt="image-20220122181527949"></p><p>问题：因为arguments获取所有的参数，如果我们想获取除传递以外的参数，如何办？</p><blockquote><p>rest ===&gt; es6引入的新特性，可获取除定义外的所有参数</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//以前获取</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">arguments</span>; i++) &#123;        <span class="hljs-comment">//....   </span>    &#125;&#125;<span class="hljs-comment">//现在rest==&gt;   只能写在最后面，用...标识</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a,b,...rest</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span> + a);        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;b&quot;</span> + b);        <span class="hljs-built_in">console</span>.log(rest);&#125;</code></pre><p><img src="/2022/01/21/JavaScript/06.png" alt="image-20220122183233655"></p><p><strong>作用域</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;    x = x + <span class="hljs-number">1</span>;&#125;x = x +<span class="hljs-number">2</span>;<span class="hljs-comment">//Uncaught ReferenceError: x is not defined</span></code></pre><p>若函数外想访问里面的变量，如何操作===&gt;  <strong>闭包</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<span class="hljs-comment">//内部函数可以访问外部函数,反之可以</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> y = x + <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">var</span> z = y + <span class="hljs-number">1</span>;<span class="hljs-comment">//Uncaught ReferenceError: z is not defined</span>&#125;</code></pre><blockquote><p>提升作用域问题===&gt;  <strong>故所有的变量定义均放在头部(规范)</strong></p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;x &quot;</span> + y;    <span class="hljs-built_in">console</span>.log(x);    <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;y&#x27;</span>; <span class="hljs-comment">//此时y的定义将提升，但是对其赋值并不会</span>&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> y;    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;x &quot;</span> + y;    <span class="hljs-built_in">console</span>.log(x);    y = <span class="hljs-string">&#x27;y&#x27;</span>; <span class="hljs-comment">//此时y的定义将提升，但是对其赋值并不会</span>&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//格式:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>,         y = x + <span class="hljs-number">1</span>,         z,i,a;<span class="hljs-comment">//undefined    </span>    <span class="hljs-comment">//之后进行使用，若再需要新变量，上面继续添加</span>&#125;</code></pre><p><strong>全局变量</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">//x为全局变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(x);&#125;f1();<span class="hljs-built_in">console</span>.log(x);<span class="hljs-comment">//打印：  1  1</span></code></pre><p>js实际上只有一个全局作用域，**任何变量(函数也可当做变量)**，假设没有在函数的作用范围内找到，则向外查找，如果全局作用域都没找到，则报错<code>RefrenceError</code></p><blockquote><p>规范：</p><p>因为<strong>所有的全局变量均绑定到我们的windows对象上</strong>(alert也是在windows上的)，故如果不同的js文件，若使用了相同的全局变量。</p><p>则造成冲突，如何解决？===&gt;</p><p><strong>把自己的代码全部放在自己定义的唯一空间名字中，降低全局命名冲突的问题</strong></p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> Yiheng = &#123;&#125;; <span class="hljs-comment">//自己定义的唯一全局变量  ===&gt;  jQuery就是如此操作的</span><span class="hljs-comment">//若定义其他的，则进行如下操作</span>Yiheng.name = <span class="hljs-string">&quot;yiheng&quot;</span>;Yiheng.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;</code></pre><p><strong>局部作用域 ==&gt; <code>let</code>关键字定义变量</strong></p><p><strong>常量</strong> ==&gt; <code>const</code></p><blockquote><p>在es6之前，定义常量是规定用大写字母进行定义，然后建议不修改！(有点扯….2333)</p><p>故es6引入了const用于修饰常量</p></blockquote><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a><strong>3</strong>.2 方法</h2><p>方法即是把函数放在对象的里面，<strong>对象只有：属性和方法</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> heng = &#123;    name : <span class="hljs-string">&quot;yiheng&quot;</span>,    brith : <span class="hljs-string">&#x27;2000&#x27;</span>,     <span class="hljs-comment">//方法    </span>    age : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();         <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.brith;  <span class="hljs-comment">//this默认指向调用它的对象    </span>    &#125;&#125;<span class="hljs-comment">//调属性</span>heng.name;<span class="hljs-comment">//调方法</span>heng.age();</code></pre><p>在js中，可以控制this的指向 ===&gt; 通过<code>apply</code>,所有的函数均有</p><pre><code class="hljs js"><span class="hljs-comment">//可将方法定义在外面</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();       <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.brith;&#125;<span class="hljs-keyword">var</span> heng = &#123;     name : <span class="hljs-string">&quot;yiheng&quot;</span>,      brith : <span class="hljs-string">&#x27;2000&#x27;</span>,        <span class="hljs-comment">//方法    </span>    age : getAge&#125;<span class="hljs-comment">//调用调用    </span>heng.age() <span class="hljs-comment">//打印22    </span>getAge()  <span class="hljs-comment">//打印NaN  this并没有指向heng    </span>getAge.apply(heng,[]);  <span class="hljs-comment">//此时this指向了heng，打印22</span></code></pre><h2 id="3-3创建对象"><a href="#3-3创建对象" class="headerlink" title="3.3创建对象"></a>3.3创建对象</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> student  =  &#123;        name : <span class="hljs-string">&quot;jack&quot;</span>,        age : <span class="hljs-string">&#x27;20&#x27;</span>,        run : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run...&quot;</span>);       &#125;&#125;<span class="hljs-keyword">var</span> heng = &#123;    name : <span class="hljs-string">&quot;heng&quot;</span>&#125;heng.__proto__ = student; <span class="hljs-comment">//将heng指向student，即heng的原型为student</span></code></pre><h2 id="3-4class继承-新特性"><a href="#3-4class继承-新特性" class="headerlink" title="3.4class继承(新特性)"></a>3.4class继承(新特性)</h2><blockquote><p><code>class</code>在es6引入</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//定义Student类，js中叫做  原型对象 JavaScript仍然是基于原型的。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name) &#123;        <span class="hljs-built_in">this</span>.name = name;        &#125;        hello() &#123;                alert(<span class="hljs-string">&quot;hello!&quot;</span>);        &#125;&#125;<span class="hljs-comment">//声明对象</span><span class="hljs-keyword">var</span> heng = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Yiheng&quot;</span>);</code></pre><pre><code class="hljs js"><span class="hljs-comment">//继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pupil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name,grade) &#123;         <span class="hljs-built_in">super</span>();                <span class="hljs-built_in">this</span>.grade = grade;     &#125;       my() &#123;         alert(<span class="hljs-string">&quot;我是小学生&quot;</span>);     &#125;&#125;<span class="hljs-keyword">var</span> jack = <span class="hljs-keyword">new</span> pupil(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">2</span>);</code></pre><h2 id="3-5原型链继承-难"><a href="#3-5原型链继承-难" class="headerlink" title="3.5原型链继承(难)"></a>3.5原型链继承(难)</h2><blockquote><ul><li><p>每个对象都有一个<code>__proto__</code>，它指向它的<code>prototype</code>原型对象，而<code>prototype</code>原型对象又具有一个自己的<code>prototype</code>原型对象，就这样层层往上直到一个对象的原型<code>prototype</code>为<code>null</code></p><p>这个查询的路径就是<code>原型链</code></p></li></ul></blockquote><p><img src="/2022/01/21/JavaScript/07.png" alt="image-20220123155241306"></p><h1 id="4-常用对象"><a href="#4-常用对象" class="headerlink" title="4.常用对象"></a>4.常用对象</h1><h2 id="4-1Date"><a href="#4-1Date" class="headerlink" title="4.1Date"></a>4.1Date</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();date.getFullYear();date.getMonth();date.getDate();date.getDay();date.getHours();date.getMinutes();date.getSeconds();date.getTime(); <span class="hljs-comment">//时间戳==&gt; 1970-1-1-0:00 到今天的毫秒数</span>date.toDateString()<span class="hljs-string">&#x27;Sun Jan 23 2022&#x27;</span>date.toGMTString()<span class="hljs-string">&#x27;Sun, 23 Jan 2022 06:48:52 GMT&#x27;</span></code></pre><h2 id="4-2-JSON"><a href="#4-2-JSON" class="headerlink" title="4.2 JSON"></a>4.2 JSON</h2><blockquote><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2">资料交换格式</a>,采用<strong>完全独立于编程语言的文本格式</strong>来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率</p></blockquote><p>在js中，一切均对象，任何js支持的类型均可以用JSON进行表示</p><p>格式：  </p><ul><li>对象都用 {}</li><li>数组用 []</li><li>所有的键值对 用key : value</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;    name:<span class="hljs-string">&quot;heng&quot;</span>,     age : <span class="hljs-number">20</span>,    <span class="hljs-attr">sex</span> : <span class="hljs-string">&#x27;男&#x27;</span>&#125;<span class="hljs-comment">//对象转json字符串</span><span class="hljs-built_in">JSON</span>.stringify(obj)<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;heng&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span><span class="hljs-comment">// json字符串解析为对象</span><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;heng&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span>)&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;heng&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;</code></pre><p><strong>Ajax</strong></p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术）</p><p>指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术</p></blockquote><ul><li>原生的js写法 ==&gt; xhr 异步请求</li><li>jQuery封装的方法 ==&gt; $(“#name”).ajax(“”)</li><li>axios请求</li></ul><h1 id="5操作Dom元素"><a href="#5操作Dom元素" class="headerlink" title="5操作Dom元素"></a>5操作Dom元素</h1><p>Document Object Model  文档对象化模型</p><p><strong>浏览器网页即是一个Dom树结构</strong></p><p><img src="/2022/01/21/JavaScript/08.png" alt="image-20220123183002561"></p><p><strong>核心：增删改查</strong></p><p>要操作Dom结点，则必须<strong>获得此节点</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;father&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>h1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;p1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-comment">//对应css选择器</span></span><span class="javascript">    <span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> p1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;p2&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;father&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> childrens = father.children; <span class="hljs-comment">//获得父节点下的所有子节点</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>上面均是原生代码，之后将使用<code>jQuery</code>代替</p><h2 id="5-1插入Dom"><a href="#5-1插入Dom" class="headerlink" title="5.1插入Dom"></a>5.1插入Dom</h2><p>获得Dom结点后。若dom结点为空，则通过<code>innerHTML</code>就可以增加一个元素</p><p>若这个dom结点存在元素，则会导致覆盖，不采用！  采用<code>append</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;js&quot;</span>&gt;</span>javaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;se&quot;</span>&gt;</span>javase<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;ee&quot;</span>&gt;</span>javaee<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;me&quot;</span>&gt;</span>javaMe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span>  js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;js&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-comment">//浏览器执行追加</span>list.append(js)</code></pre><p>如图<img src="/2022/01/21/JavaScript/09.png" alt="image-20220123200924488"></p><p><strong>创建新结点</strong></p><pre><code class="hljs js"><span class="hljs-comment">//通过js创建新结点</span><span class="hljs-keyword">var</span> newP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);newP.id = <span class="hljs-string">&quot;newP&quot;</span>;newP.innerText = <span class="hljs-string">&quot;hello!&quot;</span>;<span class="hljs-comment">//追加newp到list后面 </span>list.append(newP);<span class="hljs-comment">//还可以利用 insertBefore() 方法在已有的子节点前插入一个新的子节点。</span>node.insertBefore(要插入的节点对象,要添加新的节点前的子节点)</code></pre><p>可看到<img src="/2022/01/21/JavaScript/10.png" alt="image-20220123201719110"></p><pre><code class="hljs js"><span class="hljs-comment">//可以插入各种标签，比如js</span><span class="hljs-keyword">var</span> myScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)myScript.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>,<span class="hljs-string">&#x27;text/javascript&#x27;</span>);list.append(myScript);</code></pre><p><img src="/2022/01/21/JavaScript/11.png" alt="image-20220123202857433"></p><pre><code class="hljs js"><span class="hljs-comment">//甚至修改body的属性，可以添加css进行改变</span><span class="hljs-keyword">var</span> myStyle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>);myStyle.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>,<span class="hljs-string">&#x27;text/css&#x27;</span>);myStyle.innerHTML = <span class="hljs-string">&#x27;body&#123;background-color:chartreuse&#125;&#x27;</span>; <span class="hljs-comment">//设置样式</span><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].append(myStyle); <span class="hljs-comment">//在head内部添加css代码，此时就会生效</span></code></pre><p><img src="/2022/01/21/JavaScript/12.png" alt="image-20220123203852757"></p><p><img src="/2022/01/21/JavaScript/13.png" alt="image-20220123204006113"></p><h2 id="5-2-更新Dom"><a href="#5-2-更新Dom" class="headerlink" title="5.2 更新Dom"></a>5.2 更新Dom</h2><p><strong>操作文本</strong>  设置之后将会在对应网页显示出来</p><pre><code class="hljs js">id1.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span><span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span>id1.innerText = <span class="hljs-string">&quot;123&quot;</span><span class="hljs-string">&#x27;123&#x27;</span></code></pre><p><strong>操作css</strong></p><pre><code class="hljs js">id1.style.color = <span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-string">&#x27;red&#x27;</span>id1.style.fontSize = <span class="hljs-string">&#x27;100px&#x27;</span><span class="hljs-string">&#x27;100px&#x27;</span></code></pre><h2 id="5-3删除Dom"><a href="#5-3删除Dom" class="headerlink" title="5.3删除Dom"></a>5.3删除Dom</h2><p>步骤：先获取它父节点，然后通过父节点删除它</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> self = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);<span class="hljs-keyword">var</span> father = self.parentElement;father.removeChild(self);<span class="hljs-comment">//获得自己，然后得到自己的父亲，然后通过父亲杀死自己</span></code></pre><p>删除结点的时候，是动态的过程，children是时刻变化的</p><h1 id="6-操作Bom元素-重点"><a href="#6-操作Bom元素-重点" class="headerlink" title="6.操作Bom元素(重点)"></a>6.操作Bom元素(重点)</h1><p><strong>Browser Object Model</strong> (浏览器对象模型)</p><blockquote><p> js的出现就是为了能让它在浏览器中运行！</p></blockquote><h2 id="6-1Windows"><a href="#6-1Windows" class="headerlink" title="6.1Windows"></a>6.1Windows</h2><p>浏览器窗口 </p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.outerHeight<span class="hljs-number">824</span><span class="hljs-built_in">window</span>.outerWidt<span class="hljs-number">1536</span><span class="hljs-built_in">window</span>.innerHeight<span class="hljs-number">287</span><span class="hljs-built_in">window</span>.innerWidth<span class="hljs-number">1536</span><span class="hljs-comment">//....</span></code></pre><h2 id="6-2-navigator"><a href="#6-2-navigator" class="headerlink" title="6.2 navigator"></a>6.2 navigator</h2><pre><code class="hljs js">navigator.appName<span class="hljs-string">&#x27;Netscape&#x27;</span>navigator.appVersion<span class="hljs-string">&#x27;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&#x27;</span>navigator.userAgent<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&#x27;</span>navigator.platform<span class="hljs-string">&#x27;Win32&#x27;</span></code></pre><p>不建议使用这个属性来判断或编写代码，因为会被人为修改</p><h2 id="6-3-screen"><a href="#6-3-screen" class="headerlink" title="6.3 screen"></a>6.3 screen</h2><pre><code class="hljs js">screen.width1536 <span class="hljs-comment">//pxscreen.height864 //px</span></code></pre><h2 id="6-4-location"><a href="#6-4-location" class="headerlink" title="6.4 location"></a>6.4 location</h2><p>定位==&gt; <strong>Location 对象包含有关当前 URL 的信息</strong></p><pre><code class="hljs awk">location.reload()  <span class="hljs-regexp">//</span>重新加载页面，即刷新<span class="hljs-regexp">//</span> 跳转到指定页面,设置新的地址location.assign(<span class="hljs-string">&quot;URL&quot;</span>)</code></pre><h2 id="6-5-Document"><a href="#6-5-Document" class="headerlink" title="6.5 Document"></a>6.5 Document</h2><p><strong>代表当前页面</strong>，html dom文档树</p><p>可获取具体的文档树节点，则可以动态增删节点，即修改网页</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaEE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaSE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> test_dl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//打印 test_dl  可获取具体内容//可获取cookiedocument.cookie</code></pre><p>当<a href="https://www.taobao.com/">淘宝</a>在网址上登陆时，此时<a href="https://www.tmall.com/">天猫</a>也进行同步登陆了===&gt; 拿到cookie就可以访问你的信息，故尽量不要暴露cookie</p><p>服务器端可以设置cookie：httpOnly</p><h2 id="6-6-History"><a href="#6-6-History" class="headerlink" title="6.6 History"></a>6.6 History</h2><p>代表浏览器的历史记录</p><pre><code class="hljs awk">history.back() <span class="hljs-regexp">//</span>后退history.forward() <span class="hljs-regexp">//</span>前进</code></pre><h2 id="6-7-操作表单"><a href="#6-7-操作表单" class="headerlink" title="6.7 操作表单"></a>6.7 操作表单</h2><p>网站怎样与用户进行交互？==&gt;使用HTML表单(form)。</p><p><strong>表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</strong><br> 语法：<code>&lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt;</code></p><p>什么是表单？</p><ul><li>文本框 text</li><li>下拉框 <select></select></li><li>单选框 radio</li><li>多选框 checkbox</li><li>隐藏框 hidden</li><li>密码框 password…..</li></ul><p>表单的目的  ===&gt;  <strong>提交信息</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;username&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   <span class="hljs-keyword">var</span> input_text = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><span class="javascript">  <span class="hljs-comment">//得到输入框的值： 浏览器console中输入===&gt;  input_text.value</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>前端一般会采用<code>MD5</code>进行加密</p><h1 id="7-jQuery"><a href="#7-jQuery" class="headerlink" title="7.jQuery"></a>7.jQuery</h1><p>是一个库，里面包含了大量的js函数</p><p> <a href="https://jquery.com/download/">jQuery下载</a></p><pre><code class="hljs html">//引用<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中</p><p>而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名</p><p><strong>公式</strong>: <code>$(css选择器).事件(事件函数)</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span> =<span class="hljs-string">&quot;test&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    $(<span class="hljs-string">&#x27;#test&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        alert(<span class="hljs-string">&quot;hello jQuery!&quot;</span>)</span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><a href="https://jquery.cuishifeng.cn/">jQuery API中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>普通 vs 多线程</p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/01.png" alt="image-20220120175224495"></p><ul><li><p>程序：指指令和数据的有序集合，其本身没有任何含义，是一个<strong>静态</strong>的概念</p></li><li><p>进程：指程序的一次执行过程，<strong>动态</strong>的概念，是系统资源分配的单位</p><ul><li>通常一个进程包含多个<strong>线程</strong>。<strong>线程是CPU调度和执行的单位</strong></li></ul></li></ul><p><strong>主要概念：</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/02.png" alt="image-20220120175908442"></p><h1 id="二-线程实现-重点"><a href="#二-线程实现-重点" class="headerlink" title="二.线程实现(重点)"></a>二.线程实现(重点)</h1><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/03.png" alt="image-20220126091456256"></p><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><ul><li>自定义线程类继承<strong>Thread类</strong></li><li>重写**run()**方法，编写线程执行体</li><li>创建线程对象，调用**start()**方法启动线程</li></ul><blockquote><p>线程开启不一定立刻执行，由cpu调度</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    <span class="hljs-comment">//主线程</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程对象</span>        Main testThread = <span class="hljs-keyword">new</span> Main();        <span class="hljs-comment">//调用start方法，开启线程</span>        testThread.start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习main线程&quot;</span> + i);        &#125;     &#125;     <span class="hljs-comment">//run方法线程</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习run线程&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><ul><li><p>定义MyRunnable类实现<strong>Runnable接口</strong></p></li><li><p><strong>实现run()方法</strong>，编写线程执行体</p></li><li><p>创建线程对象，调用**start()**方法启动线程</p><blockquote><p>由于java的单继承 ,故推荐使用<strong>Runnable接口</strong> 来进行实现多线程</p><p>方便同一个对象被多个线程使用</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-comment">//创建线程==&gt; 2.实现Runnable接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread_03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建实现Runnable接口对象</span>        TestThread_03 t = <span class="hljs-keyword">new</span> TestThread_03();        <span class="hljs-comment">//创建线程对象，通过对象，开启线程 ==&gt; ( 代理 )</span>        <span class="hljs-keyword">new</span> Thread(t).start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习main线程&quot;</span> + i);        &#125;    &#125;    <span class="hljs-comment">//run方法线程</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习run线程&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><p>两者对比：</p><pre><code class="hljs java"><span class="hljs-comment">//1.继承Thread类</span>PrimeThread p = <span class="hljs-keyword">new</span> PrimeThread();p.start();  <span class="hljs-comment">//2.实现Runnable接口 </span>PrimeRun p = <span class="hljs-keyword">new</span> PrimeRun();<span class="hljs-keyword">new</span> Thread(p).start();</code></pre><p><strong>并发</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-comment">//模拟多线程抢票 ==&gt; 即多个线程共享同一个资源 （ 会导致资源同时被占用 )</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread04</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tick_num = <span class="hljs-number">10</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (tick_num &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢走了第&quot;</span> + (tick_num--) + <span class="hljs-string">&quot;票&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TestThread04 t4 = <span class="hljs-keyword">new</span> TestThread04();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;jack&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;Tom&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;rogue&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="3-实现callable接口"><a href="#3-实现callable接口" class="headerlink" title="3.实现callable接口"></a>3.实现callable接口</h2><p>(了解)</p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/04.png" alt="image-20220126104754812"></p><p>  具体==&gt; 多线程下载图片  (利用callable) </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Boolean</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> String url; <span class="hljs-comment">//图片地址</span>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//图片名字</span>    <span class="hljs-comment">//构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestCallable</span><span class="hljs-params">(String url, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.url = url;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-comment">//重写call方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        WebDownloader webDownloader = <span class="hljs-keyword">new</span> WebDownloader();        webDownloader.downloader(url, name);        System.out.println(<span class="hljs-string">&quot;Ok ==&gt; &quot;</span> + name);<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        TestCallable t1 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx3.sinaimg.cn/mw2000/007ZMXFDly1gym8x8f8okj30gu0nk0ub.jpg&quot;</span>, <span class="hljs-string">&quot;math01.jpg&quot;</span>);        TestCallable t2 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx4.sinaimg.cn/mw2000/007ZMXFDly1gym8x8o91gj30h10lcwfz.jpg&quot;</span>, <span class="hljs-string">&quot;math02.jpg&quot;</span>);        TestCallable t3 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx1.sinaimg.cn/mw2000/008buUVXgy1gyoro1n27aj31410u0whn.jpg&quot;</span>, <span class="hljs-string">&quot;math03.jpg&quot;</span>);        <span class="hljs-comment">//创建执行服务</span>        ExecutorService ser = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-comment">//提交执行</span>        Future&lt;Boolean&gt; result1 = ser.submit(t1);        Future&lt;Boolean&gt; result2 = ser.submit(t2);        Future&lt;Boolean&gt; result3 = ser.submit(t3);        <span class="hljs-comment">//执行结果</span>        <span class="hljs-keyword">boolean</span> r1 = result1.get();        <span class="hljs-keyword">boolean</span> r2 = result2.get();        <span class="hljs-keyword">boolean</span> r3 = result3.get();        <span class="hljs-comment">//关闭服务</span>        ser.shutdownNow();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebDownloader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloader</span><span class="hljs-params">(String url,String name)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> URL(url),<span class="hljs-keyword">new</span> File(name));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;io异常，downloader方法出错！&quot;</span>);        &#125;    &#125;&#125;</code></pre><h2 id="4-静态代理"><a href="#4-静态代理" class="headerlink" title="4.静态代理"></a>4.静态代理</h2><p>真实对象和代理对象都要实现同一个接口</p><p>代理对象要代理真实目标角色    </p><blockquote><p><strong>代理模式</strong>给某一个对象提供一个代理对象，并<strong>由代理对象控制对原对象的引用</strong>  即</p><p>就是提供一个对象相当于中介者，他可以帮我们调用目标的功能，同时我们可以在使用目标功能的同时扩展其他功能，而不需要直接改到目标类。</p></blockquote><p>代理的好处：</p><ul><li><strong>中介隔离</strong>作用：在某些情况下，如果某个类并不想被直接调用，那么通过创建代理类，就可以避免目标类被直接调用，这样可以保护目标类不会被曝光</li><li>可以<strong>扩展功能而不用影响目标类</strong>：假设有一个核心类提供了一些核心业务，而我们希望使用这个功能时上报日志，或者某个业务要先进行某些处理才调用，那这样如果直接改核心类，就会给核心功能加上了一些无关的内容，变得这个功能与业务有很大关联，难以复用。这时我们使用代理类的话，就可以在代理类中添加自己的业务逻辑，而不需要破坏原有的核心功能。</li></ul><blockquote><p><strong>静态代理</strong>指是由程序员手动编写或者自动生成的代理类，在程序编译的时候就可以生成对应的class文件，在运行时可以直接使用。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StaticProxy staticProxy = <span class="hljs-keyword">new</span> StaticProxy(<span class="hljs-keyword">new</span> User_01());        staticProxy.sayHello();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User_01</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-keyword">private</span> User_01 target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxy</span><span class="hljs-params">(User_01 target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;before hello&quot;</span>);        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;            target.sayHello(); <span class="hljs-comment">// 实际调用目标功能</span>        &#125;        System.out.println(<span class="hljs-string">&quot;after hello&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*打印：</span><span class="hljs-comment">before hello</span><span class="hljs-comment">hello!</span><span class="hljs-comment">after hello</span><span class="hljs-comment">*/</span></code></pre><h2 id="5-Lamda表达式"><a href="#5-Lamda表达式" class="headerlink" title="5.Lamda表达式"></a>5.Lamda表达式</h2><p>避免匿名内部类定义过多</p><p>实质属于<strong>函数式编程</strong>的概念</p><p><code>(parama) -&gt; expression[表达式]</code></p><p><code>(params) -&gt; statement[语句] </code></p><p><code>(params) -&gt; &#123;statements&#125;</code></p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread( ()-&gt; System.out.println(<span class="hljs-string">&quot;多线程学习.....&quot;</span>) ).start();</code></pre><p><strong>Functional Interface ( 函数式接口 )</strong>  学习java8 lamda表达式的关键</p><pre><code class="hljs java"><span class="hljs-comment">//定义： 任何接口，若只包含唯一一个抽象方法，则就是一个函数式接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>对于函数式接口，我们可以通过lamda表达式来创建该接口的对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLamda</span> </span>&#123;    <span class="hljs-comment">//3.静态内部类</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like2</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">&quot;I like lamda2...&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//调用2</span>        <span class="hljs-keyword">new</span> like().lamda();        <span class="hljs-comment">//调用3</span>        <span class="hljs-keyword">new</span> like2().lamda();        <span class="hljs-comment">//4局部内部类</span>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like3</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;I like lamda3...&quot;</span>);            &#125;        &#125;        <span class="hljs-comment">//调用4</span>        <span class="hljs-keyword">new</span> like3().lamda();        <span class="hljs-comment">//5.匿名内部类</span>        Ilike like = <span class="hljs-keyword">new</span> like();        like = <span class="hljs-keyword">new</span> Ilike() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;I like lamda4...&quot;</span>);            &#125;        &#125;;        <span class="hljs-comment">//调用5</span>        like.lamda();        <span class="hljs-comment">//6 lamda表达式</span>        like = () -&gt;  &#123;            System.out.println(<span class="hljs-string">&quot;I like lamda5...&quot;</span>);        &#125;;        like.lamda();    &#125;&#125;<span class="hljs-comment">//1接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Ilike</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//2.实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;I like lamda1...&quot;</span>);    &#125;&#125;</code></pre><h1 id="三-线程状态"><a href="#三-线程状态" class="headerlink" title="三.线程状态"></a>三.线程状态</h1><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/05.png" alt="image-20220127111512199"></p><p><strong>线程方法</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/06.png" alt="image-20220127112036363"></p><h2 id="1-线程停止"><a href="#1-线程停止" class="headerlink" title="1.线程停止"></a>1.线程停止</h2><ul><li><p>不推荐jdk推荐的<code>stop()</code> 和 <code>destroy()</code> 方法  (官方已废弃)</p></li><li><p>推荐让线程自己停下来</p></li><li><p>建议使用标志位进行中止，当<code>flag = false</code>,则中止</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-comment">//标志位</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (flag) &#123;          System.out.println(<span class="hljs-string">&quot;run..&quot;</span> + i++);      &#125;  &#125;  <span class="hljs-comment">//提供方法停止线程</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;      flag = <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      TestStop testStop = <span class="hljs-keyword">new</span> TestStop();      <span class="hljs-keyword">new</span> Thread(testStop).start(); <span class="hljs-comment">//启动线程</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(<span class="hljs-string">&quot;main...&quot;</span> + i);          <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">80</span> ) &#123;              testStop.stop();              System.out.println(<span class="hljs-string">&quot;this thread stopped!&quot;</span>);          &#125;      &#125;  &#125;&#125;</code></pre></li></ul><h2 id="2-线程睡眠"><a href="#2-线程睡眠" class="headerlink" title="2.线程睡眠"></a>2.线程睡眠</h2><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/07.png" alt="image-20220127113355513"> </p> <pre><code class="hljs java"><span class="hljs-comment">//倒计时</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSleep</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            tenDown();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;     <span class="hljs-comment">//获取系统时间,并进行比变化</span>        Date date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);                System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(date));                date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());<span class="hljs-comment">//更新时间</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tenDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//每一次一秒钟进行倒计时</span>            Thread.sleep(<span class="hljs-number">1000</span>) ;            System.out.println(num --);            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="3-线程礼让"><a href="#3-线程礼让" class="headerlink" title="3.线程礼让"></a>3.线程礼让</h2><ul><li>让正在执行的线程暂停，但不阻塞</li><li>将线程从运行变为就绪</li><li>cpu重新调度，是否礼让成功，根据cpu而定，仍然又可能让了之后，还继续执行 </li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestYield</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyYield myYield = <span class="hljs-keyword">new</span> MyYield();        <span class="hljs-keyword">new</span> Thread(myYield,<span class="hljs-string">&quot;a==&gt;&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(myYield,<span class="hljs-string">&quot;b==&gt;&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyYield</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;start...&quot;</span>); <span class="hljs-comment">//线程开始</span>        Thread.yield(); <span class="hljs-comment">//当前线程进行礼让</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;end...&quot;</span>); <span class="hljs-comment">//线程结束</span>    &#125;&#125;</code></pre><p><strong>Join 合并线程</strong></p><ul><li>让线程强制等待，待此线程执行完成后，再执行其他线程，其他线程阻塞 ( <strong>理解为插队</strong> )</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJoin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        TestJoin testJoin = <span class="hljs-keyword">new</span> TestJoin();        Thread thread = <span class="hljs-keyword">new</span> Thread(testJoin);        thread.start(); <span class="hljs-comment">//启动run</span>        <span class="hljs-comment">//主线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">if</span>( i == <span class="hljs-number">50</span>) &#123;                System.out.println(<span class="hljs-string">&quot;插队!main等待我执行完才可执行!!&quot;</span>);                thread.join(); <span class="hljs-comment">//进行插队,此时vip一直打印到结束</span>            &#125;            System.out.println(<span class="hljs-string">&quot;main ..&quot;</span> +i);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;I am vip ..&quot;</span> + i) ;        &#125;    &#125;&#125;</code></pre><p><code>Thread.state</code> <strong>线程状态</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/blog\source_posts\java多线程\08.png" alt="image-20220127121229233"></p><p><strong>线程优先级</strong></p><ul><li><p>java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p></li><li><p>优先级用数字表示，0~10</p><pre><code class="hljs JAVA">Thread.MIN_PRIORITY = <span class="hljs-number">1</span>;Thread.MAX_PRIORITY = <span class="hljs-number">10</span>;Thread.NORM_PRIORITY = <span class="hljs-number">5</span>;</code></pre></li><li><p>使用<code>getPriority().setPriority(int xx)</code>改变优先级</p></li></ul><blockquote><p>优先级低，不代表调度概论低，要看cpu调度</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPriority</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + Thread.currentThread().getPriority());        MyPriority myPriority = <span class="hljs-keyword">new</span> MyPriority();        Thread t1 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t2 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t3 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t4 = <span class="hljs-keyword">new</span> Thread(myPriority);        <span class="hljs-comment">//先设置优先级，再启动</span>        t1.start(); <span class="hljs-comment">//t1默认优先级</span>        t2.setPriority(<span class="hljs-number">1</span>);        t2.start(); <span class="hljs-comment">//t2优先级设置为1</span>        t3.setPriority(<span class="hljs-number">6</span>);        t3.start(); <span class="hljs-comment">//t3.</span>        t4.setPriority(Thread.MAX_PRIORITY);        t4.start();<span class="hljs-comment">//t4..</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPriority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>  </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + Thread.currentThread().getPriority());    &#125;&#125;</code></pre><p><strong>守护线程</strong> <code>daemon</code></p><ul><li>线程分为<strong>用户线程和守护线程</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕 ==&gt; 如：后台记录操作日志，监控内存，垃圾回收…..</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDaemon</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        God god = <span class="hljs-keyword">new</span> God();        You you = <span class="hljs-keyword">new</span> You();        Thread thread = <span class="hljs-keyword">new</span> Thread(god);        thread.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//默认false是用户进程</span>        thread.start(); <span class="hljs-comment">//守护线程启动</span>        <span class="hljs-comment">//用户线程开启</span>        <span class="hljs-keyword">new</span> Thread(you).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;God always bless you!&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">365</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;I...&quot;</span> + i);        &#125;        System.out.println(<span class="hljs-string">&quot;bye!!!!&quot;</span>);    &#125;&#125;</code></pre><h1 id="四-线程同步-重点"><a href="#四-线程同步-重点" class="headerlink" title="四.线程同步(重点)"></a>四.线程同步(重点)</h1><p>多个线程操作同一个资源 </p><blockquote><p>并发： <strong>同一个对象</strong>被<strong>多个线程</strong>同时操作</p></blockquote><p>当多个线程访问一个对象，并且某些线程要修改对象，这时需要<strong>线程同步</strong></p><p>线程同步其实是一种<strong>等待机制</strong>，多个需要同时访问此对象的线程进入这个<strong>对象的等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用</p><blockquote><p><strong>队列 + 锁</strong> 才可保证线程同步的安全性</p></blockquote><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/09.png" alt="image-20220127152403260"></p><pre><code class="hljs java"><span class="hljs-comment">//线程不安全的集合，因为线程会操作同一个地方，导致覆盖，最终打印并非10000</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnSafeList</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String &gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread( ()-&gt; &#123;                list.add(Thread.currentThread().getName());            &#125;).start();        &#125;        System.out.println(list.size());    &#125;&#125;</code></pre><p>在这个例子里，有两个问题</p><ul><li>第一是有些线程执行的太慢了，main线程执行完了，还有部分线程没执行完</li><li>第二是是可能会好多线程操作list的同一个l位置。</li></ul><p>加上<code>synchronized  (list) &#123; &#125;</code>之后解决了第二个问题。</p><p>第一个问题的原因，是<code>main</code>线程执行完了之后，还会有部分线程没执行完，在最后加上<code>sleep</code>，使得main线程先停止下，等待其他的线程执行完，然后输出就能正常了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnSafeList</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String &gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread( ()-&gt; &#123;                <span class="hljs-keyword">synchronized</span> (list) &#123;                    list.add(Thread.currentThread().getName());                &#125;            &#125;).start();        &#125;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(list.size());    &#125;&#125;</code></pre><p><code>synchronized</code>关键字 可分为<code>synchronized</code>方法 和 <code>synchronized</code>块</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> args)</span> </span>&#123;&#125;</code></pre><p>同步块：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(Obj) &#123;  &#125;</code></pre><p><strong>Obj为同步监视器，</strong>可以使任何对象，但一般使用共享资源作为同步监视器</p><p>同步方法中则不需要指定同步监视器，因为就是this对象本身</p><p>执行过程：</p><ul><li>a访问，锁定obj，执行代码</li><li>b访问，发现被锁，无法进行访问</li><li>a执行完毕，解锁</li><li>b访问，发现没锁，进行访问</li></ul><h1 id="五-线程通信"><a href="#五-线程通信" class="headerlink" title="五.线程通信"></a>五.线程通信</h1><h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>125.验证回文串</title>
    <link href="/2022/01/19/leetcode08/"/>
    <url>/2022/01/19/leetcode08/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个字符串，验证它是否是回文串，<strong>只考虑字母和数字字符</strong>，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p><p> 示例 1:</p><p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p><p>示例 2:</p><p>输入: “race a car”<br>输出: false<br>解释：”raceacar” 不是回文串</p><p>提示：</p><p>1 &lt;= s.length &lt;= 2 * 105<br>字符串 s 由 ASCII 字符组成</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>自顶向下思考</strong> ==&gt;  从高层次(主干) 逻辑 入手 ==&gt;</p><pre><code>1. filter out number &amp; char 2. reverse and compare</code></pre><h2 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        String filterS = _filterNonNumberAndChar(s);        <span class="hljs-keyword">return</span> _reverse(filterS).equalsIgnoreCase(filterS);     &#125;    <span class="hljs-comment">//filter out number &amp; char </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String  <span class="hljs-title">_filterNonNumberAndChar</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> s.replaceAll(<span class="hljs-string">&quot;[^A-Za-z0-9]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//正则表达式</span>    &#125;    <span class="hljs-comment">//reverse</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">_reverse</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuffer(s).reverse().toString();     &#125;&#125;</code></pre><p><strong>效率太低，又弄新字符串，又正则表达式</strong></p><h2 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解和反射</title>
    <link href="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-注解"><a href="#1-注解" class="headerlink" title="1.注解"></a>1.注解</h1><h2 id="1-1什么是注解"><a href="#1-1什么是注解" class="headerlink" title="1.1什么是注解"></a>1.1什么是注解</h2><p><strong>注解：Annotation</strong>(特殊的注释)</p><p><strong>注释：comment</strong></p><p>​    jdk5.0引入的新技术</p><p>作用：</p><ul><li>不是程序本身，可以对程序做出解释(与注释并无区别)</li><li><strong>可以被其他程序(如：编译器)读取</strong> </li></ul><p>格式：</p><blockquote><p>以 ”@注释名”在代码中存在，甚至可以添加一些参数 </p></blockquote><p>在哪使用:</p><blockquote><p>可附加在 package，class，method，field上，相当于添加了额外的辅助信息</p><p>然后通过反射机制编程实现对这些元数据的访问</p></blockquote><h2 id="1-2内置注解"><a href="#1-2内置注解" class="headerlink" title="1.2内置注解"></a>1.2内置注解</h2><ul><li>@Override：定义在java.lang.Override中，只适用于修饰方法<ul><li>表示一个方法声明打算重写父类的另一个方法声明</li></ul></li><li>@Deprecated：定义在java.lang.Deprecated中，可修饰方法，属性，类<ul><li>表示不推荐使用此类元素，通常是因为危险或存在其余更好的选择</li></ul></li><li>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用于抑制编译时的警告信息</li></ul><pre><code class="hljs java"><span class="hljs-comment">//需要添加参数才可以使用</span><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span></code></pre><h2 id="1-3元注解"><a href="#1-3元注解" class="headerlink" title="1.3元注解"></a>1.3元注解</h2><p>(meta-annotation)</p><p>作用：解释其他注解, 提供对其他annotation类型的作说明</p><ul><li><strong>@Target</strong>：用于描述注解的使用范围(被描述的注解可以在哪用)</li><li><strong>@Retention</strong>: 表示需要在什么级别保存该注解信息，用于描述注解的声明周期<ul><li>SOURCE &lt; CLASS &lt; RUNTIME</li></ul></li><li>@Document: 说明 注解将被包含在javadoc中</li><li>@Inherited: 说明子类可以继承父类中的该注解</li></ul><h2 id="1-4自定义注解"><a href="#1-4自定义注解" class="headerlink" title="1.4自定义注解"></a>1.4自定义注解</h2><p>使用@interface自定义，自动继承了java.lang.annotation.Annotation接口</p><p> <img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/00.png" alt="image-20220119063355717"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-comment">//可以进行显示赋值,与顺序无关，若没有默认值，则必须给注解赋值</span>    <span class="hljs-meta">@myAnnotation(age = 18,name = &quot;yiheng&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-meta">@myAnnotation01(&quot;Alice&quot;)</span> <span class="hljs-comment">// 此时可直接传入即可，不用写value = “Alice” (规范</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> myAnnotation&#123;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;  <span class="hljs-comment">//参数：  参数类型 + 参数名()</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;    String[] schools() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">&quot;pku&quot;</span>,<span class="hljs-string">&quot;cmu&quot;</span>&#125;;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> myAnnotation01&#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//若只要一个参数，用value</span>&#125;</code></pre><h1 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h1><p><strong>Reflection</strong></p><h2 id="2-1java反射概述"><a href="#2-1java反射概述" class="headerlink" title="2.1java反射概述"></a>2.1java反射概述</h2><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/01.png" alt="image-20220119065433643"></p><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p><p><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/02.png" alt="image-20220119070004240"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/03.png" alt="image-20220119071046834"></p><p><strong>优点</strong> ：</p><ul><li>可以实现动态创建对象和编译</li><li>灵活性高</li></ul><p><strong>缺点</strong>：</p><p>​    对性能有影响，是一种解释操作，比直接执行相同的操作慢</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/04.png" alt="image-20220119071312355"></p><h2 id="2-2理解class类并获取class实例"><a href="#2-2理解class类并获取class实例" class="headerlink" title="2.2理解class类并获取class实例"></a>2.2理解class类并获取class实例</h2><p><strong>Class类</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/05.png" alt="image-20220119075234418"></p><p><strong>Class类的功能</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/06.png" alt="image-20220119075357574"></p><pre><code class="hljs java"><span class="hljs-comment">// 1 通过对象方式获取</span>        Person p1 = <span class="hljs-keyword">new</span> Student();        Class c1  = p1.getClass();        System.out.println(c1.hashCode());<span class="hljs-comment">//2 通过forName 获取</span>        Class c2 = Class.forName(<span class="hljs-string">&quot;test.day04.test03.Student&quot;</span>); <span class="hljs-comment">//Student的路径</span>        System.out.println(c2.hashCode());<span class="hljs-comment">//3 通过类名.class获取</span>        Class c3 = Student.class;        System.out.println(c3.hashCode());<span class="hljs-comment">/*</span><span class="hljs-comment">356573597</span><span class="hljs-comment">356573597</span><span class="hljs-comment">356573597</span><span class="hljs-comment">*/</span></code></pre><p><strong>哪些类型有Class对象</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/07.png" alt="image-20220119081133308"></p><pre><code class="hljs java"> Class c1 = Integer.class; Class c2 = Override.class; Class c3 = Object.class; Class c4 = Comparable.class; Class c5 = String[].class; Class c6 = <span class="hljs-keyword">int</span>[][].class; Class c7 = ElementType.class; Class c8 = <span class="hljs-keyword">void</span>.class; Class c9 = Class.class;<span class="hljs-comment">/*</span><span class="hljs-comment">打印：</span><span class="hljs-comment">class java.lang.Integer</span><span class="hljs-comment">interface java.lang.Override</span><span class="hljs-comment">class java.lang.Object</span><span class="hljs-comment">interface java.lang.Comparable</span><span class="hljs-comment">class [Ljava.lang.String;</span><span class="hljs-comment">class [[I</span><span class="hljs-comment">class java.lang.annotation.ElementType</span><span class="hljs-comment">void</span><span class="hljs-comment">class java.lang.Class</span><span class="hljs-comment">*/</span></code></pre><h2 id="2-3-类的加载与ClassLoader"><a href="#2-3-类的加载与ClassLoader" class="headerlink" title="2.3 类的加载与ClassLoader"></a>2.3 类的加载与ClassLoader</h2><p>内存分析</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/08.png" alt="image-20220119081952225"></p><p><strong>类加载过程</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/09.png" alt="image-20220119082107807"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/10.png" alt="image-20220119083702892"></p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">1.加载到内存，会产生一个类对应的Class对象</span><span class="hljs-comment">2.链接，链接结束后 x = 0(默认)</span><span class="hljs-comment">3.初始化 </span><span class="hljs-comment">    &lt;clinit&gt;() &#123;</span><span class="hljs-comment">        System.out.println(&quot;A类静态代码块初始&quot;);</span><span class="hljs-comment">         x = 20;</span><span class="hljs-comment">         x = 10;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">static</span>  &#123;        System.out.println(<span class="hljs-string">&quot;A类静态代码块初始&quot;</span>);        x = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;A类构造方法初始&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    A a = <span class="hljs-keyword">new</span> A();    System.out.println(a.x);&#125;<span class="hljs-comment">/* 故打印结果</span><span class="hljs-comment">A类静态代码块初始</span><span class="hljs-comment">A类构造方法初始</span><span class="hljs-comment">10</span><span class="hljs-comment">*/</span></code></pre><p><strong>什么时候会发生类初始化 ？</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/11.png" alt="image-20220119084510203"></p><p><strong>类加载器</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/12.png" alt="image-20220119150313613">.</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/13.png" alt="image-20220119150339508"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/14.png" alt="image-20220119150420155"></p><h2 id="2-4获取运行时类的对象"><a href="#2-4获取运行时类的对象" class="headerlink" title="2.4获取运行时类的对象"></a>2.4获取运行时类的对象</h2><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/15.png" alt="image-20220119151416083"></p><p>有了Class类，能做什么？</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/16.png" alt="image-20220120074411795"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.day05.test01;<span class="hljs-comment">//User类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> id;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;            <span class="hljs-keyword">this</span>.id = id;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> age;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">this</span>.age = age;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.id = id;            <span class="hljs-keyword">this</span>.age = age;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                    <span class="hljs-string">&quot;, id=&quot;</span> + id +                    <span class="hljs-string">&quot;, age=&quot;</span> + age +                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;        &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;        <span class="hljs-comment">//获得对象</span>        Class c1 = Class.forName(<span class="hljs-string">&quot;test.day05.test01.User&quot;</span>);        <span class="hljs-comment">//构造一个对象  本质调用了User类中的无参构造器</span>        User user =(User) c1.newInstance();        System.out.println(user);<span class="hljs-comment">//  打印  User&#123;name=&#x27;null&#x27;, id=0, age=0&#125;</span>    &#125;</code></pre><p>若没有无参构造器，则如何操作？ ===&gt;  <strong>只需明确调用类中的构造器，并把参数传递过去</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/17.png" alt="image-20220120074626851"></p><pre><code class="hljs java"><span class="hljs-comment">//带有参数的构造器</span>      Constructor c2 = c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);      User user2 = (User)c2.newInstance(<span class="hljs-string">&quot;yiheng&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">20</span>);      System.out.println(user2); <span class="hljs-comment">//打印： User&#123;name=&#x27;yiheng&#x27;, id=1, age=20&#125;</span></code></pre><p><strong>反射操作方法</strong></p><pre><code class="hljs java">User user3 = (User)c1.newInstance();Method declaredMethod = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<span class="hljs-comment">//invoke激活==&gt; ( 对象 , &quot;对象的值&quot;)</span>declaredMethod.invoke(user3,<span class="hljs-string">&quot;恒&quot;</span>);System.out.println(user3.getName());  <span class="hljs-comment">// 打印 ： 恒</span></code></pre><p><strong>反射操作属性</strong></p><pre><code class="hljs java">User user4 = (User)c1.newInstance();Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);name.setAccessible(<span class="hljs-keyword">true</span>);name.set(user4,<span class="hljs-string">&quot;heng&quot;</span>);System.out.println(user4.getName());  <span class="hljs-comment">//加上之后，打印：heng</span><span class="hljs-comment">//报错，因为属性私有 不可以自己访问，只需关掉程序的安全检测 ==&gt; name.setAccessible(true);</span></code></pre><p><strong>setAccessible:</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/18.png" alt="image-20220120083625885"></p><h2 id="2-5反射操作泛型"><a href="#2-5反射操作泛型" class="headerlink" title="2.5反射操作泛型"></a>2.5反射操作泛型</h2><p>(了解)</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/19.png" alt="image-20220120085157551"></p><h2 id="2-6反射操作注解"><a href="#2-6反射操作注解" class="headerlink" title="2.6反射操作注解"></a>2.6反射操作注解</h2><p> <img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/20.png" alt="image-20220120090418721"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.day05.test03;<span class="hljs-keyword">import</span> java.lang.annotation.*;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-comment">//反射操作注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;        Class c1 = Class.forName(<span class="hljs-string">&quot;test.day05.test03.Student&quot;</span>);        <span class="hljs-comment">//反射获得注解</span>        Annotation[] annotations = c1.getAnnotations();        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;            System.out.println(annotation);        &#125;        <span class="hljs-comment">//获得注解value的值</span>        TableHeng annotation = (TableHeng) c1.getAnnotation(TableHeng.class);        String value = annotation.value();        System.out.println(value);        <span class="hljs-comment">//获得类指定的注解</span>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);        fieldHeng annotation1 = name.getAnnotation(fieldHeng.class);        System.out.println(annotation1.columnName());        System.out.println(annotation1.type());        System.out.println(annotation1.length());    &#125;&#125;<span class="hljs-meta">@TableHeng(&quot;db_student&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_name&quot;,type = &quot;int&quot;,length = 10)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span>    <span class="hljs-keyword">int</span> age;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_id&quot;,type = &quot;varchar&quot;,length = 3)</span>    <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&quot;, id=&quot;</span> + id +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;<span class="hljs-comment">//类名的注解</span><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> TableHeng &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//属性的注解</span><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> fieldHeng &#123;    <span class="hljs-function">String <span class="hljs-title">columnName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">打印：</span><span class="hljs-comment">@test.day05.test03.TableHeng(value=db_student)</span><span class="hljs-comment">db_student</span><span class="hljs-comment">db_name</span><span class="hljs-comment">int</span><span class="hljs-comment">10</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>注解和反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/2022/01/15/css/"/>
    <url>/2022/01/15/css/</url>
    
    <content type="html"><![CDATA[<p><strong>HTML(结构) + CSS(表现) + JavaScript(交互)</strong></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ol><li>css是什么</li><li>如何用(快速入门)</li><li><strong>css选择器 （重难点)</strong></li><li>美化网页( 文字，阴影，超链接，列表，渐变…..)</li><li>盒子模型</li><li>浮动</li><li>定位</li><li>网页动画(特效)</li></ol><h2 id="1-1什么是css"><a href="#1-1什么是css" class="headerlink" title="1.1什么是css"></a>1.1什么是css</h2><p>Cascading Style Sheet(层叠级联样式表)</p><p>css ==&gt; 表现(用于美化网页)</p><p>包括：字体，颜色，边距，高度，宽度，背景图片，网页定位，网页浮动…..</p><p><img src="/2022/01/15/css/00.png" alt="image-20220121194547522"></p><p><strong>CSS预处理器</strong></p><p><img src="/2022/01/15/css/000.png" alt="image-20220121194650495"></p><h2 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h2><p>CSS1.0  ==&gt; 只能美化一些基础的</p><p>CSS2.0 ==&gt; div(块) + css，提出html与css结构分离的思想，网页变得简单</p><p>CSS2.1===&gt;  浮动，定位</p><p>CSS3.0 ===&gt; 圆角，阴影，动画…..（需要浏览器兼容性</p><h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h2><p>书写标准格式==&gt;</p><p><img src="/2022/01/15/css/01.png" alt="image-20220115095910933"></p><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">--</span>    规范:&lt;<span class="hljs-selector-tag">style</span>&gt;编写<span class="hljs-selector-tag">css</span>代码，每一个声明，最好用分号结尾    语法：        选择器&#123;            声明1;            声明2;            声明3;        &#125;此时<span class="hljs-selector-tag">html</span>和<span class="hljs-selector-tag">css</span>未分离，在一个文件写的 <span class="hljs-selector-tag">css</span>在&lt;<span class="hljs-selector-tag">head</span>&gt;中，<span class="hljs-selector-tag">html</span>在<span class="hljs-selector-tag">body</span>中<span class="hljs-selector-tag">--</span>&gt;    &lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-tag">h1</span>&#123;            <span class="hljs-attribute">color</span>: aqua;        &#125;    &lt;/style&gt;</code></pre><p>建议分离着写，使用独立于html的css结构，即使用下面规范！</p><p><img src="/2022/01/15/css/02.png" alt="image-20220115101410535"></p><p><strong>优势:</strong></p><ol><li>内容和表现分离</li><li>网页结构统一，可以实现复用</li><li>样式很丰富 </li><li>利于SEO(<em>Search engine optimization</em>)，容易被搜索引擎收录</li></ol><h2 id="1-4三种导入方式"><a href="#1-4三种导入方式" class="headerlink" title="1.4三种导入方式"></a>1.4三种导入方式</h2><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;&lt;html lang=&quot;en&quot;&gt;&lt;<span class="hljs-selector-tag">head</span>&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;!<span class="hljs-selector-tag">--</span>    2内部样式<span class="hljs-selector-tag">--</span>&gt;    &lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-tag">h1</span>&#123;            <span class="hljs-attribute">color</span>: yellow;        &#125;    &lt;/style&gt;&lt;!<span class="hljs-selector-tag">--</span>   3，外部样式<span class="hljs-selector-tag">--</span>&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;<span class="hljs-selector-tag">body</span>&gt;&lt;!<span class="hljs-selector-tag">--</span> 1.行内样式<span class="hljs-selector-tag">--</span>&gt;    &lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时显示 行内样式的颜色 若去掉行内样式，则显示 外部样式 对应的颜色 ，因为离h1最近  </p><p><strong>就近原则</strong> 即从上到下，下面覆盖重复上面的样式</p><p>外部样式的两种方式：</p><ul><li><p>链接式(目前用这个最多)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/style.css&quot;</span>&gt;</span></code></pre></li><li><p>导入式(css2.1中使用)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;css/style.css&quot;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></li></ul><h1 id="2-选择器-重要"><a href="#2-选择器-重要" class="headerlink" title="2.选择器(重要)"></a>2.选择器(重要)</h1><blockquote><p>选择页面上的某一个或某一类元素</p></blockquote><h2 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a><strong>2.1 基本选择器</strong></h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>会选择到这个页面上的所有标签</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><pre><code>格式:.class的名称&#123;   &#125;好处：可以多个标签归类，是同一个class，可复用</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.name</span>&#123;</span>        color: red;    &#125;<span class="css">    <span class="hljs-selector-class">.id</span>&#123;</span>        color: yellow;    &#125;<span class="css">    <span class="hljs-selector-class">.phone</span>&#123;</span>        color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;phone&quot;</span>&gt;</span>phone<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><pre><code>格式： #id名称&#123;   &#125;必须全局唯一，不可以复用 不遵循就近原则  生效原则：id选择器 &gt; 类选择器 &gt; 标签选择器     </code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-id">#test</span>&#123;</span>        color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><h2 id="2-2高级选择器"><a href="#2-2高级选择器" class="headerlink" title="2.2高级选择器"></a>2.2高级选择器</h2><h3 id="1层次选择器"><a href="#1层次选择器" class="headerlink" title="1层次选择器"></a>1层次选择器</h3><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>（body  里面所有p都起作用)</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">color</span>: blue;&#125;</code></pre><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p>只会body里面一代起作用</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&gt;<span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">color</span>: blue;&#125;</code></pre><h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><p>(同辈) ===&gt; 向下的相邻</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.test</span> + <span class="hljs-selector-tag">p</span>&#123;</span>    color: blueviolet;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>此时p3会变颜色</p><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>当前选择元素的所有向下的兄弟元素 生效</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.test</span>~<span class="hljs-selector-tag">p</span>&#123;</span>        color: red;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>此时p2 p3均为变颜色</p><h3 id="2-结构伪类选择器"><a href="#2-结构伪类选择器" class="headerlink" title="2.结构伪类选择器"></a>2.结构伪类选择器</h3><p>带冒号这种==&gt; 即伪类 (代表条件判断 )</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-comment">/*定位ul中li的第一个与最后一个*/</span></span><span class="css">    <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first-child</span>&#123;</span>        color: red;    &#125;<span class="css">    <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;</span>        color: blueviolet;    &#125;    /*首先找到当前p元素的父级元素，然后选中父级元素的第一个，并且类型要是当前元素才生效 （按顺序进行选择    此时p1会变颜色    */<span class="css">    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child(1)</span> &#123;</span>        color: blue;    &#125;<span class="css">    <span class="hljs-comment">/*选中父元素下的p元素的第二个  此时p2变颜色 (按类型进行选择)  */</span> </span><span class="css">    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span> &#123;</span>        background-color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h3 id="3-属性选择器-常用"><a href="#3-属性选择器-常用" class="headerlink" title="3.属性选择器(常用)"></a>3.属性选择器(常用)</h3><p> 格式： 标签[id属性] {  }</p><pre><code class="hljs css"><span class="hljs-comment">/*选中 a标签 中id属性为 first的元素*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[id=first]</span> &#123;  &#125;<span class="hljs-comment">/*  选择a标签中class含有 links的元素 </span><span class="hljs-comment">=代表完全匹配 *=只需要含有即可 ^=以什么开头 $= 以什么结尾 (正则表达式)</span><span class="hljs-comment">*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[class *= <span class="hljs-string">&quot;links&quot;</span>]</span> &#123; &#125;</code></pre><h1 id="3-美化网页元素"><a href="#3-美化网页元素" class="headerlink" title="3 美化网页元素"></a>3 美化网页元素</h1><p><strong>为何需要美化</strong></p><pre><code>-     更有效传递网页信息-     页面好看，才能吸引用户-     凸显页面主题-     提高用户体验</code></pre><p>span==&gt; 想重点突出的字，约定用 span套起来，然后表示</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-id">#java</span>&#123;</span>        color: red;        font-size: 50px;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>欢迎学习 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;java&quot;</span>&gt;</span>JAVA<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p><strong>字体</strong></p><pre><code class="hljs css">font-family ==&gt; 字体样式font-size ==&gt;字体大小font-weight ==&gt; 粗细color ==&gt; 颜色一般统一写 font: 字体粗细 行/高 字体格式  或 font:字体风格 字体粗细 大小 字体格式如 font: bold 20px/50px Arial;  或 font: oblique bolder 50px Arial;</code></pre><p><strong>文本样式</strong></p><ol><li><p>颜色</p><p>color (rgb)</p></li><li><p><strong>文本对齐方式</strong></p><p><code>text-align</code> (排版方式: center，right，left 是水平的居中) </p></li><li><p><strong>首行缩进</strong></p><p><code>text-indent:2em;</code></p></li><li><p>行高</p><p><code>height:300px;</code></p><p><code>line-height:300px;</code>  &lt;== 行高</p><p>当 行高 与块高度相同时，则可实现上下居中</p></li><li><p>装饰</p><ul><li>下划线 <code>text-decoration:underline;</code></li><li>删除线：<code>text-decoration:line-throuth;</code></li></ul></li></ol><pre><code class="hljs css"><span class="hljs-comment">/*鼠标悬浮时的状态*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;    <span class="hljs-attribute">text-decoration</span>:none;    <span class="hljs-attribute">color</span>:<span class="hljs-number">#000</span>; &#125;</code></pre><p><strong>背景</strong></p><pre><code class="hljs css"><span class="hljs-comment">/* 颜色 图片 图片位置(在页面中) 平铺方 */</span>background: red url(&quot;../images/d.gif&quot;) 270px 10px no-repeat;</code></pre><p><strong><a href="https://www.grabient.com/">渐变</a></strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#4158D0</span>;<span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">linear-gradient</span>(83<span class="hljs-selector-tag">deg</span>, <span class="hljs-selector-id">#4158D0</span> 0%, <span class="hljs-selector-id">#C850C0</span> 46%, <span class="hljs-selector-id">#FFCC70</span> 100%);</code></pre><p><strong>列表</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">list-style</span>: </code></pre><h1 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h1><p><img src="/2022/01/15/css/03.png" alt="image-20220119182320273"></p><ul><li>margin : 外边距</li><li>border ： 内边距</li><li>padding ： 边框</li></ul><p><strong>边框</strong></p><pre><code class="hljs css"><span class="hljs-comment">/*常见的初始化操作*/</span><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">body</span>&#123;            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;            <span class="hljs-attribute">text-decoration</span>: none;        &#125;     <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">red</span>;     <span class="hljs-selector-tag">margin</span>: 0 <span class="hljs-selector-tag">auto</span>; <span class="hljs-comment">/*  margin外边距妙用==&gt; 居中 (上下0，左右auto)     条件：块元素，有固定宽度</span><span class="hljs-comment">若margin: 0 1px 2px 3px ==&gt; 逆时针(上 右 下 左)</span><span class="hljs-comment">*/</span><span class="hljs-comment">/* 下面方式也可实现居中(更有效)*/</span>&lt;div style = &quot;width: 500px;display: block; test-align:center&quot;&gt;    &lt;img src = &quot;images/tx.jpg&quot; alt= &quot;&quot; &gt;&lt;/div&gt;</code></pre><blockquote><p> 给出 50 * 50 ==&gt; 盒子模型尺寸计算指：margin + border + padding + 内容元素 = 50 * 50</p></blockquote><p><strong>圆角边框</strong></p><p>4个角</p><pre><code class="hljs css"><span class="hljs-selector-tag">border-radius</span>: 40<span class="hljs-selector-tag">px</span>;  <span class="hljs-comment">/*四个角均变*/</span><span class="hljs-selector-tag">border-radius</span><span class="hljs-selector-pseudo">:50px</span> 40<span class="hljs-selector-tag">px</span> 30<span class="hljs-selector-tag">px</span> 20<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/*(顺时针) 左上 右上 右下 左下*/</span><span class="hljs-selector-tag">border-radius</span>: 40<span class="hljs-selector-tag">px</span> 10<span class="hljs-selector-tag">px</span>;<span class="hljs-comment">/* 左上  右下 */</span></code></pre><p><strong>盒子阴影</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">width</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">height</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">border</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">red</span>;<span class="hljs-selector-tag">border-radius</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">box-shadow</span>: 10<span class="hljs-selector-tag">px</span> 10<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span> <span class="hljs-selector-id">#888888</span>;</code></pre><p><img src="/2022/01/15/css/04.png" alt="image-20220121115240716"></p><h1 id="5-浮动"><a href="#5-浮动" class="headerlink" title="5.浮动"></a>5.浮动</h1><p><strong>标准文档流</strong></p><p><img src="/2022/01/15/css/05.png" alt="image-20220121152153377"></p><p>块级元素：独占一行</p><pre><code class="hljs apache"><span class="hljs-attribute">h1</span>~h<span class="hljs-number">6</span>, p标签 div标签 列表</code></pre><p>行内元素：不独占一行</p><pre><code class="hljs stylus"><span class="hljs-selector-tag">span</span>  a标签 <span class="hljs-selector-tag">img</span> <span class="hljs-selector-tag">strong</span>....</code></pre><p><strong>display</strong> 也是实现行内元素排列的方式，但多用float  ===&gt; <strong>方向不可以控制，不会出现父级边框塌陷问题</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">block</span> 块元素<span class="hljs-selector-tag">inline</span> 行内元素<span class="hljs-selector-tag">inline-block</span> 是块元素，但是可以内联，在一行none ==&gt; 消失 </code></pre><p><strong>float浮动</strong>()  ===&gt;  <strong>浮动的话可能会脱离标准文档流，所以要解决父级边框塌陷</strong></p><p>right,left <strong>左右浮动</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:both</span>; <span class="hljs-comment">/*两侧均不许有浮动元素，即按照正常元素向下排布*/</span><span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:right</span>;<span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:none</span>; <span class="hljs-comment">/*不清理*/</span></code></pre><p>浮动会出现<strong>父级边框塌陷问题</strong></p><p><strong>如何解决？</strong></p><p>1.将父级元素(div)边框高度变大</p><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;    <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>;&#125;</code></pre><p>2.再上面div后加一个空的div，然后清除它的浮动 <strong>（尽量避免空div，不用此方法）</strong></p><pre><code class="hljs css">&lt;div class = &quot;clear&quot;&gt;&lt;/div&gt;<span class="hljs-selector-class">.clear</span>&#123;    <span class="hljs-attribute">clear</span>:both;    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;&#125;</code></pre><p>3.利用overflow</p><pre><code class="hljs css"><span class="hljs-comment">/*设置父级元素overflow  根据里面内容而进行变化*/</span><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;    <span class="hljs-attribute">overflow</span>:hidden; <span class="hljs-comment">/*网页若下拉的场景不能使用*/</span>&#125;</code></pre><p>4.在父类中添加一个伪类**(推荐使用)**</p><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;&#125;<span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">conten</span>:<span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">clear</span>:both;&#125;</code></pre><h1 id="6-定位"><a href="#6-定位" class="headerlink" title="6.定位"></a>6.定位</h1><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>相对于原来的位置进行指定偏移，位置仍然在标准文档流中，原来位置被保留</p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span><span class="hljs-selector-pseudo">:relative</span>;  <span class="hljs-comment">/* 然后设置 距离 上下左右多少*/</span><span class="hljs-selector-tag">top</span>:<span class="hljs-selector-tag">bottom</span>:<span class="hljs-selector-tag">left</span>:<span class="hljs-selector-tag">right</span>:</code></pre><p><img src="/2022/01/15/css/06.png" alt="image-20220121160558405"></p><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-id">#box</span>&#123;            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;        &#125;        <span class="hljs-selector-tag">a</span>&#123;            <span class="hljs-attribute">text-decoration</span>: none;            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">background-color</span>: pink;            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">text-align</span>: center;            <span class="hljs-attribute">color</span>: white;            <span class="hljs-attribute">display</span>: block;        &#125;        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;            <span class="hljs-attribute">background-color</span>: cornflowerblue;        &#125;        <span class="hljs-selector-class">.a2</span>,<span class="hljs-selector-class">.a4</span>&#123;            <span class="hljs-attribute">position</span>: relative;            <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;            <span class="hljs-attribute">top</span>: -<span class="hljs-number">100px</span>;        &#125;        <span class="hljs-selector-class">.a5</span>&#123;            <span class="hljs-attribute">position</span>: relative;            <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">bottom</span>: <span class="hljs-number">300px</span>;        &#125;&lt;/style&gt;&lt;div id = &quot;box&quot;&gt;    &lt;a href=&quot;#&quot; class=&quot;a1&quot;&gt;链接1&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a2&quot;&gt;链接2&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a3&quot;&gt;链接3&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a4&quot;&gt;链接4&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a5&quot;&gt;链接5&lt;/a&gt;&lt;/div&gt;</code></pre><h2 id="绝对定位和固定定位"><a href="#绝对定位和固定定位" class="headerlink" title="绝对定位和固定定位"></a>绝对定位和固定定位</h2><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">fixed</span>;</code></pre><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;    <span class="hljs-selector-tag">body</span>&#123;        <span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>; <span class="hljs-comment">/*会出现滚动条  当滚动时，固定定位一直不变，而绝对定位只是对于浏览器右边不变，上下会变*/</span>    &#125;    <span class="hljs-comment">/*绝对定位，相对于浏览器*/</span>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(1)</span> &#123;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: red;    &#125;    <span class="hljs-comment">/*固定定位*/</span>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span> &#123;        <span class="hljs-attribute">position</span>: fixed;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;        <span class="hljs-attribute">background</span>: blue;    &#125;&lt;/style&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">z-index</span>: 999; <span class="hljs-comment">/*0,1,2,3,....越大层级越高  作用类比于ps中的 图层*/</span><span class="hljs-selector-tag">opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/* 可以设置背景透明度 */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27.移除元素</title>
    <link href="/2022/01/12/leetcode07/"/>
    <url>/2022/01/12/leetcode07/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs java">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(<span class="hljs-number">1</span>) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:<span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><span class="hljs-keyword">int</span> len = removeElement(nums, val);<span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    print(nums[i]);&#125; 示例 <span class="hljs-number">1</span>：输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], val = <span class="hljs-number">3</span>输出：<span class="hljs-number">2</span>, nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]解释：函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="hljs-number">2</span> ，而 nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 或 nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]，也会被视作正确答案。示例 <span class="hljs-number">2</span>：输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>], val = <span class="hljs-number">2</span>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：<span class="hljs-number">0</span> &lt;= nums.length &lt;= <span class="hljs-number">100</span><span class="hljs-number">0</span> &lt;= nums[i] &lt;= <span class="hljs-number">50</span><span class="hljs-number">0</span> &lt;= val &lt;= <span class="hljs-number">100</span></code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力算法===&gt; 找到相同的进行覆盖，然后长度缩短</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length ; i++) &#123;            <span class="hljs-comment">//找到相同元素</span>            <span class="hljs-keyword">if</span> ( nums[i] == val ) &#123;                <span class="hljs-comment">//进行移动数组</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;                    nums[j - <span class="hljs-number">1</span>] = nums[j];                &#125;                length --;                i --;  <span class="hljs-comment">//因为数组下标i之后元素都前移了，故i也要前移一位</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> length;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.8 MB, 在所有 Java 提交中击败了77.63%的用户</p><p>通过测试用例：113 / 113</p></blockquote><p><strong>时间复杂度为 0(n^2)</strong></p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>双指针 （重点掌握！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;            <span class="hljs-keyword">if</span>( val != nums[fast] ) &#123;                nums[slow ++] = nums[fast];            &#125;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.2 MB, 在所有 Java 提交中击败了5.72%的用户</p><p>通过测试用例：113 / 113</p></blockquote><p><strong>时间复杂度为 O(n)</strong></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>977.有序数组的平方</title>
    <link href="/2022/01/11/leetcode06/"/>
    <url>/2022/01/11/leetcode06/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1：输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]示例 2：输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示：1 &lt;= nums.length &lt;= 10^4-10^4 &lt;= nums[i] &lt;= 10^4nums 已按 非递减顺序 排序 进阶：请你设计时间复杂度为 O(n) 的算法解决本问题</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>第一思路===&gt; 对每个元素进行平方，然后排序即可 （暴力排序！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length; i++) &#123;            nums[i] *= nums[i];        &#125;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：2 ms, 在所有 Java 提交中击败了39.61%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了96.37%的用户</p><p>通过测试用例：137 / 137</p></blockquote><p>java中Arrays.sort使用了两种排序方法，quick sort 和优化的 merge sort</p><p>故Java内置排序时间复杂度为o(nlogn)  ===&gt;  整体即是  o(nlogn  + n) </p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p><strong>双指针</strong></p><blockquote><p>数组是有序的，负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>考虑双指针法，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;         <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length; - <span class="hljs-number">1</span>,n = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]; <span class="hljs-comment">//大小不对！不然会越界，应该是new int[nums.length];</span>        <span class="hljs-keyword">while</span> (i &lt;= j ) &#123;            <span class="hljs-keyword">if</span> ( nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;                result[n--] = nums[i] * nums[i];                i++;             &#125;            <span class="hljs-keyword">else</span> &#123;                result[n--] = nums[j] * nums[j];                j --;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;       &#125;&#125;</code></pre><p>更改：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;         <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length]; <span class="hljs-comment">//要保证长度够</span>        <span class="hljs-keyword">while</span> (i &lt;= j ) &#123;            <span class="hljs-keyword">if</span> ( nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;                result[n--] = nums[i] * nums[i];                i++;             &#125;            <span class="hljs-keyword">else</span> &#123;                result[n--] = nums[j] * nums[j];                j--;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;       &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.3 MB, 在所有 Java 提交中击败了39.21%的用户</p><p>通过测试用例：137 / 137</p></blockquote><p>此时复杂度为 0(n) 比暴力更快！</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35.搜索插入位置</title>
    <link href="/2022/01/11/leetcode05/"/>
    <url>/2022/01/11/leetcode05/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs java">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。 示例 <span class="hljs-number">1</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span>输出: <span class="hljs-number">2</span>示例 <span class="hljs-number">2</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span>输出: <span class="hljs-number">1</span>示例 <span class="hljs-number">3</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span>输出: <span class="hljs-number">4</span>示例 <span class="hljs-number">4</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">0</span>输出: <span class="hljs-number">0</span>示例 <span class="hljs-number">5</span>:输入: nums = [<span class="hljs-number">1</span>], target = <span class="hljs-number">0</span>输出: <span class="hljs-number">0</span> 提示:<span class="hljs-number">1</span> &lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span>-<span class="hljs-number">104</span> &lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span>nums 为无重复元素的升序排列数组-<span class="hljs-number">104</span> &lt;= target &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span></code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果目标值在===&gt;  二分查找搞定，复杂度满足</p><p>如果不在，怎么找到对应位置？ ===&gt; 最终i &gt; j ,故直接返回 j + 1即是所找的位置 （可通过示例分析出来！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> ( i &lt;= j) &#123;            <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>   <span class="hljs-comment">//取mid更安全！</span>            <span class="hljs-keyword">if</span>( target &lt; nums[mid]) &#123;                j = mid - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[mid]) &#123;                i = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38 MB, 在所有 Java 提交中击败了61.66%的用户</p><p>通过测试用例：64 / 64</p></blockquote><p>抛开别的，另一种思路</p><p><strong>直接遍历一趟进行寻找，如果找到值大于 target 则返回相对应的下标，否则返回数组长度</strong> （更简便！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> ( target &lt; nums[i] )&#123;                <span class="hljs-keyword">return</span> i;            &#125;              &#125;        <span class="hljs-keyword">return</span> nums.length;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了92.45%的用户</p><p>通过测试用例：64 / 64</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>278.第一个错误版本</title>
    <link href="/2022/01/11/leetcode04/"/>
    <url>/2022/01/11/leetcode04/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。示例 1：输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。示例 2：输入：n = 1, bad = 1输出：1提示：1 &lt;= bad &lt;= n &lt;= 2^31 - 1</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分查找！</p><pre><code class="hljs java"><span class="hljs-comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><span class="hljs-comment">      boolean isBadVersion(int version); */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VersionControl</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,j = n;        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;            <span class="hljs-keyword">int</span> mid = (i + j ) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( isBadVersion(mid) ) &#123;                j = mid - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                i = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre><blockquote><p> 以上代码，超出时间限制！</p></blockquote><p>原因为何 ？ ===&gt; 只有while 循环中<strong>mid 取值不对</strong>，导致溢出</p><p>题目中还一条件：即bad 和 n范围 </p><p>因为是int 如果取值过大，比如刚好取值2^31 -1 即int的最大值，其实mid进行运算将溢出</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> mid = left + (right - left ) / <span class="hljs-number">2</span> <span class="hljs-comment">//取中间值的另一种方法,不会溢出===&gt; 要get√ </span></code></pre><p>改了之后进行提交，结果如图</p><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：11 ms, 在所有 Java 提交中击败了99.95%的用户</p><p>内存消耗：34.8 MB, 在所有 Java 提交中击败了94.21%的用户</p><p>通过测试用例：22 / 22</p></blockquote><p>总：</p><p>二分查找取中值的方法：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">//可能会溢出</span><span class="hljs-keyword">int</span> mid = (left + right - left) / <span class="hljs-number">2</span>  <span class="hljs-comment">// 不会溢出，重点掌握</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子数组和</title>
    <link href="/2022/01/09/leetcode03/"/>
    <url>/2022/01/09/leetcode03/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1:输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4示例 2:输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1//思路不难</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>直接暴力寻找</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>( nums[i] == target) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>二分法</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;       Arrays.sort(nums); <span class="hljs-comment">//不用写，题目说有序了</span>       <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (i &lt;= j) &#123;           <span class="hljs-keyword">int</span> mid = (i + j) / <span class="hljs-number">2</span>;           <span class="hljs-keyword">if</span>( target &lt; nums[mid] ) &#123;               j = mid - <span class="hljs-number">1</span>;           &#125;           <span class="hljs-keyword">if</span>( target &gt; nums[mid]) &#123;               i = mid + <span class="hljs-number">1</span>;           &#125;           <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;               <span class="hljs-keyword">return</span> mid;           &#125;       &#125;       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>217.存在重复元素</title>
    <link href="/2022/01/09/leetcode02/"/>
    <url>/2022/01/09/leetcode02/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">leetcode 217题 </a>–存在重复元素</p><pre><code class="hljs shell">给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1:输入: [1,2,3,1]输出: true示例 2:输入: [1,2,3,4]输出: false示例 3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最容易想到的，暴力算法</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numsSize;i++) &#123;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; numsSize;j++) &#123;            <span class="hljs-keyword">if</span> ( *(nums + i) == *(nums + j) ) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//时间复杂度太高！无法通过测试</span></code></pre><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>排序 + 比较</p><blockquote><p>先进行排序，然后再进行循环一趟，看是否相邻的元素相等，若等则返回true，否则返回false</p><p>而排序可利用java中的内置方法 或者  C语言中的qsort 或者自己手写快排！</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums); <span class="hljs-comment">//java内置排序方法</span>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;i++) &#123;            <span class="hljs-keyword">if</span>( nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *b)</span> </span>&#123;    <span class="hljs-keyword">return</span> ( *(<span class="hljs-keyword">int</span>*)a - *(<span class="hljs-keyword">int</span>*)b );&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;    qsort(nums,numsSize,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>),compare); <span class="hljs-comment">//qsort</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span>;i++) &#123;        <span class="hljs-keyword">if</span>( *(nums+i) == *(nums+i+<span class="hljs-number">1</span>) ) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><blockquote><h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><p><em>语法:</em> </p><p>  <strong>#include  &lt;stdlib.h&gt;</strong> <strong>void qsort( void *buf, size_t num, size_t  size, int (*compare)(const void *, const void *)  );</strong></p><p><strong>功能：</strong>  对<em>buf</em>  指向的数据(包含<em>num</em>  项,每项的大小为<em>size</em>)进行快速排序。如果函数<em>compare</em>  的第一个参数小于第二个参数，返回负值；如果等于返回零值；如果大于返回正值。函数对<em>buf</em>  指向的数据按升序排序。 </p></blockquote><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>哈希表</p><blockquote><p>将数组中的元素，插入到哈希表中，如果插入时发现该元素已经存在哈希表中，则说明存在重复元素</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;         Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;            <span class="hljs-keyword">if</span> ( !set.add(x) ) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><blockquote><p>java中集合Set用法</p><p>Set`用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象(初级)</title>
    <link href="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/"/>
    <url>/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象-初级"><a href="#面向对象-初级" class="headerlink" title="面向对象(初级)"></a>面向对象(初级)</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/01.png" alt="image-20211231104708275"></p><blockquote><p>(1)类是抽象的,概念的,代表一类食物,比如人类,猫类.他是数据类型</p><p>(2)对象是具体的,实际的,代表一个具体事物,即是实例</p><p>(3)类是对象的模板,对象是类的一个个体,对应一个实例</p></blockquote><p><strong>java内存结构</strong></p><blockquote><p>栈：存放基本数据类型（局部变量</p><p>堆：存放对象（Cat cat，数组）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><p><strong>方法的调用过程</strong></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/02.png" alt="image-20211231105242496"></p><p><strong>可变参数</strong></p><blockquote><p>java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现</p><p>基本语法：</p><p>访问修饰符  返回类型 方法名(数据类型… 形参名) {   }</p></blockquote><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/03.png" alt="image-20211231105638546"></p><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h2><p>又称为构造器，是类的一种特殊方法，完成对新对象的初始化</p><blockquote><p>特点：</p><p>​    1.方法名和类名相同</p><p>​    2.没有返回值</p><p>​    3.在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</p><p>基本语法：</p><p>[修饰符] 方法名(形参列表) { 方法体; }</p></blockquote><p>1.构造器的修饰符可以默认， 也可以是 public protected private</p><ol start="2"><li>构造器没有返回值<ol start="3"><li>方法名 和类名字必须一样<ol start="4"><li>参数列表 和 成员方法一样的规则<ol start="5"><li>构造器的调用, 由系统完成  </li></ol></li></ol></li></ol></li></ol><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/04.png" alt="image-20211231120033568"></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/05.png" alt="image-20211231120052604"></p><p><strong>this关键字</strong></p><blockquote><p>java虚拟机会给每个对象分配this，代表当前对象</p><p>简单来说：哪个对象调用，this就代表哪个对象</p></blockquote><p><strong>使用细节：</strong></p><p>1、this 关键字可以用来访问本类的属性、 方法、 构造器  </p><p>2、this 用于区分当前类的属性和局部变量</p><p>3、访问成员方法的语法： this.方法名(参数列表); </p><p>4、访问构造器语法： this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一<br>条语句)  </p><p>5、this 不能在类定义的外部使用， 只能在类定义的方法中使用。  </p><h3 id="2-1-IDEA简单使用"><a href="#2-1-IDEA简单使用" class="headerlink" title="2.1.IDEA简单使用"></a>2.1.IDEA简单使用</h3><p>常用快捷键设置</p><p>file–&gt;setting–&gt;keymap进行设置</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/06.png" alt="image-20211231143309908"></p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>) 删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d<span class="hljs-number">2</span>) 复制当前行, 自己配置 ctrl + alt + 向下光标<span class="hljs-number">3</span>) 补全代码 alt + /<span class="hljs-number">4</span>) 添加注释和取消注释 ctrl + / 【第一次是添加注释， 第二次是取消注释】<span class="hljs-number">5</span>) 导入该行需要的类 先配置 <span class="hljs-built_in">auto</span> <span class="hljs-keyword">import</span> , 然后使用 alt+enter 即可<span class="hljs-number">6</span>) 快速格式化代码 ctrl + alt + L<span class="hljs-number">7</span>) 快速运行程序 自己定义 alt + R<span class="hljs-number">8</span>) 生成构造器等 alt + insert [提高开发效率]<span class="hljs-number">9</span>) 查看一个类的层级关系 ctrl + H [学习继承后， 非常有用]<span class="hljs-number">10</span>) 将光标放在一个方法上， 输入 ctrl + B , 可以定位到方法 [学继承后， 非常有用]<span class="hljs-number">11</span>) 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] </code></pre><h3 id="2-2包-package"><a href="#2-2包-package" class="headerlink" title="2.2包(package"></a>2.2包(package</h3><blockquote><p>作用：1.区分相同名字的类；2当类很多时，可以很好的管理类(看java API文档) 3.控制访问范围</p><p>包本质：就是创建不同的文件夹/目录保存类文件</p><p>命名规则：只能包含数字，字母，下划线，小圆点，但不可以数字开头，不能是关键字</p></blockquote><p>规范：<strong>com.公司名.项目名.业务模块名</strong></p><p>例如：com.sina.crm.user 用户模块</p><p>如何引入包 ===&gt; import 包名;</p><h3 id="2-3-访问修饰符"><a href="#2-3-访问修饰符" class="headerlink" title="2.3 访问修饰符"></a>2.3 访问修饰符</h3><p>用于控制方法和属性(成员变量)的访问权限(范围)</p><ol><li>公开级别 <strong>public</strong> ，对外公开</li><li>受保护级别：<strong>protected</strong>，对子类和同一个包中的类公开</li><li>默认，没有修饰符，对同一个包的类公开</li><li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li></ol><p><strong>访问范围</strong></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/07.png" alt="image-20220109101437681"></p><h3 id="2-4-方法的重载"><a href="#2-4-方法的重载" class="headerlink" title="2.4 方法的重载"></a>2.4 方法的重载</h3><blockquote><p>一个类中可以包含多个同名的方法，但只是需要的形式参数不同</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 原本的方法</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">//ok 形参不同</span>        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-comment">//ok 返回值和形参均不同</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span> </span>&#123;    &#125;    <span class="hljs-comment">// 错误，仅返回值类型不同不能重载</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><h2 id="3-静态变量和静态方法"><a href="#3-静态变量和静态方法" class="headerlink" title="3.静态变量和静态方法"></a>3.静态变量和静态方法</h2><blockquote><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p></blockquote><ul><li>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span>    Student()&#123;        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">//打印：</span>初始化变量a构造类对象</code></pre><h2 id="3-封装-encaplation"><a href="#3-封装-encaplation" class="headerlink" title="3.封装(encaplation)"></a>3.封装(encaplation)</h2><p>封装就是把抽象出的**数据(属性)和对数据的操作(方法)**封装在一起，数据被 保护在内部，程序的其他部分只有通过被授权的操作(方法)，才能对数据进行操作</p><blockquote><p>封装的好处：1.隐藏实现细节 2.可以对数据进行验证，保证安全合理</p><p>封装的实现步骤：</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/08.png"></p></blockquote><h2 id="4-继承-extends"><a href="#4-继承-extends" class="headerlink" title="4.继承(extends)"></a>4.继承(extends)</h2><p>​        继承解决代码复用，当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/09.png" alt="image-20211231185044322"></p><pre><code class="hljs angelscript">语法：<span class="hljs-keyword">class</span> 子类 <span class="hljs-symbol">extends</span> 父类 &#123;    &#125;<span class="hljs-number">1.</span>子类就会自动拥有父类定义的属性和方法<span class="hljs-number">2.</span>父类又叫 超类，基类<span class="hljs-number">3.</span>子类又叫派生类继承的好处：代码复用性提高了 &amp; 拓展性和维护性提高了继承的细节：<span class="hljs-number">1.</span>子类继承了所有的属性和方法，非私有的属性和方法在子类可以直接访问，但私有属性和方法不能在子类直接访问，要通过父类提供公共的方法来访问<span class="hljs-number">2.</span>子类必须调用父类的构造器，完成父类的初始化<span class="hljs-number">3.</span>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用<span class="hljs-keyword">super</span>去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不通过<span class="hljs-number">4.</span>如果希望指定去调用父类的某个构造器，则显式的调用一下：<span class="hljs-keyword">super</span>(参数列表)<span class="hljs-number">5.</span><span class="hljs-keyword">super</span>在使用时，必须放在构造器第一行(<span class="hljs-keyword">super</span>只能在构造器中使用)<span class="hljs-number">6.</span><span class="hljs-keyword">super</span>()和<span class="hljs-keyword">this</span>() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器<span class="hljs-number">7.</span>java所有类都是Object类的子类，Object是所有类的基类<span class="hljs-number">8.</span>父类构造器的调用不限于直接父类，将一直往上追溯到Object类<span class="hljs-number">9.</span>子类最多只能继承一个父类(直接继承)，即java中式单继承机制问：如何让A类继承B类和C类？ ===&gt; 接口！<span class="hljs-number">10.</span>不能滥用继承，子类和父类直接必须满足 <span class="hljs-keyword">is</span> 的逻辑关系</code></pre><h2 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h2><blockquote><p>同一个行为具有多个不同表现形式或形态的能力。即同样的方法，因实现类的不同，执行结果也不同</p></blockquote><h3 id="5-1方法的重写"><a href="#5-1方法的重写" class="headerlink" title="5.1方法的重写"></a>5.1方法的重写</h3><blockquote><p>注意区分和重载的区别==&gt;</p><p>重载：原有方法的逻辑不变，可以支持更多的参数实现</p><p>重写：直接覆盖原有的方法</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//父类中 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;studying....&quot;</span>);&#125;<span class="hljs-comment">//子类中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;给你一些好康的！&quot;</span>);&#125;</code></pre><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);     student.study();   <span class="hljs-comment">//输出子类定义的内容</span>&#125;     </code></pre><blockquote><p>ps:静态方法不可以被重写，是属于类的一部分</p></blockquote><p>如果在重写时，要使用自己的逻辑，也想执行父类的逻辑，怎么办===&gt; super</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>.study();    System.out.println(<span class="hljs-string">&quot;给你看点好康的！&quot;</span>);&#125;</code></pre><p>如果要访问父类的成员变量，也可以使用super关键字来访问。同时，子类也可以具有和父类相同的成员变量，而在方法中访问的默认是： <strong>形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span> </span>&#123;    test = <span class="hljs-number">1</span>;    <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;    <span class="hljs-keyword">super</span>.tesr = <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="5-2类型转换"><a href="#5-2类型转换" class="headerlink" title="5.2类型转换"></a>5.2类型转换</h3><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;yh&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span>student.study();     <span class="hljs-comment">//得到依然是具体实现的结果，而不是当前类型的结果</span></code></pre><p>也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： (向下转型)</p><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;yh&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><span class="hljs-comment">//...</span>SportsStudent student1 = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span>student1.sport();  <span class="hljs-comment">//调用具体实现类的方法</span></code></pre><h3 id="5-3-instanceof关键字"><a href="#5-3-instanceof关键字" class="headerlink" title="5.3 instanceof关键字"></a>5.3 instanceof关键字</h3><p>如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？ ==&gt; instanceof 进行类型判断</p><p>可以明确类的具体实现到底是哪个类！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;        SportsStudent sportsStudent = (SportsStudent) student;        sportsStudent.sport();    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> ArtStudent)&#123;        ArtStudent artStudent = (ArtStudent) student;        artStudent.art();    &#125;&#125;</code></pre><pre><code class="hljs java">System.out.println(student <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">//打印true，因为student对应的类继承Student类</span></code></pre><h3 id="5-4-final关键字"><a href="#5-4-final关键字" class="headerlink" title="5.4 final关键字"></a>5.4 final关键字</h3><p>final关键字可以使一个变量的值不可更改，如果放在类前面呢？</p><pre><code class="hljs java"><span class="hljs-comment">// 此时类被声明为终态，无法再被继承，不允许子类的存在</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123; &#125;<span class="hljs-comment">//同样的 方法 定义为终态，也不能进行重写</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;学习！&quot;</span>);&#125;<span class="hljs-comment">//如何类的成员属性被声明为final，则必须在构造方法中或是在定义时赋初始值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name; <span class="hljs-comment">//引用类型不允许再指向其他对象</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//基本类型值不允许发生改变</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;</code></pre><blockquote><p>故当一个成员属性不发生改变时，应该添加上final关键字</p></blockquote><h3 id="5-5抽象类"><a href="#5-5抽象类" class="headerlink" title="5.5抽象类"></a>5.5抽象类</h3><p>抽象类是在类的基础上继续抽象，<strong>只保留特征，而不保留具体呈现形式</strong>。即方法可以定义好，但不去实现它，而是由子类进行实现！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123; <span class="hljs-comment">//抽象类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>&#125;<span class="hljs-comment">//抽象方法不需要编写具体实现（无方法体）但是 必须 由子类实现（除非子类也是一个抽象类）</span><span class="hljs-comment">//抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</span><span class="hljs-comment">//只能创建带实现的匿名内部类</span>Student s = <span class="hljs-keyword">new</span> Student() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>故抽象类一般作继承使用，使得继承关系之间更加明确</p><pre><code class="hljs java"><span class="hljs-comment">////现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;给你一些好康的！&quot;</span>)&#125;</code></pre><h3 id="5-6-接口-interface"><a href="#5-6-接口-interface" class="headerlink" title="5.6 接口(interface)"></a>5.6 接口(interface)</h3><p>接口进一步继续抽象，<strong>只代表某个确切的功能，也就是只包含方法的定义</strong>，其实已经不是一个类了！</p><p>接口包含了一些类方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口只包含public权限的抽象方法(java8之后有默认实现)</span><span class="hljs-comment">//可以通过声明default关键字来给抽象方法一个默认实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//do..</span>    &#125;&#125;<span class="hljs-comment">//接口中的变量，默认为public static final</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>一个类可以实现很多个接口，但是不能理解为多继承！</p><p>（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>,... </span>&#123;    <span class="hljs-meta">@override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;<span class="hljs-comment">//类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！</span><span class="hljs-comment">//实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</span></code></pre><h2 id="6-内部类"><a href="#6-内部类" class="headerlink" title="6.内部类"></a>6.内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment">//类中定义的一个内部类</span>    &#125;&#125;<span class="hljs-comment">//就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例</span></code></pre><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test test = <span class="hljs-keyword">new</span> Test();    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//写法有那么一丝怪异，但是没毛病！</span>&#125;</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//不用再创建外部类对象了！</span>&#125;</code></pre><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>和局部变量一样 ( 很少用 )</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;        &#125;        Inner inner = <span class="hljs-keyword">new</span> Inner();    &#125;&#125;</code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>其实就是在new的时候，直接对接口或者抽象类的实现，是实现Lambda表达式的原理。</p><pre><code class="hljs java">Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-comment">// 实现必要的抽象方法...</span>&#125;;<span class="hljs-comment">//例如：</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//DO something...</span>        &#125;    &#125;;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/2022/01/09/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/09/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p><strong>基本学习思路</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/01.png" alt="image-20211231100822172"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/02.png" alt="image-20211231100928592"></p><p><strong>java组织形式</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/03.png" alt="image-20211231101114237"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/04.png" alt="image-20211231101701040"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/05.png" alt="image-20211231101937844"></p><p><strong>关系运算符</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/06.png" alt="image-20211231102009783"></p><p>逻辑运算符</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/07.png" alt="image-20211231102034884"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/08.png" alt="image-20211231102303168"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/09.png" alt="image-20211231102318799"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/10.png" alt="image-20211231102436229"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>If,switch,</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/11.png" alt="image-20211231102454676"></p><p><strong>双分支</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/12.png" alt="image-20211231102516316"></p><p><strong>多分支</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/13.png" alt="image-20211231102538524"></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="单层"><a href="#单层" class="headerlink" title="单层"></a>单层</h4><p>for(),while(),do..while()</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/14.png" alt="image-20211231103415980"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/15.png" alt="image-20211231103533253"></p><h4 id="多层循环"><a href="#多层循环" class="headerlink" title="多层循环"></a>多层循环</h4><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/17.png" alt="image-20211231103659318"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>动态初始化</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/18.png" alt="image-20211231103749009"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/19.png" alt="image-20211231103816308"></p><p>静态初始化</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/20.png" alt="image-20211231103826667"></p><p><strong>二维数组</strong></p><pre><code class="hljs markdown">int [<span class="hljs-string"></span>][<span class="hljs-symbol"></span>] y 或者 int[<span class="hljs-string"></span>]y[<span class="hljs-string"></span>] 或者 int y[][];例如:int map[][] = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;;//含有两个元素的一维数组,map[0]含有两个元素,map[1]含有三个元素</code></pre><blockquote><p>二维数组实际上是由多个一维数组组成的， 它的各个一维数组的长度可以相同， 也可以不相同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker命令</title>
    <link href="/2022/01/04/docker%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/04/docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre><code class="hljs shell">docker version #显示docker版本信息docker info #显示docker的系统信息，包括镜像和容器docker 命令 --help # 帮助命令</code></pre><p><a href="https://docs.docker.com/reference/">docker命令文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><pre><code class="hljs shell">docker images # 查看所有本机的主机上的镜像[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY:镜像的仓库源TAG ： 镜像标签IMAGE ID  ： 镜像idCREATED ： 创建时间SIZE ： 镜像大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images)  -q, --quiet           Only show image IDs</code></pre><p><strong>搜索镜像</strong></p><pre><code class="hljs shell">docker search xxxUsage:  docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions:  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print search using a Go template      --limit int       Max number of search results (default 25)      --no-trunc        Don&#x27;t truncate output<span class="hljs-meta">#</span><span class="bash">例如：找出mysql中stars大于3000的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker search mysql --filter=STARS=3000NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql     MySQL is a widely used, open-source relation…   11931     [OK]mariadb   MariaDB Server is a high performing open sou…   4561      [OK]</code></pre><p><strong>下载镜像</strong></p><pre><code class="hljs shell">docker pull xxx[:tag]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output<span class="hljs-meta">#</span><span class="bash">下载mysql</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql72a69066d2fe: Pull complete #分成下载，docker images的核心==&gt;联合文件系统93619dbc5b36: Pull complete99da31dd6142: Pull complete626033c43d70: Pull complete37d5d7efb64e: Pull completeac563158d721: Pull completed2ba16033dad: Pull complete688ba7d5c01a: Pull complete00e060b6d11d: Pull complete1c04857f594f: Pull complete4d7cfa90e6ea: Pull completee0431212d27d: Pull completeDigest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址<span class="hljs-meta">#</span><span class="bash">指定版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Already exists #此时不用再重新下载，已经存在相同部分93619dbc5b36: Already exists99da31dd6142: Already exists626033c43d70: Already exists37d5d7efb64e: Already existsac563158d721: Already existsd2ba16033dad: Already exists0ceb82207cd7: Pull complete37f2405cae96: Pull completee2482e017e53: Pull complete70deed891d42: Pull completeDigest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash">查看</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEmysql         5.7       c20987f18b13   2 weeks ago    448MBmysql         latest    3218b38490ce   2 weeks ago    516MBhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>删除镜像</strong></p><pre><code class="hljs shell">docker rmi xxxRemove one or more imagesOptions:  -f, --force      Force removal of the image      --no-prune   Do not delete untagged parentsdocker rmi -f 容器id #删除指定的容器docker rmi -f $(docker images -aq) #删除所有的容器</code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>有了镜像才能创建容器，必须先下载镜像，以centos为例 </p></blockquote><pre><code class="hljs shell">docker pull centos</code></pre><p><strong>新建容器并启动</strong></p><pre><code class="hljs shell">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new container<span class="hljs-meta">#</span><span class="bash">参数 </span>--name=&quot;Name&quot;  #容器名字-d #后台运行-it #使用交互方式运行-p  #指定容器端口    -p ip 主机端口:容器端口    -p 主机端口:容器端口(常用)    -p 容器端口    容器端口-P  #随机指定端口<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#测试===&gt; 启动并进入容器</span></span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker run -it centos /bin/bash  [root@bea475e51bda /]# <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看容器内的centos</span></span>[root@bea475e51bda /]#  lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#从容器中退到主机</span></span>[root@bea475e51bda /]# exitexit[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsinstall.sh[root@iZ2ze9nu608mhi5at5aufaZ ~]# cd ..[root@iZ2ze9nu608mhi5at5aufaZ /]# lsbin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  patch  proc  root  run  sbin  srv  sys  tmp  usr  var  www</code></pre><p><strong>列出所有的容器</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker ps 命令</span>       #列出当前正在运行的容器    -a #列出当前正在运行的容器+带出历史运行过的容器    -n=？ #显示最近创建的容器    -q    #只显示容器的编号[root@iZ2ze9nu608mhi5at5aufaZ /]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@iZ2ze9nu608mhi5at5aufaZ /]# docker ps -aCONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMESbea475e51bda   centos        &quot;/bin/bash&quot;   4 minutes ago   Exited (127) 2 minutes ago             keen_rhodes537a7100443f   hello-world   &quot;/hello&quot;      5 days ago      Exited (0) 5 days ago                  jovial_thompson</code></pre><p> <strong>退出容器</strong></p><pre><code class="hljs shell">exit  #直接容器停止并退出ctrl + P + Q # 容器不停止退出[root@iZ2ze9nu608mhi5at5aufaZ /]#  docker run  -it centos  /bin/bash[root@25c39385df34 /]# [root@iZ2ze9nu608mhi5at5aufaZ /]#</code></pre><p><strong>删除容器</strong></p><pre><code class="hljs shell">docker rm 容器id     #删除指定的容器，不能删除正在运行的容器，如果要强制 rm -fdocker rm -f $(docker ps -aq) #删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器</code></pre><p><strong>启动和停止容器</strong></p><pre><code class="hljs shell">docker start 容器iddocker restart iddocker stop iddocker kill id</code></pre><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web介绍</title>
    <link href="/2022/01/04/JavaWeb/"/>
    <url>/2022/01/04/JavaWeb/</url>
    
    <content type="html"><![CDATA[<p><strong>javaWeb轮廓</strong></p><ul><li>Tomcat</li><li>http</li><li>maven</li><li><strong>servlet(核心)</strong></li><li>session，cookie</li><li>jsp(了解)</li><li>三层架构mvc</li><li>JSTL、EL表达式</li><li>过滤器，监听器</li><li>文件上传，邮件收发</li><li>…..(更多拓展)</li></ul><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><p>(1)web开发 ：即网页开发</p><ul><li>静态web ：html + css 提供给人看的数据不会发生变化</li><li>动态web：给人看的数据会变化，每个人看的信息各不相同！(几乎所有网站全是！ <ul><li>技术栈：Servlet/JSP ,ASP, PHP</li></ul></li></ul><p>在java中，动态web资源开发的技术成为Java web</p><p>(2)web应用程序</p><p>可以提供浏览器访问的程序，访问的任何页面或资源，均存在于世界上的某个地方的计算机上 ===&gt; URL</p><p>这个统一的web资源会被放在同一个文件夹下，即web应用服务器中===&gt; <strong>tomcat服务器</strong></p><ul><li>一个web文件多部分组成<ul><li>html + css，js</li><li>jsp ，servlet</li><li>java程序</li><li>jar包</li><li>配置文件(properties)</li></ul></li></ul><p>静态web</p><p><img src="/2022/01/04/JavaWeb/01.png" alt="image-20211231201024786"></p><p>缺点：</p><ul><li>无法动态更新，所有用户看的一样 === &gt; javaScript</li><li>无法和数据库交互，数据无法持久化</li></ul><p>动态web</p><p><img src="/2022/01/04/JavaWeb/02.png" alt="image-20211231201034766"></p><p>缺点：</p><ul><li>加入服务器的动态web资源出现了错误，需要重新编写<strong>后台程序</strong>，重新发布==&gt; 停机维护</li></ul><h1 id="2-WEB服务器"><a href="#2-WEB服务器" class="headerlink" title="2.WEB服务器"></a>2.WEB服务器</h1><h2 id="2-1技术"><a href="#2-1技术" class="headerlink" title="2.1技术"></a>2.1技术</h2><p><strong>ASP</strong> (微软–&gt; 最早流行)</p><ul><li>在HTML中嵌入了VB ==&gt; asp + COM</li><li>在asp中，基本一个页面就有几千行代码，页面很混乱，维护高！</li><li>asp里面主要用C#</li><li>IIS服务器 (windows 里面) </li></ul><p><strong>PHP</strong></p><ul><li>开发速度很快，功能很强，跨平台，代码简单</li><li>无法承载访问大的情况</li></ul><p><strong>JSP/servlet</strong>：</p><p>B/S ==&gt; 浏览器和服务器  C/S 客户端和服务器</p><ul><li>sun公司推出的B/S架构</li><li>基于java，可以承载三高（高并发，高可用，高性能</li></ul><h2 id="2-2-web服务器"><a href="#2-2-web服务器" class="headerlink" title="2.2 web服务器"></a>2.2 web服务器</h2><blockquote><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息</p></blockquote><p><strong>IIS</strong></p><ul><li>微软==&gt;windows 自带  </li></ul><p><strong>tomcat</strong></p><ul><li><p><strong>Tomcat</strong>是由Apache软件基金会属下<a href="https://zh.wikipedia.org/wiki/Jakarta%E9%A1%B9%E7%9B%AE">Jakarta项目</a>开发的<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>容器，实现了对<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>和<a href="https://zh.wikipedia.org/wiki/JavaServer_Page">JavaServer Page</a>（<a href="https://zh.wikipedia.org/wiki/JSP">JSP</a>）的支持，并提供了作为一些特有功能</p><blockquote><p>ps:工作3-5年后可以尝试手写tomcat服务器</p></blockquote><blockquote><p>下载东西的三部曲:</p><p>1.安装&amp;解压</p><p>2.了解配置文件和目录结构</p><p>3.这个东西的作用</p></blockquote><p>补充： java 内部的类，比如String 都来自于<strong>rt.jar包</strong>中</p></li></ul><p><img src="/2022/01/04/JavaWeb/03.png" alt="image-20220101085618516"></p><h1 id="3-tomcat"><a href="#3-tomcat" class="headerlink" title="3.tomcat"></a>3.tomcat</h1><h2 id="3-1下载"><a href="#3-1下载" class="headerlink" title="3.1下载"></a>3.1下载</h2><p><a href="https://tomcat.apache.org/">tomcat官网</a></p><p><img src="/2022/01/04/JavaWeb/04.png" alt="image-20220101090211230"></p><h2 id="3-2tomcat启动和配置"><a href="#3-2tomcat启动和配置" class="headerlink" title="3.2tomcat启动和配置"></a>3.2tomcat启动和配置</h2><p>文件夹结构:</p><p><img src="/2022/01/04/JavaWeb/05.png" alt="image-20220101090524114"></p><p><strong>启动和关闭</strong></p><p> <img src="/2022/01/04/JavaWeb/06.png" alt="image-20220101090649862"></p><p>点击即可</p><p>可看到命令行弹出 <strong>若闪退==&gt; 配置环境变量，检查是否错误！</strong></p><p><img src="/2022/01/04/JavaWeb/07.png" alt="image-20220101091655200"></p><p>在网页中输入：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>若页面显示，则正确</p><h2 id="3-3配置"><a href="#3-3配置" class="headerlink" title="3.3配置"></a>3.3配置</h2><p>服务器核心配置文件</p><p><img src="/2022/01/04/JavaWeb/08.png" alt="image-20220101091932529"></p><p>可以配置启动的端口号</p><ul><li>tomcat 默认端口号：8080</li><li>mysql ==&gt; 3306</li><li>http ==&gt; 80</li><li>https ==&gt; 443</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre><p>配置主机名</p><ul><li>默认主机名：localhost &lt;==&gt; 127.0.0.1</li><li>默认网站应用存在的位置==&gt;webapps</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span></code></pre><blockquote><p>面试题： 网站如何进行访问的！</p><ol><li>输入域名 ==&gt; 回车 </li><li>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件，看一下有无这个域名的映射<ol><li>有==&gt;直接返回对应ip，直接访问</li><li>无==&gt; 去DNS服务器找，找到就返回</li></ol></li></ol></blockquote><p><img src="/2022/01/04/JavaWeb/09.png" alt="image-20220101093806748"></p><p>可进行配置环境变量，方便启动</p><h2 id="3-4-发布一个web网站"><a href="#3-4-发布一个web网站" class="headerlink" title="3.4 发布一个web网站"></a>3.4 发布一个web网站</h2><p>模仿</p><ul><li><p>将自己写的网站，放在服务器tomcat指定的web文件夹下(webapps) ，就可以访问了</p></li><li><pre><code class="shell">--webapps: tomcat 服务器的web目录    -ROOT    -HUANGYIHENG 网站的目录        -WEB-INF            -classes :java 程序            -lib:web应用所依赖的包            -web.xml        -index.html 默认的首页        -static            -css                -style.css            -js            -img        -...</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础</title>
    <link href="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/04/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1.综述"></a>1.综述</h2><blockquote><p>docker学习</p></blockquote><ul><li>概述</li><li>安装</li><li>命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li>docker镜像</li><li>容器数据卷</li><li>dockerFile</li><li>docker网络原理</li><li>idea整合docker</li><li>docker Compose</li><li>docker swarm</li><li>CI/CD jenkins</li></ul><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="Docker为何会出现？"><a href="#Docker为何会出现？" class="headerlink" title="Docker为何会出现？"></a>Docker为何会出现？</h3><p>一款产品：开发==&gt; 上线  应用环境，应用配置</p><p>即开发 &amp; 运维。但常常有一个问题：在我的电脑可以运行，版本更新以及其他问题导致服务不可以，对于运维，考验就很大</p><p>而且环境配置是十分麻烦的，每一个机器都要部署环境（集群Redis，ES，hadoop）===&gt; 费事费力！</p><p>发布一个项目jar包（需要redis，mysql，jdk，es等环境）===&gt; 如果等<strong>带着jar包 和 环境</strong>一起发布岂不妙！</p><p>docker的作用就是如此！</p><blockquote><p>传统：开发jar，其余运维来做</p><p>现在，开发打包部署上线，一套流程</p></blockquote><p>类比: </p><p>java — 开发apk—-发布(到应用商店) —- 使用的话只需下载apk—-安装即可</p><p>java — jar(环境) —- 打包项目带上环境(<strong>镜像</strong>) — 放到docker仓库(即上述的商店) —  下载发布的镜像 — 直接可以运行</p><blockquote><p>docker的思想来自于 集装箱 ！</p><p>jre – 多个应用，可能会产生端口冲突</p><p>隔离 ===&gt; docker的核心思想，打包装箱，每个箱子是互相隔离的</p><p>故docker利用隔离机制，可以将服务器利用到极致！</p></blockquote><h3 id="docker历史"><a href="#docker历史" class="headerlink" title="docker历史"></a>docker历史</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/01.png" alt="image-20220102155224157"></p><p><a href="https://www.docker.com/">Docker官网</a></p><p><a href="https://docs.docker.com/">docker官网文档</a> 超级详细！</p><p><a href="https://hub.docker.com/">docker仓库地址</a> 类似于github</p><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F/1574">镜像</a>中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>操作系统的机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318">沙箱</a>机制，相互之间不会有任何接口。</p></blockquote><h2 id="3-docker安装"><a href="#3-docker安装" class="headerlink" title="3.docker安装"></a>3.docker安装</h2><h3 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h3><p>架构图</p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/2.png" alt="docker"></p><p><strong>镜像(image)</strong>:</p><blockquote><p>​    docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像===&gt; run ===&gt; tomcat01容器(提供服务器)，</p><p>可以通过这个镜像创建多个容器（最终服务运行或项目运行就在容器</p></blockquote><p><strong>容器(container)</strong></p><blockquote><p>docker利用容器技术，独立运行一个或一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令</p><p>目前可以把容器理解成一个简单的linux系统</p></blockquote><p><strong>仓库(repository)</strong></p><blockquote><p>仓库就是存放镜像的地方，分为共有仓库和私有仓库</p><p>docker hub(默认是国外的)</p><p>阿里云….也有容器服务器(需要配置镜像加速，类似于maven一样需要配置)</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>环境准备：</strong></p><blockquote><p>​    1、会linux命令</p><p>​    2、CentOS</p><p>​    3、使用ssh(例如xshell等….)</p></blockquote><p><strong>环境查看</strong>：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统内核是3.10以上的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# uname -r3.10.0-1062.18.1.el7.x86_64</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre><p> <strong>安装</strong> ===&gt; 根据官方文档</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、Uninstall old versions</span>sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span class="hljs-meta">#</span><span class="bash"> 2.安装需要的安装包</span> sudo yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo # 默认是从国外下载<span class="hljs-meta">#</span><span class="bash"> 更新一下yum索引</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4安装docker相关内容</span> sudo yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta"> #</span><span class="bash"> 5 启动docker</span> sudo systemctl start docker<span class="hljs-meta"> #</span><span class="bash"> 6 查看是否安装成功</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker versionClient: Docker Engine - Community Version:           20.10.12 API version:       1.41 Go version:        go1.16.12 Git commit:        e91ed57 Built:             Mon Dec 13 11:45:41 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.12  API version:      1.41 (minimum version 1.12)  Go version:       go1.16.12  Git commit:       459d0df  Built:            Mon Dec 13 11:44:05 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.4.12  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d runc:  Version:          1.0.2  GitCommit:        v1.0.2-0-g52b36a2 docker-init:  Version:          0.19.0  GitCommit:        de40ad0</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7 测试hello world</span>sudo docker run hello-world</code></pre><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/03.png" alt="image-20220103095017939"></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8 查看安装的镜像是否存在</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>卸载</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1卸载依赖</span>sudo yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2 删除资源</span> sudo rm -rf /var/lib/docker #docker的默认工作路径 sudo rm -rf /var/lib/containerd</code></pre><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/04.png" alt="image-20220103095749769"></p><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://0wtfvcv1.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h3 id="HelloWorld运行的原理"><a href="#HelloWorld运行的原理" class="headerlink" title="HelloWorld运行的原理"></a>HelloWorld运行的原理</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/05.png" alt="image-20220103100328777"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>docker如何工作的？</strong></p><blockquote><p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令</p></blockquote><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/06.png" alt="image-20220103101049775"></p><p><strong>docker为何比虚拟机快？</strong></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/07.png" alt="image-20220103101338942"></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/08.png" alt="image-20220103101646104"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2022/01/03/leetcode01/"/>
    <url>/2022/01/03/leetcode01/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/two-sum/"> leetcode 第一题</a></p><p>day1</p><blockquote><p>给定一个<strong>整数数组 nums</strong> 和一个<strong>整数目标值 target</strong></p><p>请你在该数组中找出 和为目标值 target  的那 两个 整数，并<strong>返回它们的数组下标。</strong></p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><p><strong>示例 1：</strong></p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p><strong>示例 2：</strong></p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p><strong>示例 3：</strong></p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力算法 ===&gt; </p><ul><li>i 和 j 双重遍历==&gt; 依次找对应数组元素两者之和是否等于target</li><li>新建数组，长度为2。若上述找到，则将数组内的值赋值为 i 和 j</li><li>将新数组作为最终结果进行return</li></ul><pre><code class="hljs c"><span class="hljs-comment">//c语言实现</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;        *returnSize = <span class="hljs-number">2</span>;<span class="hljs-comment">//因为要返回的数组大小为2</span>        <span class="hljs-comment">//新开辟数组，作为返回结果</span>       <span class="hljs-keyword">int</span> *result = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (*returnSize));       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numsSize; i++) &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; numsSize;j++) &#123;               <span class="hljs-keyword">if</span>( *(nums + i) + *(nums + j) == target ) &#123;                    *result = i;                    *(result + <span class="hljs-number">1</span>) = j;               &#125;           &#125;       &#125;       <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//返回最终结果</span>       <span class="hljs-built_in">free</span>(result);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//java实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> result[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; nums.length;j++) &#123;                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;                    result[<span class="hljs-number">0</span>] = i;                    result[<span class="hljs-number">1</span>] = j;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>效率太低了，时间复杂度高</li></ul><p><strong>如何才能把复杂度降到 0(n^2)以下？</strong></p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>利用<strong>哈希查找</strong></p><ul><li>遍历nums,记 <strong>i 为当前的下标</strong>，看 i 对应nums中的值 是否 map中存在**target - nums[i]**的key值</li><li>若存在，则找到了两个值，不存在则将当前**(num[i],i)** 放入map</li><li>一直遍历至结束</li></ul><p>比如：nums = [2,7,11,15]</p><blockquote><p>1、开始i = 0 找2，target-num[0] = 13-2 = 11 ,该值不存在，即map表中记上 key-value==&gt; (2,0)</p><p>2、此时i = 1 找到7 ，target - num[1] = 13 - 7 = 6 ,也不在，继续记上key-value===&gt;( 7, 1)</p><p>3、此时 i = 2 ,找 11，target - num[2] = 13 - 11 = 2 , 此时key在表中，找到，进行返回 对应下标0和2</p></blockquote><p>map:</p><table><thead><tr><th>key</th><th>2</th><th>7</th><th></th><th></th></tr></thead><tbody><tr><td>value</td><td>0</td><td>1</td><td></td><td></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-comment">//java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;         HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();         <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>( map.containsKey( target-nums[i]) ) &#123;                res[<span class="hljs-number">0</span>] = map.get(target - nums[i]);                res[<span class="hljs-number">1</span>] = i;            &#125;            <span class="hljs-keyword">else</span> &#123;                map.put(nums[i],i);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>法二好好学习 体会 ！哈希表写法</p><p>也可以不创建res数组，直接进行返回，减少空间复杂度</p><pre><code class="hljs java">Class HashMap&lt;K,V&gt;<span class="hljs-comment">// K -钥匙的Map保持型    V -映射的值的类型</span>Interface Map&lt;K,V&gt;<span class="hljs-comment">//以下均是map接口中的方法</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function"><span class="hljs-comment">//返回 `true`如果这Map包含一个指定的键映射。更正式地说，返回  `true`当且仅当这个图中包含了一个关键的 `k`这样 `(key==null ? k==null :  key.equals(k))`映射。（最多可以有一个这样的映射。） </span></span><span class="hljs-function"></span><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function">返回指定的键映射的值，或 <span class="hljs-keyword">null</span>如果这个Map不包含的键映射。 </span><span class="hljs-function">    </span><span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key,V value)</span></span><span class="hljs-function">将指定的值与此映射中的指定键关联（可选操作）。如果映射以前包含一个键的映射，旧值将被指定的值替换</span></code></pre><p><img src="/2022/01/03/leetcode01/01.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html</title>
    <link href="/2021/07/18/html/"/>
    <url>/2021/07/18/html/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Hyper Text Markup Language(超文本标记语言)</p><p>W3C  =  World Wide Web Consortium（万维网联盟)</p><p><a href="https://www.w3.org/">万维网联盟</a></p><p>标准： <strong>结构化</strong>标准语言(html,xml)、<strong>表现</strong>标准语言(css)、<strong>行为</strong>标准(dom，ECMASript)</p><p>利用intelliJ IDEA 进行开发  如图</p><p><img src="/2021/07/18/html/1.png"></p><h3 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--我是注释 --&gt;</span><span class="hljs-comment">&lt;!--DOCTYPE 告诉浏览器，使用什么规范 --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--head网页头部--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--meta 描述性信息 ，一般用于做SEO=搜索引擎优化--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--body网页主体--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="2、网页的基本标签"><a href="#2、网页的基本标签" class="headerlink" title="2、网页的基本标签"></a>2、网页的基本标签</h2><p>输入某个关键字，按tab键，快速生成</p><h3 id="1、标题标签"><a href="#1、标题标签" class="headerlink" title="1、标题标签"></a>1、标题标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标题标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre><h3 id="2、段落便签"><a href="#2、段落便签" class="headerlink" title="2、段落便签"></a>2、段落便签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--段落标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>跑的快 跑得快<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>一直没有耳朵 一直没有尾巴<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="3、换行标签"><a href="#3、换行标签" class="headerlink" title="3、换行标签"></a>3、换行标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--换行标签--&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>跑的快 跑得快 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>一直没有耳朵 一直没有尾巴 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></code></pre><h3 id="4、水平线标签"><a href="#4、水平线标签" class="headerlink" title="4、水平线标签"></a>4、水平线标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--水平线标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></code></pre><h3 id="5、字体样式标签"><a href="#5、字体样式标签" class="headerlink" title="5、字体样式标签"></a>5、字体样式标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--粗体 斜体--&gt;</span>粗体：<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>i love you！<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>斜体: <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>i love you!<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></code></pre><h3 id="6、注释和特殊符号"><a href="#6、注释和特殊符号" class="headerlink" title="6、注释和特殊符号"></a>6、注释和特殊符号</h3><p><strong>&amp;开始 ; 结束</strong>  中间部分根据输入的字母提示找对应的符号</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--特殊符号  &amp;提示; --&gt;</span>空       格空<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>格<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-symbol">&amp;gt;</span> 大于<span class="hljs-symbol">&amp;lt;</span> 小于<span class="hljs-symbol">&amp;copy;</span> 版权符号</code></pre><h3 id="7、图片标签"><a href="#7、图片标签" class="headerlink" title="7、图片标签"></a>7、图片标签</h3><p>常见图片格式：JPG、gif、png、bmp…..</p><p>**相对地址(推荐使用)**和绝对地址</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!--img</span><span class="hljs-comment">src:图片地址（必填</span><span class="hljs-comment">../  上一级目录 但本idea需要使用./才可以正常显示</span><span class="hljs-comment">alt：图片名字 (必填</span><span class="hljs-comment">title：在网页上鼠标放上去会显示(可选</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;./resources/image/2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;名校&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;悬停文字&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;700&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>文件结果如图，以后就这样写！规范</p><p><img src="/2021/07/18/html/2.png"></p><h3 id="8链接标签"><a href="#8链接标签" class="headerlink" title="8链接标签"></a>8链接标签</h3><p>必须掌握</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">a标签</span><span class="hljs-comment">href 必填，表示要跳转到哪个页面</span><span class="hljs-comment">target 表示窗口在哪打开</span><span class="hljs-comment">    _blank 表示在新标签中打开</span><span class="hljs-comment">    _self 表示在自己网页中打开(默认</span><span class="hljs-comment"></span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;1.我的第一个网页.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点击我跳转到页面1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点击我跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--锚链接</span><span class="hljs-comment">1需要一个锚标记</span><span class="hljs-comment">2跳转到此标记</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>功能性标签</p><p>第二个是<a href="https://shang.qq.com/v3/widget.html">qq推广</a>功能  里面自己粘贴过来</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--功能性标签</span><span class="hljs-comment">邮箱链接：mailto</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:1356410594@qq.com&quot;</span>&gt;</span>点击联系我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=1356410594&amp;site=qq&amp;menu=yes&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://wpa.qq.com/pa?p=2:1356410594:53&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>效果如图</p><p><img src="/2021/07/18/html/3.png"></p><p><strong>行内元素和块元素</strong></p><p>块元素：无论内容多少，只占一行 例如p标签</p><p>行内元素:内容撑开宽度，左右都是行内元素的可以排在一行</p><p>css中涉及块元素和行内元素转换</p><h3 id="9列表"><a href="#9列表" class="headerlink" title="9列表"></a>9列表</h3><h4 id="1、有序列表"><a href="#1、有序列表" class="headerlink" title="1、有序列表"></a>1、有序列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--有序列表 order list ，li = list --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre><h4 id="2、无序列表"><a href="#2、无序列表" class="headerlink" title="2、无序列表"></a>2、无序列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--无序列表--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><h4 id="3、自定义列表"><a href="#3、自定义列表" class="headerlink" title="3、自定义列表"></a>3、自定义列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--自定义列表</span><span class="hljs-comment">dl:标签</span><span class="hljs-comment">dt 列表名称</span><span class="hljs-comment">dd:列表内容</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>学科<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>位置<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>菏泽<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre><h3 id="10表格"><a href="#10表格" class="headerlink" title="10表格"></a>10表格</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--表格 table</span><span class="hljs-comment">行 tr</span><span class="hljs-comment">列 td</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!--colspan 跨列 4表示跨4列    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>1-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!-- rowspan跨行 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></code></pre><p>如图</p><p><img src="/2021/07/18/html/4.png"></p><h3 id="11视频和音频"><a href="#11视频和音频" class="headerlink" title="11视频和音频"></a>11视频和音频</h3><p>video 和 audio</p><p><img src="/2021/07/18/html/04.png" alt="image-20210717175509092"></p><h2 id="3、页面分析"><a href="#3、页面分析" class="headerlink" title="3、页面分析"></a>3、页面分析</h2><p><img src="/2021/07/18/html/5.png"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页头部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>主体<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页脚部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="4-内联框架"><a href="#4-内联框架" class="headerlink" title="4.内联框架"></a>4.内联框架</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>  <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mainFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><ul><li>src:引用地址</li><li>width 和 height</li><li>mainFrame:框架标识名</li></ul><h2 id="5-表单"><a href="#5-表单" class="headerlink" title="5.表单"></a>5.表单</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username &quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Yiheng&quot;</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd &quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;Button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;Reset&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;重填&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><ul><li><p>method 请求方式==&gt; get/post</p><ul><li>get： 可以在url中看到提交的信息，不安全但高效</li><li>post：比较安全，可以传输大文件</li></ul></li><li><p>action 表单提交的位置，可以是网站，也可以是一个请求处理地址</p></li><li><p>value ==&gt; 表示该文本框的默认初始值</p><h3 id="表单格式"><a href="#表单格式" class="headerlink" title="表单格式"></a>表单格式</h3></li></ul><p><img src="/2021/07/18/html/06.png" alt="image-20220114074056056"></p><h3 id="单选框radio"><a href="#单选框radio" class="headerlink" title="单选框radio"></a>单选框radio</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 性别:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span> /&gt;</span>女    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>radio : 单选框标签 </p><p>name 表示组，要这俩是同一个组，不可以进行同时选择</p><h3 id="多选框-checkbox"><a href="#多选框-checkbox" class="headerlink" title="多选框 checkbox"></a>多选框 checkbox</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 爱好：       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>唱       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;dance&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>跳       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;rap&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>rap       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="按钮-button"><a href="#按钮-button" class="headerlink" title="按钮 button"></a>按钮 button</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>按钮:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;btn1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击！&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../resources/image/1.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>type:</p><ul><li>button ==&gt; 普通按钮</li><li>image ==&gt; 图像按钮</li><li>submit ==&gt; 提交按钮</li><li>reset ==&gt; 重置</li></ul><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 下拉框:    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>山东<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 反馈:     <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;textarea&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>我是文本框<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="文件域"><a href="#文件域" class="headerlink" title="文件域"></a>文件域</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 上传:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;files&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 邮箱验证:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    URL验证:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-comment">&lt;!--       数字验证 --&gt;</span>    商品数量:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="滑块和搜索框"><a href="#滑块和搜索框" class="headerlink" title="滑块和搜索框"></a>滑块和搜索框</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--    滑块--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 音量:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;voice&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 搜索框:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;search&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>-  隐藏域：hidden-  只读: readonly-  禁用：disabled</code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!--     增强鼠标可用性 当点击时，就会规定到文本框中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span>你点我试试<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mark&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="表单初级验证"><a href="#表单初级验证" class="headerlink" title="表单初级验证"></a>表单初级验证</h3><ul><li><p>placeholder 提示信息 ，会让你根据提示输入对应信息</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name &quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><img src="/2021/07/18/html/blog\source\_posts\html\07.png" alt="image-20220114084831473" style="zoom:67%;"></li><li><p>require 非空验证</p></li><li><p>pattern 正则表达式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言学习</title>
    <link href="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习！"><a href="#C语言再学习！" class="headerlink" title="C语言再学习！"></a>C语言再学习！</h2><p>利用Visual Studio </p><p>vs –debug 将监视窗口、调用堆栈、以及内存变化调整出来！</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2.png"></p><blockquote><p>错误：编译错误&amp;链接错误</p><p>​    编译错误：双击就可以定位到第几行</p><p>​    链接错误：库函数可能写错了！看对应函数符号</p></blockquote><p>​    </p><p>编辑main.c —&gt; 编译main.obj —&gt;和库函数进行链接—&gt;main.exe—-&gt;执行</p><p><strong>写代码——增量编写法，写一点进行测试测试</strong>，<strong>保证正确</strong>，<strong>再继续写</strong></p><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>​    1. <strong>基本类型</strong></p><ul><li>整型 int</li></ul><p>​            表示范围：-2^31 到 2^31 - 1</p><p>​                short 表示范围：-2 ^ 15 到 2 ^ 15 - 1</p><p>​                long 32位机器(4个字节)，64位机器(8个字节)  -2 ^ 63 到 -2 ^63 - 1</p><p>​                unsigned int 变化范围： 0 到 2^32 - 1</p><ul><li>字符型 char</li></ul><p>​                    \n  光标到下一行行首</p><p>​                    \r   光标回到当前行行首</p><p>​                    \b  向前退一格</p><ul><li>实型(浮点型)：</li></ul><p>​                单精度实型float(四个字节)；  有效数字：6-7位</p><p>​                双精度double(八个字节)       有效数字：15-16位</p><p>​    2.<strong>构造类型</strong></p><blockquote><p>数组类型[]</p><p>结构类型struct</p><p>联合类型union</p><p>枚举类型 enum</p></blockquote><p>​    3.*<em>指针类型 **</em></p><ol start="4"><li><strong>空类型(无值类) ：void</strong></li></ol><p>常量：例如 100，3.14，‘a’，“abc”</p><p>变量：代表内存中具有特定属性的一个存储单元，用来存放数据，这就是变量的值，<strong>在程序运行期间，这些值得程序的执行过程是可以改变的。</strong></p><p>符号常量：#define SUN 7</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/3.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/4.png"></p><blockquote><p>熟悉进制的转换</p></blockquote><p>vs采用小端：低位在前，高位在后</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5.png"></p><p>补码：按位取反再+1</p><h3 id="二、scanf原理"><a href="#二、scanf原理" class="headerlink" title="二、scanf原理"></a>二、scanf原理</h3><blockquote><p>输入读取接口：scanf，getchar</p><p>标准输出接口：printf，putchar</p></blockquote><p>1、标准输入缓冲区原理</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">char</span> c;<span class="hljs-comment">//用户输入</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; i = %d\n&quot;</span>,i);<span class="hljs-comment">//正常打印了</span><span class="hljs-comment">//清除缓冲区  ps:vs2013以上版本需要rewind(stdin)  </span>fflush(<span class="hljs-built_in">stdin</span>); <span class="hljs-comment">//如果没有这一句，则c不会等待用户输入，而是直接显示出来c = </span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c); <span class="hljs-comment">//为何？因为输入一个数之后，按回车了，\n在缓冲区里面，读取到了 \n 所以不会等待用户输入 </span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>,c); </code></pre><p><strong>当使用%d的时候，会忽略空格 和 \n</strong></p><p>scanf匹配原理：即是匹配到什么之后，删除什么，没有匹配的仍在缓冲区中</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5_1.png"></p><p>2、scanf循环读取</p><p><code>while( scanf(&quot;%d&quot;,&amp;i) != EOF )</code></p><p>进行完善</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i,ret<span class="hljs-comment">//即便输入的不是整型，也可以提供用户继续输入</span><span class="hljs-keyword">while</span> ( fflush(<span class="hljs-built_in">stdin</span>),(ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i)) != EOF ) </code></pre><p>3、混合读取 </p><pre><code class="hljs c"><span class="hljs-comment">//  %d %c中间加一个空格</span><span class="hljs-comment">//即在读取字符时，在字符前面加上空格</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c%f%lf&quot;</span>,&amp;i,&amp;c,&amp;f,&amp;d);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %5.2f %f &quot;</span>,i,c,f,d);</code></pre><p>getchar() 和 putchar()</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> c;c = getchar();<span class="hljs-built_in">putchar</span>(c);c = getchar();<span class="hljs-comment">//并不会再次阻塞，等待继续输入，而是直接结束，因为缓冲区里有\n,读取到直接退出了</span><span class="hljs-built_in">putchar</span>(c);</code></pre><p>printf()利用占位符进行对其</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-number">21</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;Yiheng&quot;</span>,<span class="hljs-number">5</span>);</code></pre><h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h3><p>*<em>1、算术运算符（ + - * / %）*</em></p><p><strong>2、关系运算符( &gt; ,&lt;, ==, &gt;= ,&lt;= , !=)</strong></p><p><strong>3、逻辑运算符( !,&amp;&amp;,|| )</strong></p><p><strong>4、位运算符( &lt;&lt;, &gt;&gt;, ~, | , ^ , &amp;)</strong></p><p>​            左移&lt;&lt; : 高位丢弃，低位补0，<strong>相当于乘2</strong>，但效率比乘法高</p><p>​            右移&gt;&gt;：**相当于除2 **  正数(unsigned)的话，低位丢弃，高位补0(直接除2);负数的话，低位丢弃，高位补1(减1再除2)</p><p><strong>5、赋值运算符 （ = 及其扩展赋值运算符 ）</strong></p><p><strong>6、条件运算符( ? : )  即三目运算符</strong></p><p><strong>7、逗号运算符 ( , )</strong></p><p>*<em>8、指针运算符 （ * 和 &amp;）*</em></p><p><strong>9、求字节数运算符（ sizeof() )</strong></p><p><strong>10、强制类型转换运算符 （ （类型） ）</strong></p><p><strong>11、分量运算符 (  .  -&gt; )</strong></p><p><strong>12、下标运算符 （ [ ]  ）</strong></p><p><strong>13、其他，如函数调用运算符:()</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6_1.png"></p><p><strong>算术运算符优先级高于关系运算符</strong></p><p><strong>关系运算符高于逻辑与和逻辑或</strong></p><p>a = 5  ==&gt;范围 -6到5</p><p> 0000 0101</p><p>1111 1010 ==&gt; 0000 0110 ==&gt; -6 </p><p>1111 1011 ==&gt;0000 0101 ==&gt; -5</p><p>ps:若要拿到任意一个数的最低位为1的那个数，不利用循环如何实现？<br>     1、若是循环，则此数字每一位和1进行&amp;运算，若为0，则1&lt;&lt;1，再进行下一位比较，为1则找到了<br>        2、利用 i &amp; -i = 最终低位为1的那个数字 ===&gt;该数与其对应补码进行&amp;操作</p><p>异或^：</p><p>​    <strong>任何数与自身异或为 0</strong> </p><p>​    <strong>任何数与0异或为其自身</strong></p><p>可利用异或对两个数进行交换，而不使用中间变量</p><p>交换两个数，三种方法</p><pre><code class="hljs c"><span class="hljs-comment">//1、利用异或，但必须有两个空间，不会出现溢出</span>a = <span class="hljs-number">5</span>,b = <span class="hljs-number">4</span>;a = a ^ b;b = a ^ b; <span class="hljs-comment">// 此时即为 b = (a^b) ^b = a</span>a = a ^ b; <span class="hljs-comment">//此时 a = (a ^ b ) ^ a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//2、利用数学运算对其进行交换,可能会溢出</span>a = a + b;b = a - b;<span class="hljs-comment">// b = (a + b) - b = a </span>a = a - b;<span class="hljs-comment">// a = (a + b) - a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//3、传统的，利用另一个变量temp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">7</span>,temp;temp = a;a = b;b = temp;</code></pre><p>例题：若数组中 101个数，50个数出现两次，1个数出现一次，找出出现一次的这个数的值？**(经典)**</p><p>对数组的的数进行异或操作</p><pre><code class="hljs C"><span class="hljs-comment">//简化版本</span><span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;    <span class="hljs-keyword">int</span> i ,result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); i++) &#123;        result ^= arr[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find value = %d\n&quot;</span>,result); <span class="hljs-comment">//最终输出为7</span></code></pre><p>自增和自减</p><p><code>j = i-- &gt; -2; //等价于j = i &gt; -2;i --</code></p><h3 id="四、选择，循环和数组"><a href="#四、选择，循环和数组" class="headerlink" title="四、选择，循环和数组"></a>四、选择，循环和数组</h3><p>1、if …else</p><p>2、switch</p><pre><code class="hljs angelscript"><span class="hljs-comment">// ( )里面不可以是浮点型表达式 </span><span class="hljs-keyword">switch</span>()&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">break</span>     dafault:<span class="hljs-keyword">break</span>;&#125;</code></pre><p>3、循环</p><p>（1）goto  学校老师讲的不用掌握goto是错误的，<strong>goto才是循环的本质</strong>，对应于汇编中的jmp跳转 </p><pre><code class="hljs C"><span class="hljs-comment">//求前100个数字的和</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;label:    sum += i;    i++;     <span class="hljs-comment">//需要进行判断，小于100才goto，不然一直循环</span>    <span class="hljs-keyword">if</span>( i &lt;= <span class="hljs-number">100</span>)&#123;        <span class="hljs-keyword">goto</span> label;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);</code></pre><p>（2） while  和  do ….while </p><p>（3） for</p><p>4、数组：具有<strong>相同数据</strong>类型的数据的<strong>有序</strong>集合</p><p>(1)、一维数组</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-comment">//定义数组的时候，必须初始化</span>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//arr[0]到arr[4]</span>    <span class="hljs-keyword">sizeof</span>(arr) <span class="hljs-comment">//大小为20个字节 5*4</span>    <span class="hljs-comment">//访问越界，提示stack around arr 代表栈空间访问越界</span>    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">6</span>;    arr[<span class="hljs-number">6</span>] = <span class="hljs-number">7</span>;    arr[<span class="hljs-number">7</span>] = <span class="hljs-number">8</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<span class="hljs-comment">//此时i变为8了，在vs中</span></code></pre><p>访问越界如图所示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/7.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/8.png"></p><p>当作为函数参数传递时，是传递的数组的起始地址，<strong>即数组名存的是数组的起始地址</strong>，不可以修改</p><p>C<strong>语言函数调用是值传递</strong></p><p>(2)、二维数组</p><pre><code class="hljs markdown">int a[<span class="hljs-string">3</span>][<span class="hljs-symbol">4</span>] = &#123;1,3,5,7,2,4,6,8,9,11,13,15&#125;;//范围a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]到a[<span class="hljs-string">2</span>][<span class="hljs-symbol">3</span>]sizeof(a) //48个字节sizeof(a[0])  //16个字节 sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">1</span>]) //4个字节</code></pre><p>(3)、字符数组</p><p>利用%s时scanf(“%s”,d)， 如果输出的有空格，则停止向后读</p><pre><code class="hljs C"><span class="hljs-comment">//这样打印，会出现乱码，因为利用%s打印，遇到\0会停下，并没有存地方\0标志，所以会在内存中打印至\0为止</span><span class="hljs-comment">//  \0代表结束标志 而\0的值即为0</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,c);<span class="hljs-comment">//建议，要有空间保存\0，即长度比字符长度大1</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;ABCDEF&quot;</span>;<span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">sizeof</span>(c); <span class="hljs-comment">// 为10</span><span class="hljs-built_in">strlen</span>(c); <span class="hljs-comment">//是5</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/9.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/10.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/11.png">当利用第二种方法存字符数组时，会在最后添上\0</p><pre><code class="hljs C">gets(c);<span class="hljs-comment">//会在最后添上\0，不会把\n读取到内存中   类似于scanf 也可能不安全，会访问越界</span> <span class="hljs-built_in">puts</span>(c)<span class="hljs-comment">//会在最后打印一个\n</span> <span class="hljs-comment">//等价于printf(&quot;%s\n&quot;,c);</span> <span class="hljs-comment">//循环输入字符串,并打印。按ctrl+z则会退出</span> <span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>]; <span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span> ) &#123;     <span class="hljs-built_in">puts</span>(c); &#125; <span class="hljs-comment">//安全，不会访问越界，当＞sizeof(c)时，系统不允许输入</span> <span class="hljs-comment">//并且会把\n读到内存中</span> fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>);</code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/12.png">例如：输入hello，fgets()会在后面增加\0和\0</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13.png">例：gets()情况，输入hello之后</p><p>str<strong>系列字符串操作函数</strong>   (在头文件#include&lt;string.h&gt;中)</p><pre><code class="hljs C"><span class="hljs-comment">//如果去除fget()后的最后一个\n呐？</span><span class="hljs-comment">//可以利用strlen获取最后的位置，然后替换成\0</span><span class="hljs-comment">//打印输出，并计算长度(去除\n)</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">size_t</span> len;<span class="hljs-keyword">while</span>( fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;    c[ <span class="hljs-built_in">strlen</span>(c) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//进行替换</span>    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输入什么则进行输出什么</span>    len = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);<span class="hljs-comment">//输出输入的长度</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//复制字符串 不能用于整型数组</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">char</span> d[<span class="hljs-number">50</span>];<span class="hljs-comment">//如果过小，会访问越界</span><span class="hljs-built_in">strcpy</span>(d,c);<span class="hljs-comment">//利用此接口进行赋值，会把c中\0读到d中，之后结束</span><span class="hljs-built_in">puts</span>(d);<span class="hljs-comment">//将字符进行拼接！</span><span class="hljs-built_in">strcat</span>(d,<span class="hljs-string">&quot;Yiheng&quot;</span>); <span class="hljs-comment">//最后会有\0</span></code></pre><p>strn<strong>系列字符串造作函数</strong></p><pre><code class="hljs C"><span class="hljs-comment">//strncpy</span><span class="hljs-keyword">int</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">50</span>];<span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//需要另加一句，保证要拷贝到的数组中元素为0</span>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));<span class="hljs-comment">//内置接口，此时将不会出现错误</span>    <span class="hljs-built_in">strncpy</span>(d,c,<span class="hljs-number">7</span>);<span class="hljs-comment">//将c中的前7个字符拷贝到d中，不会有\0结束符，知道内存中遇到\0才结束输出</span>    <span class="hljs-built_in">puts</span>(d);&#125;<span class="hljs-built_in">strncmp</span>(d,<span class="hljs-string">&quot;李宁&quot;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//判断前二个字节是否相等，即d中输入是否和‘李’相等(汉字占两个字节</span><span class="hljs-built_in">strncat</span>(d,<span class="hljs-string">&quot;牛牛牛&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//会部分拼接，把‘牛’拼到d后面</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> b[<span class="hljs-number">5</span>];<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//可以进行内存拷贝，不可以用strcpy()，因为遇到\0则停止拷贝</span></code></pre><h3 id="五、指针"><a href="#五、指针" class="headerlink" title="五、指针"></a>五、指针</h3><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-comment">//通过指针间接访问变量i</span><span class="hljs-keyword">int</span> *p = &amp;i;<span class="hljs-comment">//把i的地址保存起来，初始化必须是一个变量的取地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<span class="hljs-comment">//取保存起来地址所对应的值</span></code></pre><p>1、指针的使用场景：<strong>传递和偏移</strong></p><p>指针的传递：子函数要改变主函数的变量</p><pre><code class="hljs C"><span class="hljs-comment">//函数调用值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *i)</span></span>&#123;    *i /= <span class="hljs-number">2</span>;&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    change(&amp;i)<span class="hljs-comment">//这是会改变i的值，应该是传递的保存i的地址</span>&#125;</code></pre><p>指针的偏移(服务于数组)：p+1，是偏移的基类型的大小–&gt;sizeof(int)</p><pre><code class="hljs C"><span class="hljs-comment">//借助指针将数组元素输出</span><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> *p = &amp;a;<span class="hljs-comment">//数组名保存了数组的起始地址</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>,*(p + i)); <span class="hljs-comment">//其实a[i] &lt;==&gt; *(a+i)</span>&#125;</code></pre><p>2、指针和自增自减操作符</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> *p = a;<span class="hljs-keyword">int</span> j;j = *p++;<span class="hljs-comment">//==&gt;j = *p ,p ++;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 2 7</span>j = (*p)++ <span class="hljs-comment">//===&gt; j = *p,(*p)++;</span><span class="hljs-comment">//上面可改成j  = p[0] ++ 两者等价，不会有影响</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 7 8</span><span class="hljs-comment">//通过上述(*p)++,把数组中第二个元素7变成了8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[1] = %d\n&quot;</span>,a[<span class="hljs-number">1</span>]); <span class="hljs-comment">//8</span></code></pre><p>3、指针与一维数组</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>&#123;    *p = <span class="hljs-string">&#x27;H&#x27;</span>;    p[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;E&#x27;</span>;    *(p+<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;L&#x27;</span>;&#125;main()&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;hello&quot;</span>;    change(c);    <span class="hljs-built_in">puts</span>(c) <span class="hljs-comment">//输出  HELlo</span>&#125;</code></pre><p> (1)动态内存申请</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> needSize;<span class="hljs-keyword">char</span> *pStart;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;needStart);pStart = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(needSize);<span class="hljs-comment">//使用malloc动态申请堆空间</span><span class="hljs-comment">//向申请的空间填入数据</span><span class="hljs-built_in">strcpy</span>(pStart,<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-built_in">puts</span>(pStart);<span class="hljs-built_in">free</span>(pStart);<span class="hljs-comment">//最后用完进行释放</span><span class="hljs-comment">//释放完之后要将此指针赋值为NULL,不然就成了野指针</span>pStart = <span class="hljs-literal">NULL</span>;</code></pre><p>（2）野指针</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> *p1,*p2,*p3;p1 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p1 = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p1 = %d\n&quot;</span>,*p1);<span class="hljs-comment">//1</span>p2 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p2 = <span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p2 = %d\n&quot;</span>,*p2);<span class="hljs-comment">//2</span><span class="hljs-built_in">free</span>(p2);<span class="hljs-comment">//要加上p2 = NULL</span>p2 = <span class="hljs-literal">NULL</span>;p3 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p3 = <span class="hljs-number">3</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//3</span>*p2 = <span class="hljs-number">100</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//不加p2 = NULL ，会输出100</span><span class="hljs-comment">//由于p2被free了，但是后来p3申请空间不知道，p3申请会用p2释放的空间。之后又用了p2所以造成p3出现错误</span><span class="hljs-comment">//在free后面添加p2 = NULL;，如果再次使用p2则会产生错误为何</span></code></pre><p>(3)都是内存空间，为何分栈和堆？</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13_1.png"></p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>windows中栈空间有上限的，单个函数<span class="hljs-number">1</span>M，如果超过，则会Stack Overflow<span class="hljs-regexp">//</span>函数递归调用也有一个上限<span class="hljs-comment">#define N 500000</span>int a[N]<span class="hljs-regexp">//</span>执行到这里则会出现栈溢出</code></pre><p>(4)栈空间和堆空间的差异</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printStack</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;i am stack&quot;</span>;    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输出i am stack</span>    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printMalloc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;i am malloc&quot;</span>);    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出i am malloc</span>    <span class="hljs-keyword">return</span> p; &#125;main() &#123;    <span class="hljs-keyword">char</span> *p;    p = printStack();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//会出现乱码</span>    <span class="hljs-comment">//因为函数执行进行压栈，执行完之后弹栈</span>    <span class="hljs-comment">//之后执行puts的时候把原来函数的栈空间给占了</span>    <span class="hljs-comment">//应该怎么办，利用堆！</span>    p = printMalloc();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出 i am malloc</span>    <span class="hljs-built_in">free</span>(p);    p = <span class="hljs-literal">NULL</span>;&#125;</code></pre><p>(5)realloc动态扩容</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 20</span><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(MAX);<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,max = MAX;<span class="hljs-comment">//对其进行循环输入字符</span><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c) != EOF ) &#123;<span class="hljs-comment">//因为最后要放&#x27;\0&#x27;，故是max -1</span>    <span class="hljs-keyword">if</span>( i == max - <span class="hljs-number">1</span>) &#123;        p = (<span class="hljs-keyword">char</span> *)reallloc(p, max * <span class="hljs-number">2</span>);<span class="hljs-comment">//如果达到最后，利用realloc进行扩容</span>    &#125;    p[i] = c;<span class="hljs-comment">//每次输入的保存起来</span>    i++;&#125;p[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//将最后弄成结束标志，按下ctrl+z则会显示结果</span><span class="hljs-built_in">puts</span>(p);<span class="hljs-built_in">free</span>(p);p = <span class="hljs-literal">NULL</span>;</code></pre><p>（6）字符指针与字符数组初始化</p><p>申请完空间之后，为何<code>strcpy(p,&quot;i am malloc&quot;);</code>而不是 <code>p = &quot;i am malloc&quot;;</code></p><pre><code class="hljs C"><span class="hljs-keyword">char</span> *p = <span class="hljs-string">&quot;helloworld&quot;</span>; <span class="hljs-comment">//字符串存放在数据段的字符串常量区，是不可以修改的！p指向了首地址</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-comment">//这个是在代码段，可以修改</span>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 正确！ </span>p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 错误！！</span>p = <span class="hljs-string">&quot;how are you&quot;</span><span class="hljs-comment">//正确</span>c = <span class="hljs-string">&quot;how are you!&quot;</span><span class="hljs-comment">//错误！！因为c是起始地址，是只读的</span><span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;helloworld!&quot;</span>)<span class="hljs-comment">//错误，因为strcpy会对p[0]=&#x27;h&#x27;进行逐一赋值，但p空间此时不可以修改</span><span class="hljs-comment">//strcpy必须是可读可写的，即malloc申请的堆空间,或让p指向堆空间，指向可以修改的空间</span><span class="hljs-comment">//例如：</span>p = c;<span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;Yiheng&quot;</span>);<span class="hljs-comment">//此时正确</span></code></pre><p>(7)数组指针（服务于二维数组）</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> b[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//b数组名是保存了数组的起始地址 </span><span class="hljs-comment">//&amp;b也是保存了数组的起始地址，但&amp;b类型是数组指针，而b里面的类型为整型指针</span><span class="hljs-comment">//b+1 偏移的是数组类型的一个字节的大小，例如b + 1之后所对应地址的那个变量的值为2</span><span class="hljs-comment">//&amp;b+1 偏移的是整个数组字节大小，此时将跑到数组外面那个地址区域</span><span class="hljs-built_in">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<span class="hljs-comment">//a+1 指向2的起始地址</span><span class="hljs-comment">//&amp;a+1 指向15之后那个地方的地址(相当于&amp;a是一个二维数组指针,偏移整个数组的大小)</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14.png"></p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[][<span class="hljs-number">4</span>],<span class="hljs-keyword">int</span> row)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; row; i ++) &#123;         <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-keyword">sizeof</span>(*p) /<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> );j++)&#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*(*(p+i)+j));             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,p[i][j]);</span>             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,*(p[i]+ j));</span>         &#125;     &#125;&#125;main() &#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;    <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>];<span class="hljs-comment">//数组指针，指向一个长度为4的一维数组</span>    p = a;<span class="hljs-comment">//不会报错</span>    print(p,<span class="hljs-number">3</span>);&#125; <span class="hljs-comment">//动态二维数组</span>p = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">4</span>])<span class="hljs-built_in">malloc</span>( <span class="hljs-number">16</span> * <span class="hljs-number">100</span>);</code></pre><p> (7)二级指针  (<strong>只服务于一级指针的传递和偏移</strong>)</p><p>子函数内需要修改主函数某个一级指针的值，需要二级指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p1,<span class="hljs-keyword">int</span> **p2)</span> </span>&#123;    *p1 = *p2&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>,j = <span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> *p1 = &amp;i,*p2 = &amp;j;<span class="hljs-comment">//此时*p1 = 10,*p2 = 5;</span>    <span class="hljs-comment">//想改变*p1 = 5,*p2 = 10 </span>    change(&amp;p1,&amp;p2);<span class="hljs-comment">//此时利用二级指针成了交换</span>&#125;</code></pre><p>二级指针的初始化必须是某个一级指针变量的取地址</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">10</span>])</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPointerArr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;main()&#123;    <span class="hljs-keyword">char</span> b[N][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&quot;lilei&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;zhousi&quot;</span>&#125;;    <span class="hljs-keyword">char</span> **p = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * N);    print(b);<span class="hljs-comment">//打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>    printPointerArr(b);<span class="hljs-comment">//同样打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>&#125;</code></pre><p>(8)函数指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am b func&quot;</span>);&#125;main() &#123;    <span class="hljs-keyword">void</span> (*p) () <span class="hljs-comment">//p为函数指针</span>    p = b;<span class="hljs-comment">//初始化必须为某个函数的函数名</span>    p();<span class="hljs-comment">//打印i am b func</span>&#125;</code></pre><h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p> <strong>1、函数声明，定义，及调用</strong></p><p>​    通常将程序内容分别放在若干个源文件中，再由若干原程序文件组成一个C程序，便于<strong>分别编写，分别编译，提高调试效率</strong></p><p>点击’运行’即代表增量编译，如果之前运行过，则在运行的基础上进行编译(耗时很短)</p><p>右键–&gt;重新生成 则代表重新编译一次(但意义并不大，运行也慢)</p><p>函数不能嵌套定义</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14_1.png"></p><pre><code class="hljs C"><span class="hljs-comment">//main.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//函数调用</span>    printStar();    printMessage();&#125;<span class="hljs-comment">//func.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">//函数声明,作用：对函数的形参和返回值类型进行检查</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//fun.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-comment">//函数定义</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;how are you?&quot;</span>);&#125;</code></pre><p>2、函数的分类</p><blockquote><p>(1)标准函数，即库函数，系统提供的</p><p>(2) 用户自己定义的函数</p></blockquote><p>不同函数之间传递数据：</p><p>​    参数：通过形参和实参(调用完，空间则释放掉)</p><p>​    返回值：用return语句返回计算结果</p><p>​    全局变量：外部变量(不好，因为会一直占用着空间，也导致阅读困难)</p><p>3、函数的嵌套调用</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><span class="hljs-comment">//嵌套函数直接回到主函数，main调用a，a调用b，b直接回到main</span><span class="hljs-comment">// 函数将系统栈保存于envbuf中，以供以后调用longjmp()。当第一次调用setjmp(),它的返回值为零。</span><span class="hljs-comment">//之后调用longjmp(),longjmp()的第二个参数即为setjmp()的返回值</span>jmp_buf envbuf;<span class="hljs-comment">//全局变量</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am func b\n&quot;</span>);    longjmp(envbuf,<span class="hljs-number">5</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before,i am func a\n&quot;</span>);    b();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after,i am func a\n&quot;</span>);<span class="hljs-comment">//此时这一句不会打印</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ret;    ret = setjmp(envbuf);    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == ret) &#123;        a();&#125;</code></pre><p> 4、函数的递归调用</p><pre><code class="hljs C"><span class="hljs-comment">//爬楼梯，一次只能爬1或者2层</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-number">1</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> ( <span class="hljs-number">2</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-2</span>) + f(n<span class="hljs-number">-1</span>);&#125;</code></pre><p>5、变量及函数的作用域</p><p>​    局部变量和全局变量(内部变量和外部变量)</p><p><strong>变量在离自己最近的大括号内有效</strong></p><p>static—&gt;修饰局部变量，全局变量，函数</p><p><code>static int i = 0;</code>//静态变量只会初始化一次</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//局部变量加static</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//若没有static，则会多次执行此条语句</span>    i++;    print(<span class="hljs-string">&quot;%d\n&quot;</span>,i);&#125;main() &#123;<span class="hljs-comment">//每调用一次就会增加1</span>    fun();<span class="hljs-comment">//此时i = 1</span>    fun();<span class="hljs-comment">//此时i = 2</span>&#125;<span class="hljs-comment">//全局变量,以及函数 前加static，则表明不能被其他的文件借用了，只能在此文件中可见 </span>ps：另一个文件借用全局变量时，借用加<span class="hljs-keyword">extern</span>  </code></pre><h3 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h3><p>不同类型的数据组合成一个有机的整体</p><p>为了避免浪费空间，会把小字节的数据放在一起</p><pre><code class="hljs C"><span class="hljs-comment">//结构体定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">char</span> sex;    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">float</span> score;    <span class="hljs-keyword">char</span> address[<span class="hljs-number">30</span>];&#125;;<span class="hljs-comment">//结构体声明</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">s</span> = &#123;</span><span class="hljs-number">1001</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">98</span>,<span class="hljs-string">&quot;heze&quot;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">sArr</span>[3];</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.address);<span class="hljs-comment">//打印</span><span class="hljs-comment">//用户输入数据，scanf里面空格别忘记</span><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i ++) &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s %c%d%f%s &quot;</span>,&amp;sArr[i].num,sArr[i].name,&amp;sArr[i].sex,&amp;sArr[i].age,&amp;sArr[i].score,sArr[i].address);&#125;<span class="hljs-comment">/** 用户输入</span><span class="hljs-comment">1001 lili M 20 98 heze</span><span class="hljs-comment">1002 lele F 22 92 heze</span><span class="hljs-comment">1003 hehe M 19 88 heze</span><span class="hljs-comment">**/</span><span class="hljs-comment">//打印到屏幕</span><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,sArr[i].num,sArr[i].name,sArr[i].sex,sArr[i].age,sArr[i].score,sArr[i].address);&#125;</code></pre><p>通过<strong>结构体变量名.成员名</strong>来访问结构体成员</p><p>1、结构体指针</p><p>一个结构体变量的指针就是该变量所占据的内存段的起始地址。</p><p>可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址</p><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">float</span> score;&#125;<span class="hljs-keyword">student_t</span>,*pStudent_t;<span class="hljs-comment">//student_t就是结构体的别名 *pStudent_t等价于struct student*，可以利用这个定义指针</span>pStudent_t p1,p2;<span class="hljs-comment">//p1，p2均为结构体指针</span><span class="hljs-keyword">student_t</span> s = &#123;<span class="hljs-number">101</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">99</span>&#125;;<span class="hljs-keyword">student_t</span> *p = &amp;s;<span class="hljs-comment">//结构体指针</span><span class="hljs-comment">//利用指针访问成员变量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %0.2f\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;score);</code></pre><p>2、typedef定义变量 </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE; <span class="hljs-comment">//此时相当于INTERGE为int类型，即int的别名,编译的时候真正产生这个类型</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4<span class="hljs-comment">// 一般是定义常量，而且是在预处理时候直接替换,后面不需要加分号，上面那个需要加</span></span></code></pre><p>3、共用体与枚举</p><pre><code class="hljs C"><span class="hljs-comment">//联合体(共用体) 所有成员公用一块空间，并且不可修改</span><span class="hljs-keyword">union</span> data &#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">float</span> f;&#125;;<span class="hljs-comment">//枚举</span><span class="hljs-keyword">enum</span> weekday &#123;sun,mon,tue,wed,thus,fir,sat&#125;;<span class="hljs-comment">//sum = 0，mon = 2,.......</span></code></pre><h3 id="九、数据结构基础"><a href="#九、数据结构基础" class="headerlink" title="九、数据结构基础"></a>九、数据结构基础</h3><h4 id="1、链表的增删改查"><a href="#1、链表的增删改查" class="headerlink" title="1、链表的增删改查"></a>1、链表的增删改查</h4><p>线性表的两种存储结构：线性结构(<strong>数组</strong>）和链式结构(<strong>链表</strong>)</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/15.png"></p><p>写链表首先先定义结点！</p><pre><code class="hljs C"><span class="hljs-comment">//结点定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;        <span class="hljs-keyword">float</span> score;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">pNext</span>;</span> &#125;;</code></pre><p>新增：头插法，尾插法，有序插入</p><pre><code class="hljs C"><span class="hljs-comment">//结点的声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span>&#125;Student_t,*pStudent_t;<span class="hljs-comment">//头插法  参数是二级指针</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 新结点的next指针指向原有头结点，新结点作为头结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listHeadInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pNew-&gt;num = val;    <span class="hljs-comment">//判断链表是否为空</span>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-comment">//不空，则进行插入</span>    <span class="hljs-keyword">else</span> &#123;        pNew-&gt;next = *head;        *head = pNew;    &#125;&#125;<span class="hljs-comment">//尾插法</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 原来尾结点的next指针指向新结点，再将新结点作为尾结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listTailInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStduent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Stduent_t));    pNew-&gt;num = val;    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        (*tail)-&gt;next = pNew;        *tail = pNew;    &#125;&#125;<span class="hljs-comment">//有序插入</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//若不为空，如果头结点的值&gt;要插入结点的值==&gt;头插法;如果没有，则遍历链表，找到比插入值大的结点位置，新结点的next指针指向当前结点位置，前一个结点的next指针指向新结点;未找到插入位置，说明要放到链表尾部，尾插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listSortInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pStudent_t pCur,pPre;<span class="hljs-comment">//vs老版本中，定义必须放在前面，不然会错误</span>    pNew-&gt;num = val; <span class="hljs-comment">//进行初始化，不然结果为0</span>    pCur = pPre = *head;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( val &lt; pCur-&gt;num ) &#123;    <span class="hljs-comment">//头插法</span>        pNew-&gt;next = *head;        *head = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( <span class="hljs-literal">NULL</span> != pCur) &#123;        <span class="hljs-comment">//找到了结点比要插入的结点大，这说明插入这中间</span>            <span class="hljs-keyword">if</span>( pCur-&gt;num &gt; val ) &#123;                pPre-&gt;next = pNew;                pNew-&gt;next = pCur;<span class="hljs-comment">//在这一步之前，要保证前一个结点不能丢失</span>                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//保证pCur向前走，而pPre跟在pCur之后那个位置，即:pPre先赋值成pCur(保存好位置),pCur再走</span>            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有插入到中间，则pCur == NULL,则插入到最后</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            pPre-&gt;next = pNew;            *tail = pNew;        &#125;    &#125;&#125;<span class="hljs-comment">//主函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    pStduent_t phead = <span class="hljs-literal">NULL</span>,pTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) != EOF) &#123;        listHeadInsert(&amp;pHead,&amp;pTail,<span class="hljs-keyword">int</span> num);<span class="hljs-comment">//要将地址进行传入</span>    &#125;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//删除链表中的结点</span><span class="hljs-comment">/*</span><span class="hljs-comment">    判断是否为空==&gt;为空打印，链表为空</span><span class="hljs-comment">    判断删除值是不是头结点==&gt;是的话==&gt;头结点的pNext赋值给头结点，free删除的结点空间，如果删除结点后链表为空，设置尾指针为NULL</span><span class="hljs-comment">    不是的话==&gt;遍历链表，找到要删除的值，将前一个结点的pNext的指针指向删除结点的下一个结点，判断删除结点地址值是否等于尾指针，相等==&gt;说明删除为尾结点，尾指针指向前一个结点，之后free删除的结点；若没有找到删除的结点，打印没有发现删除结点的值</span><span class="hljs-comment">    </span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> deleteNum)</span> </span>&#123;    <span class="hljs-comment">//pCur用来指向被删除的结点，一直遍历，pPre指向pCur的前一个结点</span>    pStudent_t pCur = *head,pPre;    pPre = pCur;    <span class="hljs-comment">//判断是否为空</span>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pCur) &#123;        print(<span class="hljs-string">&quot;list is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//删除头部结点</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pCur-&gt;num == deleteNum) &#123;        *head = pCur-&gt;next;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head ) &#123;            *tail = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-comment">//删除头部或尾部</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( *head != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span> ( pCur-&gt;next == deleteNum) &#123;                pPre-&gt;next = pCur-&gt;next;                <span class="hljs-keyword">break</span>;            &#125;            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有找到对应结点</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find deleteNum\n&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (pCur == *tail) &#123;            *tail = pPre;        &#125;    &#125;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//修改链表中的元素</span><span class="hljs-comment">//并不需要修改头指针，所以传入一级指针就行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listModify</span><span class="hljs-params">(pStudent head,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">float</span> score)</span> </span>&#123;    <span class="hljs-keyword">while</span> ( head != <span class="hljs-literal">NULL</span> ) &#123;        <span class="hljs-keyword">if</span>( head-&gt;num = num) &#123;            head-&gt;socre = socre;        &#125;        head = head-&gt;next;    &#125;    <span class="hljs-keyword">if</span> ( head == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find modify num\n&quot;</span>);    &#125;&#125;</code></pre><h4 id="2、常用数据结构和算法"><a href="#2、常用数据结构和算法" class="headerlink" title="2、常用数据结构和算法"></a>2、常用数据结构和算法</h4><p>设计数据结构，就是为了高效管理数据。</p><p>有效的存取方法可提高我们访问数据的效率，即算法</p><p>需要掌握的数据结构</p><p><strong>数组，栈，队列，链表，树，堆，散列表，图…..</strong></p><h5 id="1-、栈-stack"><a href="#1-、栈-stack" class="headerlink" title="(1)、栈(stack)"></a>(1)、栈(stack)</h5><p>后进先出</p><pre><code class="hljs C"><span class="hljs-comment">//栈的定义</span><span class="hljs-comment">//结点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> *<span class="hljs-title">pNext</span>;</span>&#125;Node_t,*pNode_t ;<span class="hljs-comment">//利用链，栈的结构体</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    pNode_t head;    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈的大小</span>&#125;Stack_t,pStack_t;<span class="hljs-comment">//一系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//初始化栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//入栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//返回栈的大小</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//确定栈是否为空</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">stack</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Stack_t));<span class="hljs-comment">//系统内置接口，在&lt;string.h&gt;中，用于将内存初始化某值</span>    <span class="hljs-comment">//是将Stack_t中的分量设置为0的快捷的方法</span>    <span class="hljs-comment">//void *memset( void *buffer, int ch, size_t count );</span>    <span class="hljs-comment">// 拷贝ch到buffer从头开始的count个字符里，并返回buffer指针</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//入栈，头插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-comment">//既然是入栈，肯定是要申请结点空间</span>    pNode_t pNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pNew-&gt;val = val;    pNew-&gt;pNext = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-built_in">stack</span>-&gt;head = pNew;    <span class="hljs-built_in">stack</span>-&gt;size ++;&#125;<span class="hljs-comment">//出栈，头部删除法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-comment">//先判断是否栈为空</span>    pNode_t pCur;<span class="hljs-comment">//因为要删除结点，肯定要free,所以必须要个pCur</span>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//之后进行pop</span>    pCur = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-comment">//stack-&gt;head = stack-&gt;head-&gt;pNext;</span>    <span class="hljs-built_in">stack</span>-&gt;head = pCur = pCur-&gt;pnext;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//防止野指针</span>    <span class="hljs-built_in">stack</span>-&gt;size --;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;head-&gt;val;&#125;<span class="hljs-comment">//返回栈的元素个数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;size;&#125;<span class="hljs-comment">//判断是否为空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">stack</span>-&gt;size;&#125;</code></pre><h5 id="2-、队列"><a href="#2-、队列" class="headerlink" title="(2)、队列"></a>(2)、队列</h5><p>循环队列</p><pre><code class="hljs C"><span class="hljs-comment">//循环队列的定义，利用数组实现</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 5</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType data[MaxSize];    <span class="hljs-keyword">int</span> front,rear;&#125;SqQueue_t;<span class="hljs-comment">//系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *)</span></span>;<span class="hljs-comment">//初始化队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *,ElemType )</span></span>;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t *,ElemType* )</span></span>;<span class="hljs-comment">//出队,利用了传出参数</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化循环队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>)</span> </span>&#123;    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-rear = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>,ElemType x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否满了</span>    <span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; queue is full\n&quot;</span>);    &#125;    <span class="hljs-comment">//入队，放入x</span>    <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;rear] = x;    <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize;<span class="hljs-comment">//rear向前走</span>&#125;<span class="hljs-comment">//出队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t* <span class="hljs-built_in">queue</span>,ElemType *x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty\n&quot;</span>);    &#125;    <span class="hljs-comment">//出队</span>    *x = <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;front];    <span class="hljs-built_in">queue</span>-&gt;front = ((<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize)&#125;</code></pre><h5 id="3-、二叉树"><a href="#3-、二叉树" class="headerlink" title="(3)、二叉树"></a>(3)、二叉树</h5><p><strong>每个结点最多有两个子树的树结构！</strong></p><p>二叉树常用于实现 <strong>二叉查找树 和 二叉堆</strong></p><p><strong>层次建树==&gt;辅助队列</strong></p><p>k层，总节点数 2^k - 1</p><p>完全二叉树：只允许最后一层有空缺且在右边。对任一结点，其右子树的深度为j，则左子树深度必为j或j+1,度为1的点只有1个或0个</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<span class="hljs-comment">//结点声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span></span><span class="hljs-class">&#123;</span>    ElemType c;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pleft</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pright</span>;</span>&#125;Node_t,*pNode_t;<span class="hljs-comment">//2、利用辅助队列进行层次建树</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span></span><span class="hljs-class">&#123;</span>    pNode_t insertPos; <span class="hljs-comment">//要插入结点的位置</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span> *<span class="hljs-title">pNext</span>;</span>&#125;Queue_t,*pQueue_t;<span class="hljs-comment">//接口声明</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//前序遍历==&gt;根左右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//中序遍历==&gt;左根右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//后序遍历===&gt;左右根</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t*,pQueue_t*,pQueue_t *,<span class="hljs-keyword">int</span> )</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span> )     &#123;        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);        <span class="hljs-built_in">putchar</span>(root-c);    &#125;&#125;<span class="hljs-comment">//2、层次建树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t *treeRoot,pQueue_t *queHead,pQueue_t *queTail,<span class="hljs-keyword">int</span> val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//申请结点</span>    pNode_t treeNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pQueue_t queNew = (pQueue_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Queue_t));    pQueue_t queCur = *queHead;<span class="hljs-comment">//指向给哪个元素结点放孩子 </span>    treeNew-&gt;c = val;    queNew-&gt;insertPos = treeNew;    <span class="hljs-comment">//判断是否有根节点</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *treeRoot )    &#123;        *treeRoot = treeNew;        *queHead = queNew;        *queTail = queNew;    &#125;    <span class="hljs-comment">//根节点不为空，找插入位置</span>    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//队列操作，把元素放入队列===&gt;尾插法</span>        (*queTail)-&gt;pNext = queNew;        *queTail = queNew;        <span class="hljs-comment">//判断左子树是否空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pleft )        &#123;            queCur-&gt;inSertPos-&gt;pleft = treeNew;        &#125;        <span class="hljs-comment">//判断右子树是否为空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pright )        &#123;            queCur-&gt;insertPos-&gt;pright = treeNew;            <span class="hljs-comment">//先保存后释放,某个结点左右孩子都有了之后，出队</span>            *queHead = queCur-&gt;pNext;            <span class="hljs-built_in">free</span>(queCur);            queCur = <span class="hljs-literal">NULL</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1、可利用数组进行层次建树</span>    ElemType c[] = <span class="hljs-string">&quot;ABCDEFJHI&quot;</span>;    pNode_t p[N];<span class="hljs-comment">//p为指针数组</span>    <span class="hljs-keyword">int</span> i,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j记住往哪个结点放数据</span>    <span class="hljs-comment">//为每个结点申请空间，同时把结点值放进去</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        p[i] = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));        p[i]-&gt;c = c[i];    &#125;    <span class="hljs-comment">//第一个结点A不需要建立，即A自己也是。故从1开始进入</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;N;i++)<span class="hljs-comment">//外层控制进入的元素</span>    &#123;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p[j]-&gt;pleft )<span class="hljs-comment">//内层比较，找位置</span>        &#123;            p[j]-&gt;pleft = p[i];<span class="hljs-comment">//为空，则放入</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( NUll == p[j]-&gt;pright )        &#123;            p[j]-&gt;pright = p[i];            j++;<span class="hljs-comment">//插入完之后，跑到B位置等待左右孩子插入其中(j初始为0)</span>        &#125;    &#125;    <span class="hljs-comment">//2、辅助队列进行层次建树</span>    ElemType val;    pNode_t treeRoot = <span class="hljs-literal">NULL</span>;    pQueue_t queHead = <span class="hljs-literal">NULL</span>,queTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%c&quot;</span>,&amp;val) != EOF)    &#123;        <span class="hljs-keyword">if</span>( val == <span class="hljs-string">&#x27;\n&#x27;</span> ) &#123;            <span class="hljs-keyword">break</span>;        &#125;        BuildBinaryTree(&amp;treeRoot,&amp;queHead,&amp;queTail,val);    &#125;&#125;</code></pre><h5 id="4-、排序算法"><a href="#4-、排序算法" class="headerlink" title="(4)、排序算法"></a>(4)、排序算法</h5><p>时间复杂度和空间复杂 </p><p>时间复杂度====&gt;大O符号表示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/16.png"></p><p><strong>掌握八种算法：冒泡，选择，插入，希尔，快排，堆排，归并，基排</strong>.  </p><blockquote><p>插入类：插入排序，希尔排序</p><p>选择类：选择排序，堆排序</p><p>交换类：冒泡排序，快速排序</p><p>归并类：归并排序</p><p>分配类：基数排序、计数排序、桶排序，同额外的空间来分配和收集，继而实现排序</p></blockquote><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/17.png"> </p><p><strong>qsort重点掌握！！！</strong></p><h5 id="lt-1-gt-冒泡"><a href="#lt-1-gt-冒泡" class="headerlink" title="&lt;1&gt;冒泡"></a>&lt;1&gt;冒泡</h5><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">2001 li 45.5 96.5 70.4</span><span class="hljs-comment">2009 liu 98.5 78.5 98.6</span><span class="hljs-comment">2003 lin 78 83.5 79.6</span><span class="hljs-comment">2004 zhang 95 93.5 80.5</span><span class="hljs-comment">2005 wang 88.5 75.7 40.6</span><span class="hljs-comment">*/</span><span class="hljs-comment">/* 冒泡排序</span><span class="hljs-comment">1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><span class="hljs-comment">2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><span class="hljs-comment">3、针对所有的元素重复以上的步骤，除了最后一个。</span><span class="hljs-comment">4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  SWAP(a,b) &#123;int tmp;tmp = a; a = b;b = tmp;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; N;i++)    &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>;i &lt; N - <span class="hljs-number">1</span> - i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])            &#123;                SWAP(arr[j],arr[j+<span class="hljs-number">1</span>])            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="lt-2-gt-选择"><a href="#lt-2-gt-选择" class="headerlink" title="&lt;2&gt;选择"></a>&lt;2&gt;选择</h5><pre><code class="hljs C"><span class="hljs-comment">/*选择排序</span><span class="hljs-comment">首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</span><span class="hljs-comment">然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span><span class="hljs-comment">以此类推，直到所有元素均排序完毕</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,maxPos;    <span class="hljs-keyword">for</span>(i = N;i&gt;<span class="hljs-number">0</span>;i++)    &#123;        maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>( j = <span class="hljs-number">1</span>;j &lt; i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[maxPos])            &#123;                maxPos = j;            &#125;        &#125;        SWAP(arr[maxPos,arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-3-gt-插入"><a href="#lt-3-gt-插入" class="headerlink" title="&lt;3&gt;插入"></a>&lt;3&gt;插入</h5><pre><code class="hljs C"><span class="hljs-comment">/*认为零号元素自然有序,从1号元素开始插入</span><span class="hljs-comment">先存储插入元素的值，从后向前，依次拿有序序列的值，依次与插入元素的值进行比较</span><span class="hljs-comment">如果有序序列值大于插入元素值，有序序列值向后移动一位，找到插入元素值的位置，将插入元素值放入对应位置</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>;i &lt; N;i++)     &#123;        InsertVal = arr[i];        <span class="hljs-keyword">for</span> (j = i <span class="hljs-number">-1</span>;j &gt;= <span class="hljs-number">0</span>; j--)         &#123;            <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )             &#123;                arr[j + <span class="hljs-number">1</span>] = arr[j];            &#125;            <span class="hljs-keyword">else</span>             &#123;                <span class="hljs-keyword">break</span>;            &#125;            &#125;        arr[j + <span class="hljs-number">1</span>] = InsertVal;        &#125;&#125;</code></pre><h5 id="lt-4-gt-希尔"><a href="#lt-4-gt-希尔" class="headerlink" title="&lt;4&gt;希尔"></a>&lt;4&gt;希尔</h5><pre><code class="hljs C"><span class="hljs-comment">//希尔排序,需要一个步长,步长以长度的1/2开始，每次步长除2减少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrShell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal,gap;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>(gap = N &gt;&gt; <span class="hljs-number">1</span>;gap &gt;<span class="hljs-number">0</span>;gap &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-comment">//gap 除以2 ,利用移位可调高效率</span>    &#123;        <span class="hljs-keyword">for</span>( i = gap;i &lt; N;i++)         &#123;            InsertVal = arr[i];            <span class="hljs-keyword">for</span> (j = i -gap;j &gt;= <span class="hljs-number">0</span>; j= j - gap)             &#123;                <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )                 &#123;                    arr[j + gap] = arr[j];                &#125;                <span class="hljs-keyword">else</span>                 &#123;                    <span class="hljs-keyword">break</span>;                &#125;                &#125;            arr[j + gap] = InsertVal;            &#125;    &#125;&#125;</code></pre><h5 id="lt-5-gt-快排"><a href="#lt-5-gt-快排" class="headerlink" title="&lt;5&gt;快排"></a>&lt;5&gt;快排</h5><pre><code class="hljs C"><span class="hljs-comment">/*递归进行，开始进行partition划分，选择最后一个元素作为分割值，将比分隔值小的放在分隔值的左边，比分隔值大的放在分隔值的右边，此时分隔值的位置就确定了，故返回分隔值的下标。此时数组一分为二，对前半部分和后半部分继续进行分割，重复操作，进行递归</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,k;<span class="hljs-comment">//i遍历数组，k记录比右边小的数的位置</span>    <span class="hljs-keyword">for</span>(i = left,k = left;i &lt; right;i++)     &#123;        <span class="hljs-comment">//进行交换</span>        <span class="hljs-keyword">if</span>(arr[right] &gt;  arr[i])        &#123;            SWAP(arr[i],arr[k]);            k++;        &#125;    &#125;    SWAP(arr[k],arr[right]);    <span class="hljs-keyword">return</span> k;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrQuick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span>( left &lt; right )    &#123;        <span class="hljs-keyword">int</span> pivot;        pivot = partition(arr,left,right);        arrQuick(arr,left,pivot - <span class="hljs-number">1</span>);        arrQuick(arr,pivot + <span class="hljs-number">1</span>,right);    &#125;&#125;</code></pre><h5 id="lt-6-gt-堆排"><a href="#lt-6-gt-堆排" class="headerlink" title="&lt;6&gt;堆排"></a>&lt;6&gt;堆排</h5><p>什么是堆===&gt;用数组去存一棵树</p><p>左孩子 son = 2 * dad + 1 (位置而言)</p><p><strong>大根堆(大顶堆)：若父结点的值恒大于等于子结点的值</strong>，若从小到大排序，需要建立大顶堆</p><p><strong>小根堆(小顶堆)：若父结点的值小于等于子结点的值</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/18.png"></p><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">    堆排序</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_max_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> adjust_pos,<span class="hljs-keyword">int</span> len)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dad = adjust_pos;    <span class="hljs-keyword">int</span> son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子</span>    <span class="hljs-keyword">while</span>( son &lt; len)    &#123;        <span class="hljs-comment">//可能没右孩子，先判断右孩子是存在及右孩子是否大于左孩子</span>        <span class="hljs-keyword">if</span>( son + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) &#123;            son ++;        &#125;        <span class="hljs-keyword">if</span>(arr[son] &gt; arr[dad]) &#123;            SWAP(arr[son],arr[dad]);            <span class="hljs-comment">//因为一个调整后，可能或影响其他的，导致其他的需要再次调整，所以进行循环调整</span>            <span class="hljs-comment">//把交换完的重新作为dad，再次判断</span>            dad = son;            son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">//倒着从最后一个父结点开始调整</span>    <span class="hljs-keyword">for</span>( i = N/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> ; i--) &#123;        adjust_max_heap(arr,i,N);    &#125;    <span class="hljs-comment">//接着需要进行有序化</span>    <span class="hljs-comment">//把最后一个结点和根节点交换，接着最后一个结点是最大的，去除！再进行调整</span>    SWAP(arr[<span class="hljs-number">0</span>],arr[N<span class="hljs-number">-1</span>]);     <span class="hljs-keyword">for</span>( i = N - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">1</span> ; i--) &#123;        <span class="hljs-comment">//因为只破坏了根部，所以只需一直调整根部为大根堆</span>        adjust_max_heap(arr,<span class="hljs-number">0</span>,i);        SWAP(arr[<span class="hljs-number">0</span>],arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-7-gt-归并"><a href="#lt-7-gt-归并" class="headerlink" title="&lt;7&gt;归并"></a>&lt;7&gt;归并</h5><pre><code class="hljs C"><span class="hljs-comment">//归并</span><span class="hljs-comment">//合并两个有序数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> high)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> b[N];    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i = low;i &lt;= high;i++)    &#123;        b[i] = arr[i];    &#125;    <span class="hljs-keyword">for</span>(k = low,i = low,j = mid + <span class="hljs-number">1</span>;i &lt;= mid &amp;&amp; j&lt;= high;)    &#123;        <span class="hljs-keyword">if</span>(b[i] &lt; b[j])        &#123;            arr[k] = b[i];            k++;            i++;        &#125;        <span class="hljs-keyword">else</span>        &#123;            arr[k] = b[j];            k++;            j++;        &#125;    &#125;    <span class="hljs-keyword">while</span>(i &lt;= mid)    &#123;        arr[k] = b[i];        k++;        i++;    &#125;    <span class="hljs-keyword">while</span>(j &lt;= high)    &#123;        arr[k] = b[j];        k++;        j++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">if</span>(low &lt; high)     &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        arr_merge(arr,low,mid);        arr_merge(arr,mid + <span class="hljs-number">1</span>,high);        merge(arr,low,mid,high);    &#125;&#125;</code></pre><h5 id="lt-8-gt-计数排序"><a href="#lt-8-gt-计数排序" class="headerlink" title="&lt;8&gt;计数排序"></a>&lt;8&gt;计数排序</h5><p>空间换时间！====  数据的范围必须是有限的</p><pre><code class="hljs C"><span class="hljs-comment">//申请一个被排序数的范围大小的空间arr_count,遍历数组，统计数组中每个值出现的次数</span><span class="hljs-comment">//遍历arr_count，根据每个值出现的次数，对要排序的数组进行填充</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>     M 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">int</span> arr_count[M] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">//统计出arr数组中，每个值出现的次数</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        arr_count[arr[i]]++;    &#125;    k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; M;i++)    &#123;        <span class="hljs-keyword">for</span>(j= <span class="hljs-number">0</span> ;j&lt;arr_count[i];j++)        &#123;            arr[k] = i;            k++;        &#125;    &#125;&#125;</code></pre><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/19.png"> </p><p>涉及到磁盘的===&gt;尽可能少读磁盘，速度太慢</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/20.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/21.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/22.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/23.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/24.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/25.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/26.png"> </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>针对有序数组~</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high,<span class="hljs-keyword">int</span> target)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(low &lt;= high)    &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>( arr[mid ] &gt; target)        &#123;            high = mid <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( arr[mid ] &lt; target)        &#123;            low = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><h5 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h5><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/27.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28_1.png"></p><p><strong>哈希冲突</strong></p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29_1.png"></p><p>建议用链表法</p><pre><code class="hljs C"><span class="hljs-comment">//哈希查找：通过哈希函数对要找的字符串进行哈希计算，得到key值(数组下标)，通过key去哈希表中得到对应的元素</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxKey 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *key)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//ELF hash函数</span>    <span class="hljs-comment">//下面是公式！冲突会比较少，经验！</span>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>,g;    <span class="hljs-keyword">while</span>( *key )    &#123;        h = (h &lt;&lt; <span class="hljs-number">4</span>) + *key++;        g = h &amp; <span class="hljs-number">0xf0000000</span>;        <span class="hljs-keyword">if</span>(g)         &#123;            h ^= g &gt;&gt; <span class="hljs-number">24</span>;        &#125;        h &amp;= ~g;    &#125;    <span class="hljs-keyword">return</span> h % MaxKey;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_hash</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *pStr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;xiongda&quot;</span>,<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;wangdao &quot;</span>,<span class="hljs-string">&quot;fenghua&quot;</span>&#125;;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *pHash_table[MaxKey] = &#123;<span class="hljs-literal">NULL</span>&#125;;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is key = %d\n&quot;</span>,pStr[i],hash(pStr[i]));        pHash_table[hash(pStr[i])] = pStr[i];    &#125;&#125;</code></pre><h3 id="十、文件操作"><a href="#十、文件操作" class="headerlink" title="十、文件操作"></a>十、文件操作</h3><p><strong>程序执行时成为进程</strong>，进程运行过程中的数据均在内存中。需要存储运算后的数据时，就需要使用文件</p><p>文件是指存储在外部介质(磁盘或磁带)上的数据集合。操作系统是以文件为单位对数据进行管理的</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/30.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/31.png"> </p><p>1、文件的打开、读写、关闭  </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/32.png">  </p><pre><code class="hljs C"><span class="hljs-comment">//从文件中读</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> c;    FILE *fp;<span class="hljs-comment">//是结构体指针，系统定义好的</span>    fp = fopen(<span class="hljs-string">&quot;text.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//r表示只读</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == fp )    &#123;        perror(<span class="hljs-string">&quot;fopen&quot;</span>);<span class="hljs-comment">//如果指针错误，则利用perror定位错误信息</span>        <span class="hljs-keyword">goto</span> error;    &#125;    <span class="hljs-comment">//把text.txt文件的内容打印到屏幕上</span>    <span class="hljs-keyword">while</span>( (c = fgetc(fp)) != EOF)    &#123;        <span class="hljs-built_in">putchar</span>(c);    &#125;error:    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客的搭建-hexo-github</title>
    <link href="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/"/>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/</url>
    
    <content type="html"><![CDATA[<h2 id="1前提介绍："><a href="#1前提介绍：" class="headerlink" title="1前提介绍："></a>1前提介绍：</h2><p>​    我用的是win10，下面会从win10来介绍，不过mac应该也差别不大</p><p>正式搭建之前，我们先要做好提前的准备</p><h2 id="2需要提前安装的软件："><a href="#2需要提前安装的软件：" class="headerlink" title="2需要提前安装的软件："></a>2需要提前安装的软件：</h2><h3 id="1-、node-js"><a href="#1-、node-js" class="headerlink" title="(1)、node.js"></a><strong>(1)、node.js</strong></h3><p>官网 ：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> </p><p>image-20200811072015514</p><p>点击12.18.3 LTS 根据步骤安装即可，记得勾选添加到环境变量</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-10-24.png" alt="Snipaste_2020-08-11_08-10-24"></p><p>安装之后，打开命令行，即win+r 敲入cmd，进入命令行</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-08-40.png"></p><p>输入：<code>node -v</code> 和 <code>npm -v</code></p><p>​    如图所示</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-05-46.png" alt="Snipaste_2020-08-11_08-05-46"></p><h3 id="2-、git"><a href="#2-、git" class="headerlink" title="(2)、git"></a>(2)、<strong>git</strong></h3><p>(也可以用别的命令行工具，但需要带git，我就用的cmder也可以)</p><p>git官网： <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-12-37.png" alt="Snipaste_2020-08-11_08-12-37"></p><p>cmder官网： <a href="https://cmder.net/">https://cmder.net/</a>    (选择Download  Full)</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-13-33.png" alt="Snipaste_2020-08-11_08-13-33"></p><p>安装完毕之后，就可以在开始菜单看到所安装的东西了</p><p><code>tips：git bash/cmder其实就是相当于linux下的终端窗口，之后就用它来代替win10里面的cmd就行啦</code></p><p>下面正式开始！！！</p><h2 id="3安装hexo"><a href="#3安装hexo" class="headerlink" title="3安装hexo"></a>3安装hexo</h2><p>首先在电脑某位置建立blog文件</p><p>类似这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-21-08.png" alt="Snipaste_2020-08-11_08-21-08"></p><p>之后的操作都在blog文件里面，如果哪儿不行，就可以把blog文件删掉，重新来</p><p>然后在文件夹内用git bash 或cmder 右键打开终端</p><p>输入：</p><p>​     <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code> </p><p>即借用npm安装cnpm的淘宝源~安装之后下载会更快一些</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-16-35.png" alt="Snipaste_2020-08-11_10-16-35"></p><p>可以利用  <code>cnpm</code> 和 <code>cnpm -v</code>   查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-35.png" alt="Snipaste_2020-08-11_08-48-35"></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-47.png" alt="Snipaste_2020-08-11_08-48-47"></p><p>则说明成功！</p><p>接着利用cnmp安装hexo</p><p> <code>cnpm install -g hexo-cli</code>      等待…….</p><p>再输入</p><p><code>hexo -v</code></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-51-44.png" alt="Snipaste_2020-08-11_08-51-44"></p><p><strong>则hexo安装成功！！</strong></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-54-17.png" alt="Snipaste_2020-08-11_08-54-17"></p><p>利用 <code>pwd</code>  命令查看一下自己所在的文件位置 ，是否在blog下</p><p>如果是ok，进行初始化 <code>hexo init</code>，接着等待 就行啦</p><p>之后blog文件夹会变成这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-06-14.png" alt="Snipaste_2020-08-11_09-06-14"></p><p>可以在source -&gt; _posts中看到博客的内容，在里面进行创建，是Markdown的形式</p><p>大功告成，进行测试，下面这几个命令我们管理博客经常用到的~</p><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> clean <span class="hljs-comment">#用来清理缓存文件</span>hexo g      <span class="hljs-comment">#生成文件</span>hexo  s     <span class="hljs-comment">#运行本地服务器</span>hexo  d   <span class="hljs-comment">#上传到服务器</span></code></pre><p>终端敲入<code>hexo s</code></p><p>就会看到 4000端口的localhost网址，在浏览器输入，就会看到默认landscape主题的博客</p><p>类似于这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-12-33.png"></p><p><strong>本地环境搭建完毕！！！</strong></p><h2 id="4推送到远端"><a href="#4推送到远端" class="headerlink" title="4推送到远端"></a>4推送到远端</h2><p>下面就要推到远端github上，所以需要一个<a href="https://github.com/">github</a>账号</p><p>然后进行注册就好啦~最好name是小写英文，否则好像会出现bug</p><p>可以在account中change name</p><p>创建好之后，create a new repository</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-26-02.png" alt="Snipaste_2020-08-11_09-26-02"></p><p>Repository name 中输入前面Owner的具体名字，再加github.io</p><p>就如：<code>codeheng.github.io</code> 以后就可以利用这个网址访问</p><p>在blog下打开终端，win10输入<code>npm install --save hexo-deployer-git</code></p><p>安装git部署的插件</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-18-46.png" alt="Snipaste_2020-08-11_10-18-46"></p><p>安装完毕后，进行一些设置，博客的基本配置都在<code>_config.yml</code>中，我是用vscode打开的</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-19-37.png" alt="Snipaste_2020-08-11_10-19-37"></p><p>进行如下的修改</p><p>type中内容改为git，<em>注意<strong>冒号后面有一个空格</strong></em></p><p>添加repo：后面是在github中查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-45-07.png" alt="Snipaste_2020-08-11_09-45-07"></p><p>最终如图所示：</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-12-53.png" alt="Snipaste_2020-08-11_10-12-53"></p><p>接着就可以把本地的部署到远端了，利用<code>hexo d</code>命令，之后输入用户名和密码就成功了！</p><p>如果没有用过git，需要提前输入下面这两行命令，设置名字和邮箱，再进行上述输入</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.name&quot;</span>`git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.email&quot;</span></code></pre><p>到此为止基本结束！只不过主题是默认的~根据自己的喜好更好即可</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-56-14.png" alt="Snipaste_2020-08-11_09-56-14"></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
