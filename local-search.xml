<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>9排序</title>
    <link href="/2022/04/02/9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/02/9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h1><p><strong>从小到大排序</strong></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code class="hljs c"><span class="hljs-comment">//对数组长度为n的arr排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> n)</span> </span>&#123;     <span class="hljs-comment">//进行n-1轮</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="hljs-number">-1</span>];j--) &#123;            swap(arr[j],arr[j<span class="hljs-number">-1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//用于优化冒泡</span>    <span class="hljs-comment">//进行n-1轮循环</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n &amp;&amp; flag != <span class="hljs-number">0</span>;i++) &#123;        flag = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n-i;j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &lt;= arr[j+<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            swap(arr[j],arr[j+<span class="hljs-number">1</span>]);            flag ++;        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-comment">//若元素太少，&lt; 2</span>    <span class="hljs-keyword">if</span> ( r - l &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">//此时两个元素,并且前面值大，则进行交换</span>        <span class="hljs-keyword">if</span> (r -l == <span class="hljs-number">1</span> &amp;&amp; arr[l] &gt; arr[r]) swap(arr[l],arr[r]);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//保存中间结点</span>    <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-comment">//两边分别递归，进行排序</span>    merge_sort(arr,l,mid);    merge_sort(arr,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-comment">//递归排序完，两两有序，进行归并过程</span>    <span class="hljs-comment">//开辟新空间</span>    <span class="hljs-keyword">int</span> *temp = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (r-l+<span class="hljs-number">1</span>));    <span class="hljs-comment">//p1指向第一个数组第一个位置,p2指向归并的第二个数组的第一个位置，k指向新开辟的的第一个位置</span>    <span class="hljs-keyword">int</span> p1 = l,p2 = mid + <span class="hljs-number">1</span>,k = <span class="hljs-number">0</span>;    <span class="hljs-comment">//当一个数组或者第二个数组有元素时,进行循环</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid || p2 &lt;= r) &#123;        <span class="hljs-comment">//归并，放到临时存储区</span>        <span class="hljs-comment">//当 第二个数组为空，或者第一个不空且满足第一个值小 p1指向进行赋值，否则p2指向赋值</span>        <span class="hljs-keyword">if</span> (p2 &gt; r || p1 &lt;= mid &amp;&amp; arr[p1] &lt;= arr[p2])  &#123;            temp[k++] = arr[p1++];        &#125;        <span class="hljs-keyword">else</span> &#123;            temp[k++] = arr[p2++];        &#125;    &#125;    <span class="hljs-comment">//此时已有序，再将数据拷贝到原数组中</span>    <span class="hljs-comment">//复制temp指向内存内容的前 sizeof(int)*(r-l+1) 个字节到arr+l所指的内存地址上</span>    <span class="hljs-built_in">memcpy</span>(arr+l,temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (r-l+<span class="hljs-number">1</span>));&#125; </code></pre><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 20</span><span class="hljs-comment">//异或此方式适用于两个是不同元素</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap(a,b) &#123; \</span>  a ^= b;b ^= a; a ^= b;\&#125;<span class="hljs-comment">//输出数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, * (arr + i));    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-comment">//定义一个长度为MAX_LEN的数组arr</span>    <span class="hljs-keyword">int</span> arr[MAX_LEN];    <span class="hljs-comment">//对元素随机赋值 (0-100)</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; MAX_LEN;i++) &#123;        arr[i] = rand() % <span class="hljs-number">100</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原数组：&quot;</span>);    output(arr,MAX_LEN);    insert_sort(arr,MAX_LEN);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入排序：&quot;</span>);    output(arr,MAX_LEN);    bubble_sort(arr,MAX_LEN);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;冒泡排序：&quot;</span>);    output(arr,MAX_LEN);    merge_sort(arr,<span class="hljs-number">0</span>,MAX_LEN<span class="hljs-number">-1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;归并排序: &quot;</span>);    output(arr,MAX_LEN);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202204022104919.png" alt="image-20220402210438861"></p><h1 id="非稳定排序"><a href="#非稳定排序" class="headerlink" title="非稳定排序"></a>非稳定排序</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n<span class="hljs-number">-1</span>;i++) &#123;        <span class="hljs-keyword">int</span> index = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++) &#123;            <span class="hljs-keyword">if</span> (arr[index] &gt; arr[j]) index = j;        &#125;        swap(arr[i],arr[index]);    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span> (r &lt;= l) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//x指向头，y指向尾，index为基准值，选择第一个为基准</span>    <span class="hljs-keyword">int</span> x = l,y = r,index = arr[l];     <span class="hljs-comment">//若左边位置 &lt; 右边位置 一直循环</span>    <span class="hljs-keyword">while</span> (x &lt; y) &#123;        <span class="hljs-comment">//循环进行寻找，至 右边对应值&gt;基准值,则y减小</span>        <span class="hljs-keyword">while</span> (x &lt; y &amp;&amp; arr[y] &gt;= index) --y;        <span class="hljs-comment">//此时若满足 左 &lt; 右,则将右边值放到左边，则x对应位置自增</span>        <span class="hljs-keyword">if</span> (x &lt; y) arr[x+=] = arr[y];        <span class="hljs-comment">//同理操作左边</span>        <span class="hljs-keyword">while</span> (x &lt; y &amp;&amp; arr[x] &lt;= index) ++x;        <span class="hljs-keyword">if</span> (x &lt; y) arr[y--] = arr[x];    &#125;    <span class="hljs-comment">//此时头尾相交,赋值，然后左右分别进行快排</span>    arr[x] = index;    quick_sort(arr,l,x<span class="hljs-number">-1</span>);    quick_sort(arr,x+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="main测试-1"><a href="#main测试-1" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap(a,b) &#123; \</span>    __typeof(a) _temp = a; \    a = b,b = _temp; \&#125;<span class="hljs-comment">//输出数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, * (arr + i));    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-keyword">int</span> arr[MAX_LEN];    <span class="hljs-comment">//对数组进行赋值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; MAX_LEN;i++) &#123;        arr[i] = rand() % <span class="hljs-number">100</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原数组：&quot;</span>);    output(arr,MAX_LEN);    select_sort(arr,MAX_LEN);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选择排序：&quot;</span>);    output(arr,MAX_LEN);    quick_sort(arr,<span class="hljs-number">0</span>,MAX_LEN<span class="hljs-number">-1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;快速排序：&quot;</span>);    output(arr,MAX_LEN);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202204022126776.png" alt="image-20220402212644727"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.堆排序</title>
    <link href="/2022/04/02/8%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/02/8%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>利用<strong>大根堆</strong>或者<strong>小根堆</strong> 进行排序</p><ul><li>大根堆，每次弹出最大值到最后，故最终<strong>从小到大排序</strong></li><li>小根堆，每次弹出最小值到最后，故最终<strong>从大到小</strong>排序</li></ul><p>因为每次弹出后，需要进行<strong>向下调整</strong>，使其再次满足树的条件</p><p><strong>封装对树的向下调整方法</strong></p><pre><code class="hljs c"><span class="hljs-comment">//对有n个元素的arr数组的index位置进行向下调整</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">downUpdate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//若有子节点，则进行调整</span>    <span class="hljs-keyword">while</span> ( (index &lt;&lt; <span class="hljs-number">1</span>) &lt;= n ) &#123;        <span class="hljs-comment">//记录要调整的位置,左，右</span>        <span class="hljs-keyword">int</span> temp = index,l = index &lt;&lt; <span class="hljs-number">1</span>,r = index &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;        <span class="hljs-comment">//建立大根堆，找最大的==&gt; 左右 分别与根比较</span>        <span class="hljs-keyword">if</span> (arr[l] &gt; arr[temp]) temp = l;        <span class="hljs-keyword">if</span> (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r;        <span class="hljs-keyword">if</span> (index == temp) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//进行对应交换</span>        swap(arr[temp],arr[index]);        <span class="hljs-comment">//将根index重新指向</span>        index = temp;    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre><p><strong>建堆，进行堆排序</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//保证下标从1开始,小tips，此时原先0位置需要arr[1]才可以访问</span>    arr -= <span class="hljs-number">1</span>;    <span class="hljs-comment">//调整结点，建立大根堆</span>    <span class="hljs-comment">//找到数组中，最后一个有元素的位置,即n/2,然后开始调整</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n &gt;&gt;<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">1</span>;i--)&#123;        downUpdate(arr,n,i);    &#125;    <span class="hljs-comment">//进行排序,n次最大值弹出，向下调整</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n;i &gt; <span class="hljs-number">1</span> ; i--) &#123;        <span class="hljs-comment">//最后元素和顶部元素交换</span>        swap(arr[<span class="hljs-number">1</span>],arr[i]);         <span class="hljs-comment">//调整arr数组，还剩i-1,对index=1位置，即堆顶进行调整</span>        downUpdate(arr,i<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre><p><strong>输出</strong></p><pre><code class="hljs c"><span class="hljs-comment">//输出数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d]: &quot;</span>,len);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, * (arr + i));    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;</code></pre><p>main测试</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_OP 20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap(a,b) &#123; \</span>    __typeof(a) _temp = a; \    a = b,b = _temp; \&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));     <span class="hljs-comment">//对数组分配空间</span>    <span class="hljs-keyword">int</span> *arr = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * MAX_OP);     <span class="hljs-comment">//随机对数组元素赋值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP;i++) &#123;        arr[i] = rand() % <span class="hljs-number">100</span>;    &#125;     <span class="hljs-comment">//输出长度为MAX_OP的数组arr</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原数组:\n&quot;</span>);    output(arr,MAX_OP);     <span class="hljs-comment">//进行堆排序</span>    heap_sort(arr,MAX_OP);    <span class="hljs-comment">//排序完再进行输出</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆排序后：\n&quot;</span>);    output(arr,MAX_OP);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202204021111390.png" alt="image-20220402111112351"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/2022/03/31/leetcode12/"/>
    <url>/2022/03/31/leetcode12/</url>
    
    <content type="html"><![CDATA[<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="[144] 二叉树的前序遍历"></a>[144] 二叉树的前序遍历</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你二叉树的<strong>根节点 root</strong> ，返回它节点值的 <strong>前序 遍历</strong>。</p></blockquote><p><strong>示例 1：</strong></p><p>输入：root = [1,null,2,3]<br>输出：[1,2,3]</p><p><strong>示例 2：</strong></p><p>输入：root = []<br>输出：[]<br><strong>示例 3：</strong></p><p>输入：root = [1]<br>输出：[1]<br><strong>示例 4：</strong></p><p>输入：root = [1,2]<br>输出：[1,2]<br><strong>示例 5：</strong></p><p>输入：root = [1,null,2]<br>输出：[1,2]</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>递归 和 非递归</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>递归</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//保存最终结果，将其返回</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        list.add(root.val);        list.addAll(preorderTraversal(root.left));        list.addAll(preorderTraversal(root.right));        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><ul><li><code>add</code>是将传入的参数作为当前List中的一个Item存储，即使你传入一个List，也只会为当前的List增加1个</li><li><code>addAll</code> 是传入一个List，将此List中的<strong>所有元素</strong>加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小</li></ul><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p><strong>非递归遍历</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//非递归</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        <span class="hljs-comment">//定义栈，保存结点</span>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//将根节点入栈</span>        stack.push(root);        <span class="hljs-comment">//若栈不空,一直循环</span>        <span class="hljs-keyword">while</span> ( !stack.isEmpty()) &#123;            TreeNode node = stack.pop(); <span class="hljs-comment">//将栈顶弹出，对应值添加到list中</span>            list.add(node.val);            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) stack.push(node.right);            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) stack.push(node.left);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="[94]二叉树的中序遍历"></a>[94]二叉树的中序遍历</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p> 给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> </p></blockquote><p><strong>示例 1：</strong></p><p>输入：root = [1,null,2,3]</p><p>输出：[1,3,2]</p><p><strong>示例 1：</strong></p><p>输入：root = []<br>输出：[]</p><p><strong>示例 1：</strong></p><p>输入：root = [1]<br>输出：[1]</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>递归和非递归</p><p><strong>递归法和前序相同！</strong></p><h4 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;         List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//若根为空，直接返回</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        <span class="hljs-comment">//左 ==&gt; 根 ==&gt; 右</span>        list.addAll(inorderTraversal(root.left));        list.add(root.val);        list.addAll(inorderTraversal(root.right));        <span class="hljs-keyword">return</span> list;     &#125;&#125;</code></pre><h4 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h4><p>非递归，利用栈</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//利用临时进行保存根，因为要入栈,并访问左子树</span>        TreeNode node = root;        <span class="hljs-comment">//若node不为空或者栈不空，进行循环，找左边子节点，进行入栈</span>        <span class="hljs-keyword">while</span> ( !(stack.isEmpty()) || node != <span class="hljs-keyword">null</span> ) &#123;            <span class="hljs-comment">//若node不为空，则入栈</span>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;                stack.push(node);                <span class="hljs-comment">//根入栈后，向左子树走</span>                node = node.left;            &#125;            <span class="hljs-comment">//此时代表栈不空，将栈顶出栈，并加入到list中,之后访问右子树</span>            <span class="hljs-keyword">else</span> &#123;                node = stack.pop();                list.add(node.val);                node = node.right;            &#125;        &#125;        <span class="hljs-keyword">return</span> list;     &#125;&#125;</code></pre><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="[145]二叉树的后序遍历"></a>[145]二叉树的后序遍历</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong></p></blockquote><pre><code class="hljs shell">示例1输入：root = [1,null,2,3]输出：[3,2,1]示例 2：输入：root = []输出：[]示例 3：输入：root = [1]输出：[1]</code></pre><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><h4 id="法一-2"><a href="#法一-2" class="headerlink" title="法一"></a>法一</h4><p>递归</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;         <span class="hljs-comment">//递归  (左==&gt; 右 ==&gt; 根)</span>        list.addAll(postorderTraversal(root.left));        list.addAll(postorderTraversal(root.right));        list.add(root.val);        <span class="hljs-keyword">return</span> list;       &#125;&#125;</code></pre><h4 id="法二-2"><a href="#法二-2" class="headerlink" title="法二"></a>法二</h4><p>非递归</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;        <span class="hljs-comment">//左 右 根 &lt;==&gt; 访问 根 右 左 然后反转 (和前序异曲同工！)</span>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//若根不为null或栈不空，一直循环</span>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-comment">//若根不为空，则一直向右走</span>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;                list.add(root.val);                stack.push(root);                root = root.right;            &#125;            TreeNode node = stack.pop();            root = node.left;        &#125;        <span class="hljs-comment">//进行反转</span>        Collections.reverse(list);        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h2 id="前中后序非递归总结"><a href="#前中后序非递归总结" class="headerlink" title="前中后序非递归总结"></a>前中后序非递归总结</h2><p><strong>前序</strong>  ： 根==&gt; 左==&gt; 右 </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//根不空，或栈不空 循环遍历</span>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-comment">//根不空时，先将根的值放到容器中，根压栈，然后向左子树走</span>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;                list.add(root.val);                stack.push(root);                root = root.left;            &#125;            <span class="hljs-comment">//当走到空的时候，没法继续走了，弹栈，访问右边</span>            TreeNode node = stack.pop();            root = node.right;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><p>**中序 **： 左 ==&gt; 根==&gt; 右</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//进行循环</span>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-comment">//若根不空，先入栈，访问左边</span>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;                stack.push(root);                root = root.left;            &#125;            <span class="hljs-comment">//此时左边访问完毕，再弹栈，将对应值放入容器，再访问右子树</span>            root = stack.pop();            list.add(root.val); <span class="hljs-comment">//添加到容器中</span>            root = root.right;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><p>后序： 左 ==&gt; 右 ==&gt; 根</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">//左 右 根 &lt;== 先访问 根 右 左 反转 (即和前序异曲同工)</span>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;                list.add(root.val);                stack.push(root);                root = root.right;<span class="hljs-comment">//和前序的差异，前序是向左走</span>            &#125;            TreeNode node = stack.pop();            root = node.left;<span class="hljs-comment">//和前序的差异</span>        &#125;        Collections.reverse(list);        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="[173]二叉搜索树迭代器"></a>[173]二叉搜索树迭代器</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.二叉树线索化</title>
    <link href="/2022/03/30/5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96/"/>
    <url>/2022/03/30/5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>希望得到二叉树中<strong>某一个结点的前驱或者后继结点</strong>时，普通的二叉树，只能进行遍历一次二叉树，十分不方便</p><p>、<img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202204020843430.png" alt="image-20220402084340288"></p><p>一个有<code>n</code>个结点的二叉链表，每个节点都有指向左右孩子的两个指针域，一共有<code>2n</code>个指针域，即存在<code>2n - (n-1) = n+1</code>个空指针域</p><p><strong>线索二叉树就是利用<code>n+1</code>个空链域来存放结点的前驱和后继结点的信息</strong></p><p>加上线索的二叉树，即成为<strong>线索二叉树</strong></p><p>​     <strong>结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202204020844274.png" alt="image-20220402084405241"></p><p><code>ltag</code>和<code>rtag</code> 标志是否为线索，若为0则说明为孩子，为1则为线索</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="hljs c"><span class="hljs-comment">//定义线索二叉树</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-keyword">int</span> val;     <span class="hljs-keyword">int</span> ltag,rtag;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">child</span>;</span>&#125;Node;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs c"><span class="hljs-function">Node *<span class="hljs-title">getNewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;    Node *node = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));    node-&gt;val = val;    node-&gt;lchild = node-&gt;rchild = <span class="hljs-literal">NULL</span>;    node-&gt;rtag = node-&gt;ltag = NORMAL; <span class="hljs-comment">//宏定义，此时为0，表明为左右子树，而非线索</span>    <span class="hljs-keyword">return</span> node;&#125;</code></pre><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *node)</span> </span>&#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//非线索的时候进行销毁</span>    <span class="hljs-keyword">if</span> (node-&gt;ltag == NORMAL) clear(node-&gt;lchild);    <span class="hljs-keyword">if</span> (node-&gt;rtag == NORMAL) clear(node-&gt;rchild);    <span class="hljs-built_in">free</span>(node);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><pre><code class="hljs c"><span class="hljs-comment">//插入结点 (排序二叉树)</span><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> getNewNode(val);    <span class="hljs-keyword">if</span> (val == root-&gt;val) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root-&gt;rchild = insert(root-&gt;rchild,val);    <span class="hljs-keyword">else</span> root-&gt;lchild = insert(root-&gt;lchild,val);    <span class="hljs-keyword">return</span> root;&#125;</code></pre><h2 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h2><pre><code class="hljs c"><span class="hljs-comment">//中序遍历线索化, 对于root为根节点的，建立线索化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_thread</span><span class="hljs-params">(Node *root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//静态局部变量技巧，记录之前处理的子树的最后一个结点</span>    <span class="hljs-keyword">static</span> Node *pre = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">//左子树线索化,之后pre指向左子树中序最后一个节点</span>     build_thread(root-&gt;lchild);     <span class="hljs-keyword">if</span> (root-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123;         root-&gt;lchild = pre;         root-&gt;ltag = THREAD;     &#125;     <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123;         pre-&gt;rchild = root;         pre-&gt;rtag = THREAD;     &#125;     pre = root;     build_thread(root-&gt;rchild);     <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//递归中序遍历 (是有序的! 排序二叉树的性质)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node *root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (root-&gt;ltag == NORMAL) inOrder(root-&gt;lchild);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,root-&gt;val);    <span class="hljs-keyword">if</span> (root-&gt;rtag == NORMAL) inOrder(root-&gt;rchild);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="沿线索进行输出"><a href="#沿线索进行输出" class="headerlink" title="沿线索进行输出"></a>沿线索进行输出</h2><pre><code class="hljs c"><span class="hljs-comment">//找中序第一个结点</span><span class="hljs-function">Node *<span class="hljs-title">letfMost</span> <span class="hljs-params">(Node *p)</span> </span>&#123;    <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;ltag == NORMAL &amp;&amp; p-&gt;lchild) p = p-&gt;lchild;    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//沿着线索化输出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Node *root)</span> </span>&#123;    Node *p = letfMost(root);    <span class="hljs-keyword">while</span> (p) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;val);        <span class="hljs-keyword">if</span> (p-&gt;rtag == THREAD) &#123;            p = p-&gt;rchild;        &#125; <span class="hljs-keyword">else</span> &#123;            p = letfMost(p-&gt;rchild);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;</code></pre><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_OP 5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NORMAL 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THREAD 1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));    Node *node = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; MAX_OP;i++) &#123;        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;        node = insert(node,val);    &#125;    build_thread(node);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;中序遍历(递归) : &quot;</span>);    inOrder(node);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;中序线索化输出: &quot;</span>);    output(node);    clear(node);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203311811395.png" alt="image-20220331181127309"></p><p>两次运行均相同，表示符合预期</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.优先队列/堆</title>
    <link href="/2022/03/30/7%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E5%A0%86/"/>
    <url>/2022/03/30/7%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><table><thead><tr><th>普通队列</th><th>(最大/最小) 堆</th></tr></thead><tbody><tr><td>尾部入队</td><td>尾部可以插入</td></tr><tr><td>头部出队</td><td>头部可以弹出</td></tr><tr><td>先进先出</td><td>每次出队权值(最大/最小的元素)</td></tr><tr><td>数组实现</td><td>数组实现，<strong>逻辑上看成堆</strong></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4.哈夫曼编码</title>
    <link href="/2022/03/29/4%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/2022/03/29/4%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　<strong>哈夫曼（Huffman）编码算法</strong>是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。</p><p>根据文本字符出现的频率，重新对字符进行编码</p><blockquote><p><strong>出现频率越高的字符越会在上层，这样它的编码越短；</strong></p><p><strong>出现频率越低的字符越会在下层，编码越短。</strong></p><p><strong>经过这样的设计，最终整个文本存储空间才会最大化的缩减</strong></p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈夫曼编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h1><p>1、数据库的设计过程</p><ul><li>需求分析： 用户的需求，包括<strong>数据、功能和性能</strong>需求。</li><li>概念结构设计 <code>E-R模型</code></li><li>逻辑结构设计 <code>E-R图  ==&gt; 表</code></li><li>物理结构设计 ： 设计的数据库选择合适的<strong>存储结构和存取路径</strong></li><li>数据库实施 ：编程、测试和试运行</li><li>数据库运行和维护 </li></ul><p>2、事务的概念以及四个特征</p><p>事务是一系列数据操作的结合，要么通过<code>commit</code> 一起成功，要么通过<code>rollback</code>一起回滚</p><p>事务是指作为<strong>单个逻辑工作单元</strong> 执行的一系列操作，要么全做，要么不做</p><p> <code>ACID ==&gt; atomicity, consistency, isolation, durability </code></p><ul><li>原子性 ： 事务是最小的操作结合，不可再分</li><li>一致性 ： 数据库在事务执行前后都要保持一致，在此前提下，所有事务对同一数据的读取结果均是相同的</li><li>隔离性 ： 一个事务所做的修改在其提交之前，对其他事务是不可见的</li><li>持久性 ： 事务提交之后，所有对数据的修改永远存在数据库中</li></ul><p>3、数据库规范化过程 / 概述范式</p><p><code>1NF 2NF 3NF BCNF</code>  逐步增高  <strong>Normal Form</strong></p><ul><li><p>1NF </p><p>数据库表的<strong>每一列都是不可分割</strong>的数据项，<strong>关系型数据库都要满足1NF</strong></p><p>属性（对应于表中的<strong>字段</strong>）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段</p></li><li><p>2NF  </p><p>在1NF基础上，消除了<strong>非主属性</strong>对码的<strong>部分</strong>依赖</p><p>第二范式在第一范式的基础上增加了一个列，这个列称为主键，<strong>非主属性都依赖于主键</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png" alt="第二范式"></p></li><li><p>3NF :</p><p>在2NF 基础上，消除了<strong>非主属性</strong>对码的<strong>传递</strong>依赖，解决了数据冗余过大，插入异常，修改异常，删除异常的问题</p></li><li><p>BCNF </p><p>在3NF基础上消除了，<strong>主属性</strong>对码的<strong>部分依赖和传递依赖</strong></p></li></ul><p>4、<strong>完整性的约束条件</strong></p><p>是一组完整性规则的集合，是对<strong>数据模型以及联系</strong>所具有的制约和依赖性规则</p><p>分为 <strong>实体完整性，参照完整性 ，用户自定义完整性</strong></p><ul><li>实体完整性： 是对<strong>主键</strong>的约束，主属性独一无二且不为空</li><li>参照完整性： 是对<strong>外键</strong>的约束，外键必须是另一个关系的主键值或者为为空</li><li>自定义完整性 ： 根据用户需求，比如sex 只能为男或女</li></ul><p>5、并发性一致的问题</p><ul><li>【丢失数据】： T1,T2同时对一个数据进行修改，T1先修改，T2再修改，覆盖了T1的修改，造成T1事务修改的丢失</li><li>【脏读】 ： T1事务修改一个数据，但未提交，之后T2访问了该数据，此时T1进行了回滚操作，T2读的数据将会和第一次不同</li><li>【不可重复读】： T2读取一个数据，T1对数据进行了修改，T2再次读取，重复读取的结果不同</li><li>【幻读】 ： T1读取某一范围的数据，T2向这个范围插入数，T1重复读时，发现结果不同了</li></ul><blockquote><p>通过<strong>并发控制</strong>来保证隔离，并发控制可通过<strong>封锁</strong>来实现</p></blockquote><p>6、封锁</p><p>封锁是指事务T在对某个数据对象（例如表、记录等）操作之前，<strong>先向系统发出请求</strong>，对其<strong>加锁</strong>。</p><p>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</p><p>【封锁类型】</p><ul><li>排它锁（记为X锁/写锁）</li></ul><p>​       若事务T 对数据对象A 加上X 锁，则只允许T 读取和修改A ， 其它任何事务都不能再对A 加任何类型的锁，直到T 释放A 上的锁。</p><ul><li><p>共享锁（记为S锁/读锁）</p><p>​      若事务T 对数据对象A 加上S 锁，则其它事务只能再对A 加S 锁，而不能加X 锁，直到T 释放A 上的S 锁。</p><p>X锁和S锁都是加在某一个数据对象上的。</p></li></ul><p>【封锁粒度】</p><p>封锁对象可以很大也可以很小，例如对整个数据库加锁、对某个属性值加锁。</p><p><strong>封锁对象的大小称为封锁的粒度。</strong></p><p>封锁的粒度越大，系统中能够被封锁的对象就越少，并发度也就越小，但系统开销也越小；</p><p>封锁的粒度越小，并发度越高，但开销也就越大。</p><p>【封锁协议】</p><ul><li>一级封锁协议：当T1修改数据时，加X锁，直到事务结束后释放X锁</li><li>二级封锁协议：在一级封锁协议基础上，当T1读取数据时，加S锁，读完马上释放S锁</li><li>三级：在二级基础上，当T1读取数据时，加S锁，等T1事务完全结束时释放S锁</li><li>两端锁协议：事务分为<strong>加锁</strong>和<strong>解锁</strong>阶段，事务开始处于加锁阶段，直到遇到<code>commit</code>或<code>rollback</code>才使事务进入解锁阶段</li></ul><p>7、ER图</p><p><code>Entity Relationship Diagram</code> 实体-联系图，提供了表示<strong>实体类型、属性和联系</strong>的方法，用来描述现实世界的概念模型</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png" alt="ER图示例"></p><ul><li>实体：矩形表示，内部写实体名</li><li>属性：椭圆形表示，并用无向边将其与相应实体连接起来</li><li>联系：菱形表示，内部写联系名称，并在无向边中两侧指明哪种关系</li></ul><p>关系模式：一对一，一对多，多对多</p><p>8、三级模式</p><ul><li><p>外模式 ：又称<strong>子模式</strong>，是数据库<strong>用户可以看到和使用</strong>的局部数据的<strong>逻辑结构和特征描述</strong>，是数据库用户的<strong>数据视图</strong>，外模式是模式的子集，一个数据库可以有多个外模式</p></li><li><p>模式 ：<strong>概念模式</strong>，数据库中<strong>全体数据</strong>的逻辑结构和特征描述，是所有用户的<strong>公共视图</strong>，一个数据库只有一个模式</p></li><li><p>内模式 ：<strong>存储模式</strong>，是数据库物理结构和存储方式的描述，是数据在数据库内的<strong>组织方式</strong></p></li></ul><p>9、数据库的二级映像功能和数据独立性</p><p>外模式/内模式  和  模式/内模式</p><ul><li>逻辑独立性</li></ul><p>​      由<strong>外模式/模式</strong>映像保证的，当模式发生改变时，DBA对外模式/模式的映射做出向相应改变，使外模式保持不变，保证了数据的逻辑独立性</p><ul><li>物理独立性</li></ul><p>​     由<strong>模式/内模式</strong>映像保证，当数据库存储结构发生变化时，DBA对模式/内模式映射做出改变，使得模式不变，保证了数据的物理独立性</p><p>10、关系，关系模式，关系数据库</p><ul><li><p>关系： 是关系模式在<strong>某一时刻</strong>的状况，关系是<strong>动态的，不稳定的</strong>，随时间变化而变化的</p></li><li><p>关系模式： 是静态的，稳定的</p></li><li><p>关系数据库：是建立在关系模式的基础上，利用关系来描述现实世界</p></li></ul><p>11、查询优化的策略</p><ul><li>如果子表达式多次出现，先将其<strong>计算结果保存起来</strong>，避免重复计算</li><li><strong>选择运算</strong>尽量先做</li><li>尽可能指明展示列，少用<code>*</code>代替</li><li>避免在列索引上使用<code>IS NULL</code> 和 <code>IS NOT NULL</code></li></ul><p>12、数据字典</p><p>数据字典是<strong>对数据表中数据元素的定义和描述</strong>，目的是对数据流程图中的各个元素进行详细的说明</p><p>数据字典和数据流程图 共同构成了系统的逻辑模型</p><p>13、数据库故障恢复策略</p><ul><li>事务故障恢复： 由<strong>系统自动完成</strong>，反向扫描日志，对事务更新操作执行逆操作</li><li>系统故障恢复：由系统<strong>重启时</strong>自动完成，正向扫描日志，记录<code>REDO</code>队列和<code>UNDO</code>队列，对UNDO队列进行撤销处理，对REDO队列进行重做处理</li><li>介质故障恢复：重装后援副本 + REDO + UNDO</li><li>登记日志文件原则<ul><li>登记次序严格按照并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql基础"><a href="#mysql基础" class="headerlink" title="mysql基础"></a>mysql基础</h1><h2 id="SQL如何执行"><a href="#SQL如何执行" class="headerlink" title="SQL如何执行"></a>SQL如何执行</h2><p>Mysql是<code>C/S</code>架构，服务器端程序使用的 <code>mysqld</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203290858615.png" alt="image-20220329085801498"></p><ul><li>连接层: 客户端和服务器端建立连接，客户端发送 SQL 至服务器端</li><li>SQL层 ： 对sql语句进行查询处理</li><li>存储引擎层：与<strong>数据库文件</strong>打交道，负责数据的存储和读取,<code>MySQL5.5.5</code> 版本开始默认的是<code>InnoDB</code></li></ul><p><strong>SQL层结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203290900503.png" alt="image-20220329090004464"></p><blockquote><p> SQL 语句→缓存查询→解析器→优化器→执行器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203290909915.png" alt="image-20220329090922855"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.二叉树</title>
    <link href="/2022/03/28/3%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/28/3%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><img src="https://pic1.zhimg.com/80/v2-00eb0b393ef3b9d629d823807980f8e8_720w.jpg" alt="img"></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>树的结点（node）：包含一个数据元素及若干指向子树的分支；</li><li>孩子结点（child node）：结点的子树的根称为该结点的孩子；</li><li>双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；</li><li>兄弟结点：同一双亲的孩子结点；堂兄结点：同一层上结点；</li><li>祖先结点: 从根到该结点的所经分支上的所有结点</li><li>子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙</li><li>结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；</li><li><strong>树的深度：树中最大的结点层</strong></li><li>结点的度：结点子树的个数</li><li><strong>树的度：树中最大的结点度。</strong></li><li>叶子结点：也叫终端结点，是度为 0 的结点；</li><li>分枝结点：度不为0的结点；</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>在二叉树中，第 <code>i</code> 层上至多有<code>2^(i-1)</code>个节点（<code>i ≥ 1</code>）</li><li>深度为<code>k</code>的二叉树至多有<code>2^(k−1)</code>个节点（<code>k≥1</code>）</li><li>对一棵二叉树，如果叶子节点的个数为<code>n0</code>，度为2的节点个数为<code>n2</code>，则<code>n0=n2+1</code></li><li>具有<code>n</code>个节点的完全二叉树的深度为<code>⌊log2n⌋+1</code></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="hljs c"><span class="hljs-comment">//节点的定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span>&#125;Node;<span class="hljs-comment">//树定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span> &#123;</span>    Node *root;    <span class="hljs-keyword">int</span> n; <span class="hljs-comment">//代表多少个结点</span>&#125;Tree;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs c"><span class="hljs-comment">//结点初始化</span><span class="hljs-function">Node *<span class="hljs-title">getNewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;    Node *p = (Node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));    p-&gt;val = val;    p-&gt;lchild = p-&gt;rchild = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//树初始化</span><span class="hljs-function">Tree *<span class="hljs-title">getNewTree</span><span class="hljs-params">()</span> </span>&#123;    Tree *tree = (Tree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Tree));    tree-&gt;n = <span class="hljs-number">0</span>;    tree-&gt;root = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> tree;&#125;</code></pre><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><pre><code class="hljs c"><span class="hljs-comment">//销毁节点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearNode</span><span class="hljs-params">(Node *node)</span> </span>&#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    clearNode(node-&gt;lchild);    claerNode(node-&gt;rchild);    <span class="hljs-built_in">free</span>(node);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//销毁树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearTree</span><span class="hljs-params">(Tree *tree)</span> </span>&#123;    clearNode(tree-&gt;root);    <span class="hljs-built_in">free</span>(tree);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs c"><span class="hljs-comment">//输出节点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outputNode</span><span class="hljs-params">(Node *node)</span> </span>&#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,node-&gt;val);    <span class="hljs-keyword">if</span> (node-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;rchild == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ( &quot;</span>);    outputNode(node-&gt;lchild);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;,&quot;</span>);    outputNode(node-&gt;rchild);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; )&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//将树转为广义表输出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outputTree</span><span class="hljs-params">(Tree *tree)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tree(%d) = &quot;</span>,tree-&gt;n);    outputNode(tree-&gt;root);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>插入后，树的节点肯定增加，故要利用传出参数</p><pre><code class="hljs c"><span class="hljs-comment">//插入节点,ret为传出参数</span><span class="hljs-function">Node *<span class="hljs-title">insertNode</span><span class="hljs-params">(Node *root,<span class="hljs-keyword">int</span> val,<span class="hljs-keyword">int</span> *ret)</span> </span>&#123;    <span class="hljs-comment">//若为空，创建新节点</span>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;        *ret = <span class="hljs-number">1</span>; <span class="hljs-comment">//为1代表插入成功</span>        <span class="hljs-keyword">return</span> getNewNode(val); <span class="hljs-comment">//创建节点</span>    &#125;    <span class="hljs-keyword">if</span> (root-&gt;val == val) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;lchild = insertNode(root-&gt;lchild,val,ret);    <span class="hljs-keyword">else</span> root-&gt;rchild = insertNode(root-&gt;rchild,val,ret);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-comment">//在树中进行插入,即二叉排序树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Tree *tree,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//标志位，开始为0，若成功，则将传出参数为1带回，然后自增！</span>    tree-&gt;root = insertNode(tree-&gt;root,val,&amp;flag);    tree-&gt;n += flag;<span class="hljs-comment">//将树中结点数目进行更新</span>    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><pre><code class="hljs c"><span class="hljs-comment">//前序遍历</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderNode</span><span class="hljs-params">(Node *pNode)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pNode == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,pNode-&gt;val);    preOrderNode(pNode-&gt;lchild);    preOrderNode(pNode-&gt;rchild);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Tree *pTree)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;preOrder: &quot;</span> );    preOrderNode(pTree-&gt;root);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//中序遍历</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderNode</span><span class="hljs-params">(Node *pNode)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pNode == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    inOrderNode(pNode-&gt;lchild);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,pNode-&gt;val);    inOrderNode(pNode-&gt;rchild);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Tree *pTree)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;inOrder: &quot;</span> );    inOrderNode(pTree-&gt;root);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//后序遍历</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrderNode</span><span class="hljs-params">(Node *pNode)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pNode ==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    postOrderNode(pNode-&gt;lchild);    postOrderNode(pNode-&gt;rchild);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,pNode-&gt;val);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Tree *pTree)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;postOrder: &quot;</span> );    postOrderNode(pTree-&gt;root);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));    Tree *tree = getNewTree(); <span class="hljs-comment">//初始化树</span>    <span class="hljs-comment">//共五个节点，利用随机数生成</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++) &#123;        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;        insert(tree,val); <span class="hljs-comment">//插入节点</span>        outputTree(tree);    &#125;    preOrder(tree); <span class="hljs-comment">//前序</span>    inOrder(tree); <span class="hljs-comment">//中序</span>    postOrder(tree); <span class="hljs-comment">//后序</span>    clearTree(tree); <span class="hljs-comment">//销毁</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203291011528.png" alt="image-20220329101143472"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子数组和</title>
    <link href="/2022/03/25/leetcode11/"/>
    <url>/2022/03/25/leetcode11/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>​     给你一个整数数组 nums ，请你找出一个具有<strong>最大和的连续子数组</strong>（子数组最少包含一个元素），返回其<strong>最大和</strong>。子数组 是数组中的一个连续部分。</p></blockquote><p>示例 1：</p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p>示例 2：</p><p>输入：nums = [1]<br>输出：1</p><p>示例 3：</p><p>输入：nums = [5,4,-1,7,8]<br>输出：23</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="1-暴力算法"><a href="#1-暴力算法" class="headerlink" title="1.暴力算法"></a>1.暴力算法</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">//定义一个最小值,因为要找最大值,暂存结果;</span>        <span class="hljs-keyword">int</span> result = Integer.MIN_VALUE,sum;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; num.length; i++) &#123;            sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; num.length;j++) &#123;                sum += nums[j];<span class="hljs-comment">//进行累计求和</span>                result = sum &gt; result ? sum : result; <span class="hljs-comment">//是否更新结果</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>此方法和<code>209.长度最小的子数组</code> 很类似</p><blockquote><p>时间复杂度O(n^2) ，太高了！！</p></blockquote><h2 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2.贪心"></a>2.贪心</h2><p>负数只会降低总和，若连续和为负数，则立马重新计算，即让<code>sum=0</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> result = Integer.MIN_VALUE,sum = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            sum += nums[i];            <span class="hljs-comment">//取区间累计的最大值</span>            <span class="hljs-keyword">if</span> (sum &gt; result) result = sum;            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h2><ul><li>确定dp数组以及下标的含义<ul><li>dp[i] ==&gt; i之前的最大连续子序列和</li></ul></li><li>确定递推公式<ul><li><code>dp[i] = max(dp[i - 1]+nums[i],nums[i])</code> </li></ul></li><li>初始化dp</li><li>确定遍历顺序</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,result;        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length]; <span class="hljs-comment">//定义新的dp数组</span>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        result = dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            dp[i] = Math.max(nums[i],dp[i-<span class="hljs-number">1</span>] + nums[i]);<span class="hljs-comment">//递推公式</span>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>或者</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> result = nums[<span class="hljs-number">0</span>], sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">//当和大于0时，才进行求和</span>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) sum += nums[i];            <span class="hljs-keyword">else</span> sum = nums[i]; <span class="hljs-comment">//否则赋值，准备下次重新加和</span>            result = Math.max(sum, result);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.单调队列和单调栈</title>
    <link href="/2022/03/25/6%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2022/03/25/6%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>单调队列：具有<strong>单调性</strong>的队列，用于求某区间<strong>最大或者最小值</strong></p><ul><li><strong>单调递增队列</strong>：保证<strong>队头</strong>元素一定是当前队列的最小值，用于维护区间的最小值。</li><li><strong>单调递减队列</strong>：保证<strong>队头元素</strong>一定是当前队列的最大值，用于维护区间的最大值。</li></ul><p><strong>单调队列</strong>是一种主要用于解决<strong>滑动窗口</strong>类问题的数据结构</p><blockquote><p>原理：**<em>如果一个选手比你小还比你强，你就可以退役了**</em></p></blockquote><p>例：<code>6 3 2 5 4 1 7 4 2 3</code>  </p><p>要维护 <strong>区间长度为3</strong> 的最大值,<strong>单调递减</strong></p><table><thead><tr><th align="left">操作</th><th align="left">队列状态</th><th></th></tr></thead><tbody><tr><td align="left">6 入队</td><td align="left"><code>&#123;6&#125;</code></td><td>区间长度 &lt; 3</td></tr><tr><td align="left">3入队</td><td align="left"><code>&#123;6 3&#125;</code></td><td>区间长度 &lt; 3</td></tr><tr><td align="left">2入队</td><td align="left"><code>&#123;6 3 2&#125;</code></td><td>最大为6</td></tr><tr><td align="left">5要入队，6出去，同时3,2比5小，同样出去</td><td align="left"><code>&#123;5&#125;</code></td><td>最大为5</td></tr><tr><td align="left">4入队</td><td align="left"><code>&#123;5 4&#125;</code></td><td>最大为5</td></tr><tr><td align="left">1入队</td><td align="left"><code>&#123;5 4 1&#125;</code></td><td>最大为5</td></tr><tr><td align="left">7入队，前面的都出去了</td><td align="left"><code>&#123;7&#125;</code></td><td>最大为7</td></tr><tr><td align="left">4入队</td><td align="left"><code>&#123;7 4&#125;</code></td><td>最大为7</td></tr><tr><td align="left">2入队</td><td align="left"><code>&#123;7 4 2&#125;</code></td><td>最大为7</td></tr><tr><td align="left">3入队，7和2都出去(7超范围，3大于2)</td><td align="left"><code>&#123;4 3&#125;</code></td><td>最大为4</td></tr></tbody></table><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>最大子序和</strong></p><blockquote><p> 输入一个长度为<code>n</code>的整数序列，从中找到一段<strong>不超过</strong><code>M</code>的<strong>连续子序列</strong>，使得序列和最大</p></blockquote><p><strong>输入：</strong></p><ul><li>第一行两个数:  n  m</li><li>第二行有n个数，要求在n个数中找到最大子序和</li></ul><p>输出：</p><ul><li>一个数，表示找到的最大和</li></ul><p>如：</p><pre><code class="hljs shell">1 -3 5 1 -2 3当m = 4 ==&gt; sum = 5 + 1 + -2 + 3  = 7当n = 2 或 m=3 时==&gt; sum = 5 + 1 = 7输入：6 41 -3 5 1 -2 3输出7</code></pre><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>维护最近(大于/小于)关系</strong></p><ul><li>单调递增栈：只有比<strong>栈顶小</strong>的才能入栈，否则就把栈顶出栈后，再入栈。出栈时可能会有一些计算。<ul><li>适用于求解第一个大于该位置元素的数。</li></ul></li><li>单调递减栈：与单调递增栈相反。<ul><li>适用于求解第一个小于该位置元素的数。</li></ul></li></ul><p>要求每次<strong>入栈的元素必须要有序</strong>，使之形成单调递增/单调递减的一个栈</p><p>（如果新元素入栈不符合要求，则将之前的元素出栈，直到符合要求再入栈）</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>209.长度最小的子数组</title>
    <link href="/2022/03/24/leetcode10/"/>
    <url>/2022/03/24/leetcode10/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个含有 <strong>n 个正整数</strong>的数组和一个<strong>正整数 target</strong> 。 </p><p>找出该数组中满足其和 ≥ target 的<strong>长度最小的 连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 </p></blockquote><pre><code class="hljs shell">示例 1：输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。示例 2：输入：target = 4, nums = [1,4,4]输出：1示例 3：输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1.暴力求解"></a>1.暴力求解</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">//result 用一个大的值，暂存,因为是要找最小的，sublen子序列长度</span>        <span class="hljs-keyword">int</span> result = nums.length + <span class="hljs-number">1</span>,sum,sublen = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++) &#123;            sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; nums.length;j++) &#123;                sum += nums[j];                <span class="hljs-comment">//若子序列超过了目标值，更新result</span>                <span class="hljs-keyword">if</span> ( sum &gt;= target) &#123;                    sublen = j - i + <span class="hljs-number">1</span>;                    result = (sublen &gt; result ? result : sublen);                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找的最小，一找到直接break</span>                &#125;            &#125;        &#125;        <span class="hljs-comment">// 如果result没被更新的话，就返回0，说明没有符合条件的子序列</span>        <span class="hljs-keyword">return</span> result == nums.length + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : result;    &#125;&#125;</code></pre><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h2><p>就是不断的调节子序列的<strong>起始位置和终止位置</strong>，从而得出我们要想的结果。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> result = nums.length + <span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>,sublen = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; <span class="hljs-comment">//j为滑动窗口的起始位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++) &#123;            sum += nums[i];<span class="hljs-comment">//得到子序列和</span>            <span class="hljs-keyword">while</span> ( target &lt;= sum ) &#123;                sublen = i - j + <span class="hljs-number">1</span>;                result = result &lt; sublen ? result : sublen;                sum -= nums[j ++]; <span class="hljs-comment">//不断变更起始位置 （关键）</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> result == nums.length + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.队列和栈</title>
    <link href="/2022/03/24/2%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <url>/2022/03/24/2%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> &#123;</span>    <span class="hljs-keyword">int</span> *data;<span class="hljs-comment">//数据域</span>    <span class="hljs-keyword">int</span> head,tail;<span class="hljs-comment">//指向队头和队尾</span>    <span class="hljs-keyword">int</span> length; <span class="hljs-comment">//队列的 长度</span>    <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//使其变为循环队列</span>&#125;Queue;</code></pre><h2 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h2><pre><code class="hljs c"><span class="hljs-comment">//初始化长度为n的队列</span><span class="hljs-function">Queue *<span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span> </span>&#123;    Queue *q = (Queue*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Queue));    q-&gt;data = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    q-&gt;head = q-&gt;tail = q-&gt;count = <span class="hljs-number">0</span>;    q-&gt;length = n;    <span class="hljs-keyword">return</span> q;&#125;<span class="hljs-comment">//销毁队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Queue *q)</span> </span>&#123;    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">free</span> (q-&gt;data);    <span class="hljs-built_in">free</span> (q);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="判空和获得队首元素"><a href="#判空和获得队首元素" class="headerlink" title="判空和获得队首元素"></a>判空和获得队首元素</h2><pre><code class="hljs c"><span class="hljs-comment">//判断队列是否为空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empyt</span><span class="hljs-params">(Queue *q)</span> </span>&#123;    <span class="hljs-keyword">return</span> q-&gt;count == <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//返回队首元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">(Queue *q)</span> </span>&#123;    <span class="hljs-keyword">return</span> q-&gt;data[q-&gt;head];&#125;</code></pre><h2 id="入队和出队"><a href="#入队和出队" class="headerlink" title="入队和出队"></a>入队和出队</h2><pre><code class="hljs c"><span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(Queue *q,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-comment">//若q为空指针或者队列满了，则直接返回</span>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span> || q-&gt;count == q-&gt;length ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    q-&gt;data[q-&gt;tail ++] = val; <span class="hljs-comment">//入队</span>    <span class="hljs-comment">//循环队列操作，使得尾指向头</span>    <span class="hljs-keyword">if</span>( q-&gt;tail == q-&gt;length ) q-&gt;tail -= q-&gt;length;    q-&gt;count ++;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//出队</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(Queue*q)</span> </span>&#123;    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span> || empyt(q) ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    q-&gt;head ++;    <span class="hljs-keyword">if</span> (q-&gt;head == q-&gt;length) q-&gt;head -= q-&gt;length;    q-&gt;count ++;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs c"><span class="hljs-comment">//输出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Queue *q)</span> </span>&#123;    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue = [&quot;</span>);    <span class="hljs-comment">//从头部指向的位置输出，不是从第0元素开始输出</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = q-&gt;head,j = <span class="hljs-number">0</span>; j &lt; q-&gt;count; j++) &#123;        <span class="hljs-comment">//当前元素坐标</span>        <span class="hljs-keyword">int</span> index = (i + j) % q-&gt;length; <span class="hljs-comment">//获得下标</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, q-&gt;data[index]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ]\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_OP 10</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>));    Queue *q = init(MAX_OP);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP;i++) &#123;        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;        <span class="hljs-keyword">int</span> op = rand() % <span class="hljs-number">2</span>;        <span class="hljs-keyword">switch</span> (op) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enQueue %d to queue = %d\n&quot;</span>,val,enQueue(q,val));            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123; <span class="hljs-comment">//获得队首值,临时保存，如果放到printf里，会从右向左打印,导致已经出队了，再打印队中首元素</span>                <span class="hljs-keyword">int</span> head_val = front(q);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;deQueue %d from queue = %d\n&quot;</span>,head_val,deQueue(q));            &#125;                <span class="hljs-keyword">break</span>;        &#125;        output(q);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-comment">//查看一系列操作后，头指针和尾指针</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;head : %d, tail: %d, count : %d\n&quot;</span>,q-&gt;head,q-&gt;tail,q-&gt;count);    <span class="hljs-comment">//测试是否可以进行循环，再进行插入十个值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP;i++) &#123;        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enQueue %d to queue = %d\n&quot;</span>,val,enQueue(q,val));    &#125;    output(q);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203241635515.png" alt="image-20220324163542402"></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203241635451.png" alt="image-20220324163559414"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  MAX_OP 20 <span class="hljs-comment">//执行20次操作</span></span><span class="hljs-comment">//定义栈的结构</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span>    <span class="hljs-keyword">int</span> *data;    <span class="hljs-keyword">int</span> top,size;&#125;Stack;<span class="hljs-comment">//初始化</span><span class="hljs-function">Stack *<span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    Stack *s = (Stack*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));    s-&gt;data = (<span class="hljs-keyword">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * n);    s-&gt;size = n;    s-&gt;top = <span class="hljs-number">-1</span>; <span class="hljs-comment">//开始top为-1，代表栈空</span>    <span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">//销毁栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Stack*s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">free</span>(s-&gt;data);    <span class="hljs-built_in">free</span>(s);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//判空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(Stack *s)</span> </span>&#123;    <span class="hljs-keyword">return</span> s-&gt;top == <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//查看栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack *s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (empty(s)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> s-&gt;data[s-&gt;top];&#125;<span class="hljs-comment">//入栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *s,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-comment">//若栈为空指针或栈已满，这直接返回</span>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span> || s-&gt;top + <span class="hljs-number">1</span> == s-&gt;size) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    s-&gt;data[ ++ s-&gt;top] = val;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *s)</span> </span>&#123;    <span class="hljs-comment">//若栈指针为空或栈里面没有元素</span>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span> || empty(s)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    s-&gt;top -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//输出栈中元素</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Stack *s)</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; stack(%d) = [&quot;</span>,s-&gt;top + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s-&gt;top; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,s-&gt;data[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ]\n&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//测试</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//随机数种子，若没有，则运行将每次都一样，而用时间作为种子，使得每次均不同</span>    srand(time(<span class="hljs-number">0</span>));    Stack *s = init(MAX_OP);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP; i++) &#123;        <span class="hljs-keyword">int</span> op = rand() % <span class="hljs-number">2</span>, val = rand() % <span class="hljs-number">100</span>;        <span class="hljs-keyword">switch</span> (op) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;push %d to stack = %d\n&quot;</span>,val,push(s,val));            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;                <span class="hljs-keyword">int</span> top_val = top(s);<span class="hljs-comment">//和队列操作类似，临时保存</span>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pop %d from stack = %d\n&quot;</span>,top_val,pop(s));            &#125;                <span class="hljs-keyword">break</span>;        &#125;        output(s);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203241639553.png" alt="image-20220324163943506"></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203241640008.png" alt="image-20220324164003969"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.有效的括号</title>
    <link href="/2022/03/23/leetcode09/"/>
    <url>/2022/03/23/leetcode09/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，<strong>判断字符串是否有效</strong>。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul></blockquote><pre><code class="hljs shell">示例 1：输入：s = &quot;()&quot;输出：true示例 2：输入：s = &quot;()[]&#123;&#125;&quot;输出：true示例 3：输入：s = &quot;(]&quot;输出：false示例 4：输入：s = &quot;([)]&quot;输出：false示例 5：输入：s = &quot;&#123;[]&#125;&quot;输出：true</code></pre><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 仅由括号 ‘()[]{}’ 组成    </li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>如果只有一种括号，怎么做？</li><li>用栈？ 在简化问题中，能不能不用栈？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203231502612.png" alt="image-20220323150230545"></p><p> <strong>任意位置右括号数量应 <code>&lt;=</code> 左括号数量 且 最终位置 右 <code>==</code> 左</strong></p><p>此时简化问题，故只需统计左右括号数量即可</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">int</span> lnum = <span class="hljs-number">0</span>,rnum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;        <span class="hljs-keyword">switch</span> (s[i])&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: ++lnum;<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: ++rnum;<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (lnum &gt;= rnum) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> lnum == rnum;&#125;</code></pre><p>这里 <code>rnum</code> 变量 可以不需要，进行优化</p><ul><li>碰到左括号 <code>+ 1</code> ，碰到右括号 <code>-1</code> ===&gt; <strong>这就是栈呀！！！ <code>lnum</code>就是栈顶指针，+1代表入栈，-1代表出栈</strong></li></ul><p>即栈可以处理具有<strong>完全包含关系</strong>的问题</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203231532815.png" alt="image-20220323153258704"></p><p><strong>解法</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">//声明一个stack</span>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();        <span class="hljs-comment">// 遍历s中所有的字符</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">&#x27;(&#x27;</span>) stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( stack.isEmpty() || c != stack.pop()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre><blockquote><p>Java语言为内置数据类型char提供了<strong>包装类Character</strong>类。</p></blockquote><p>三种情况:</p><ul><li>已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</li><li>遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</li><li>遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</li></ul><p><strong>如图所示</strong><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.顺序表和链表</title>
    <link href="/2022/03/18/1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/03/18/1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p> <strong>C语言实现数据结构</strong></p></blockquote><p>C语言阶段：</p><ul><li>基本语法(if while for switch …..)</li><li>指针  &lt;===&gt;  内存模型</li><li>C实现各种数据结构</li></ul><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> </span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> *data; <span class="hljs-comment">//数据域</span>    <span class="hljs-keyword">int</span> size,length; <span class="hljs-comment">//线性表总大小和当前的长度</span>&#125;Vector;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><span class="hljs-function"></span>&#123;    Vector *vec = (Vector*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Vector)); <span class="hljs-comment">//开辟结构新的空间</span>    vec-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * n); <span class="hljs-comment">//数据域开辟空间</span>    vec-&gt;size = n;    vec-&gt;length = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> vec;&#125;</code></pre><h2 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a><strong>增加</strong>元素</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Vector *vec,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> value)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//条件判断，若线性表为空或位置不符，则直接return</span>    <span class="hljs-keyword">if</span> (vec == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; vec-&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//若线性表长度达到总长度，则进行扩容操作</span>    <span class="hljs-keyword">if</span> (vec-&gt;length == vec-&gt;size)    &#123;        <span class="hljs-comment">//扩容失败，直接返回</span>        <span class="hljs-keyword">if</span> (! expand(vec)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;expand vector size to %d suceess\n&quot;</span>,vec-&gt;size);    &#125;    <span class="hljs-comment">//插入逻辑</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = vec-&gt;length;i &gt; index;i--)    &#123;        vec-&gt;data[i] = vec-&gt;data[i<span class="hljs-number">-1</span>];    &#125;    vec-&gt;data[index] = value;<span class="hljs-comment">//将值进行插入</span>    vec-&gt;length ++; <span class="hljs-comment">//线性表长度要+1 (别忘记</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//扩容操作</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(Vector *vec)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> new_size = vec-&gt;size * <span class="hljs-number">2</span>;<span class="hljs-comment">//进行二倍扩容</span>    <span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(vec-&gt;data,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * new_size);<span class="hljs-comment">//重新申请空间</span>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//扩容失败</span>    vec-&gt;size = new_size;    vec-&gt;data = p;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>realloc</p><blockquote><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">realloc</span><span class="hljs-params">( <span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size )</span></span>;</code></pre><p>函数将<em>ptr</em>  对象的储存空间<strong>改变为给定的大小<em>size</em></strong>。 参数<em>size</em>可以是任意大小，大于或小于原尺寸都可以。  返回值是指向新空间的指针，如果错误发生返回NULL</p></blockquote><p>试着在原先的基础先进行扩容，若成功，返回之前那个区域的首地址</p><p>若失败，则会调用<code>malloc</code>，另外申请一片空间，并把之前数据拷贝，返回新的首地址，并释放之前的空间</p><p>所以不可以像下面这样写</p><pre><code class="hljs c">vec-&gt;size *= <span class="hljs-number">2</span>;vec-&gt;data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(vec-&gt;data,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * size);</code></pre><p>若返回空地址，则之前的内容丢失了，因为被赋值为<code>NULL</code></p><p>即造成<strong>内存泄漏</strong> ==&gt; 你开辟的这个空间，但是你用不了了，把内存信息丢失了</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除</strong>元素</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Vector *vec,<span class="hljs-keyword">int</span> index)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//正确性检查</span>    <span class="hljs-keyword">if</span> (vec == <span class="hljs-literal">NULL</span> || vec-&gt;length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= vec-&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//删除</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index + <span class="hljs-number">1</span>;i &lt; vec-&gt;length; i++)    &#123;        vec-&gt;data[i - <span class="hljs-number">1</span>] = vec-&gt;data[i];    &#125;    vec-&gt;length --;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="销毁线性表"><a href="#销毁线性表" class="headerlink" title="销毁线性表"></a>销毁线性表</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Vector *vec)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (vec == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">free</span>(vec-&gt;data); <span class="hljs-comment">//释放数据域</span>    <span class="hljs-built_in">free</span>(vec); <span class="hljs-comment">//释放整个结构体</span>&#125;</code></pre><h2 id="输出线性表"><a href="#输出线性表" class="headerlink" title="输出线性表"></a>输出线性表</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Vector *vec)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Vector(%d) = [&quot;</span>, vec-&gt;length);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec-&gt;length;i++ ) &#123;        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, &quot;</span>); <span class="hljs-comment">// 进行分隔</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,vec-&gt;data[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;]\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_OP 20 <span class="hljs-comment">//执行二十次操作 (增or删)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(time(<span class="hljs-number">0</span>)); <span class="hljs-comment">//随机数种子，让其随机产生数字</span>    Vector *vec = init(<span class="hljs-number">1</span>); <span class="hljs-comment">//让线性表初始最大为1</span>    <span class="hljs-keyword">int</span> op,ind,val;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP;i++) &#123;        op = rand() % <span class="hljs-number">4</span>; <span class="hljs-comment">//op表示增还是删的概率，让增加概率为3/4,删1/4</span>        ind = rand() % (vec-&gt;length + <span class="hljs-number">3</span>); <span class="hljs-comment">//索引的位置,随机产生</span>        val = rand() % <span class="hljs-number">100</span>; <span class="hljs-comment">//产生1-100的数字</span>        <span class="hljs-keyword">switch</span> (op) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;insert %d at %d to vector = %d\n&quot;</span>,                       val, ind, insert(vec, ind, val));            &#125;            <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;delete item at %d from vector = %d\n&quot;</span>,                       ind, <span class="hljs-keyword">delete</span>(vec, ind));            &#125;            <span class="hljs-keyword">break</span>;        &#125;        output(vec);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;&#125;</code></pre><p>结果如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203231450915.png" alt="image-20220323145053869"></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203231452456.png" alt="image-20220323145255413"></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><pre><code class="hljs C"><span class="hljs-comment">//链表节点定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span>    <span class="hljs-keyword">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">next</span>;</span>&#125; ListNode;<span class="hljs-comment">//整个链表定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkList</span> &#123;</span>    <span class="hljs-comment">//此处为虚拟头节点,不存数据，下一个才代表序号0，开始存数据</span>    ListNode head;    <span class="hljs-keyword">int</span> length;&#125;LinkList;</code></pre><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs c"><span class="hljs-comment">//初始化结点</span><span class="hljs-function">ListNode *<span class="hljs-title">init_listNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;    ListNode *p = (ListNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ListNode));    p-&gt;data = val;    p-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//初始化整个链表</span><span class="hljs-function">LinkList *<span class="hljs-title">init_linkList</span><span class="hljs-params">()</span> </span>&#123;    LinkList *l = (LinkList*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkList));    l-&gt;head.next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//此时l-&gt;head为ListNode的变量,而非地址,故需要指向next才可</span>    l-&gt;length = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> l;&#125;</code></pre><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><pre><code class="hljs c"><span class="hljs-comment">//销毁链表结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear_listNode</span><span class="hljs-params">(ListNode *p)</span> </span>&#123;    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">free</span>(p);    <span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//销毁整个链表</span><span class="hljs-keyword">void</span> clear_linkList(LinkList* l) &#123;    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//销毁每一个结点</span>    ListNode *p = l-&gt;head.next,*q;    <span class="hljs-keyword">while</span> (p) &#123;        q = p-&gt;next;        clear_listNode(p);        p = q;    &#125;    <span class="hljs-built_in">free</span>(l);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>在<code>l</code> 链表中，<code>index</code>的位置，插入<code>value</code>值</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(LinkList *l,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-comment">//合法性判断，链表为空或者插入不合法直接返回0</span>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; l-&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//插入操作</span>    ListNode *p = &amp;(l-&gt;head),*new_node = init_listNode(value);    <span class="hljs-comment">//找到位置</span>    <span class="hljs-comment">//因为有虚拟头节点的存在，index为几，则p向后走几步，则找到了要操作的前一个位置</span>    <span class="hljs-keyword">while</span> (index --) &#123;        p = p-&gt;next;    &#125;    new_node-&gt;next = p-&gt;next;    p-&gt;next = new_node;    l-&gt;length ++;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(LinkList *l,<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= l-&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    ListNode *p = &amp;(l-&gt;head),*q;    <span class="hljs-keyword">while</span>( index --) &#123;        p = p-&gt;next;    &#125;    q = p-&gt;next;    p-&gt;next = q-&gt;next;    clear_listNode(q);      <span class="hljs-comment">/* 或</span><span class="hljs-comment">    * q = p-&gt;next-&gt;next;</span><span class="hljs-comment">    * clear_listNode(p-&gt;next);</span><span class="hljs-comment">    * p-&gt;next = q;</span><span class="hljs-comment">    * */</span>    l-&gt;length --;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(LinkList *l)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ListList(%d) : &quot;</span>,l-&gt;length);    <span class="hljs-keyword">for</span> (ListNode *p = l-&gt;head.next; p!= <span class="hljs-literal">NULL</span>; p = p-&gt;next) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d -&gt; &quot;</span>,p-&gt;data);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL\n&quot;</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="main测试-1"><a href="#main测试-1" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MAX_OP 10</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    srand(time(<span class="hljs-number">0</span>)); <span class="hljs-comment">//随机生成操作</span>    LinkList *l = init_linkList();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_OP; i++) &#123;        <span class="hljs-keyword">int</span> op = rand() % <span class="hljs-number">3</span>; <span class="hljs-comment">// ==&gt; 插入概率2/3 ,删除1/3</span>        <span class="hljs-keyword">int</span> ind = rand() % (l-&gt;length + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> val = rand() % <span class="hljs-number">100</span>;        <span class="hljs-keyword">switch</span> (op) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:&#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;insert %d at %d to Linklist = %d\n&quot;</span>,                        val,ind,insert(l,ind,val));            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;delete item at %d from Linklist = %d\n&quot;</span>,                        ind,<span class="hljs-keyword">delete</span>(l,ind));            &#125;                <span class="hljs-keyword">break</span>;        &#125;        output(l);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    clear_linkList(l);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203231448036.png" alt="image-20220323144759877"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>顺序表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>路由器和交换机、集线器</strong></p><p>起初通信，可以两个主机进行相连，但又加入小伙伴了怎么办？</p><p>单独找个机器，多设计几个网口，我们都连接在上面，此时我们都可以进行通信了，即是集线器</p><ul><li>集线器起到了一个<strong>将网线集结起来</strong>的作用，实现最初级的网络互通。集线器是通过网线<strong>直接</strong>传送数据的，我们说他工作在<strong>物理层</strong>。各设备处在同一冲突域内，即处在其中的一台发送数据，通过集线器连接的主机全部都接收到了</li></ul><p>现在基于以上，如何解决存在的问题？</p><p>我们给这台设备加入一个<strong>指令</strong>，让他可以根据网口名称<strong>自动寻址传输数据</strong>，即解决冲突问题，此时就实现了<strong>任意两台</strong>电脑间的互联，我们就将其称为<strong>交换机</strong>，工作在<strong>数据链路层</strong>，根据mac地址进行转发</p><ul><li>交换机（Switch）意为“<a href="https://baike.baidu.com/item/%E5%BC%80%E5%85%B3/2275072">开关</a>”是一种用于电（光）信号转发的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/7667828">网络设备</a>。它可以为接入交换机的任意两个<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9/9338583">网络节点</a>提供独享的电信号通路</li></ul><p>再基于以上，若要和<strong>不同区域</strong>的进行通信，如何办？</p><p>由于可能机子的操作系统不同，我们需要公共采用<strong>同样的信息</strong>传送形式，在各自操作系统上再加上一套<strong>协议</strong>，不同地域通信时，信息经协议加工成<strong>统一形式</strong>，再经由一个特殊的设备传送出去。这个设备就叫做<strong>路由器</strong></p><ul><li>路由器通过IP地址寻址，我们说它工作在计算机的<strong>网络层</strong></li></ul><blockquote><p>交换机适合局域网内互联，路由器实现全网段互联。</p></blockquote><p>我们家庭的那个”猫”是干嘛的？</p><p>它叫<a href="https://www.zhihu.com/search?q=%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:402261894%7D">调制解调器</a>，作用是将数字信号（电脑想要发送的信息）转换成模拟信号（网线中的<a href="https://www.zhihu.com/search?q=%E7%94%B5%E6%B5%81%E8%84%89%E5%86%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:402261894%7D">电流脉冲</a>）从而使信息在网线中传输</p><p><strong>OSI七层协议</strong></p><ul><li>应用层:为网络用户之间的通信提供专用的<strong>程序和协议</strong></li><li>表示层:提供<strong>数据压缩、解压、加密</strong>等服务，为应用层提供语法选择，语法转换</li><li>会话层:建立、管理和终止表示层实体之间的会话连接</li><li>传输层:为会话层提供<strong>可靠的、无误的</strong>数据传输</li><li>网络层:基于<strong>IP地址</strong>为数据的传输进行网络间的<strong>路由选择</strong></li><li>数据链路层 : <strong>物理地址寻址</strong>，为网络层提供数据传送服务</li><li>物理层:为数据传输提供<strong>物理媒体</strong>，进行数据的实际传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203050801952.png" alt="image-20220305080120814">、</p><p><strong>路由器之间如何传输数据？</strong></p><ul><li>电路交换</li><li>报文交换</li><li>分组交换(目前使用)<ul><li>分组在各节点存储转发时需要排队，会造成一定的时延。</li><li>必须携带首部(含有控制信息)，造成了一定的开销</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203050809987.png" alt="image-20220305080941888"></p><p><strong>性能指标</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203050819519.png" alt="image-20220305081947420"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><strong>码元</strong>:  在使用时间域(时域)的波形表示数字信号时，代表不同离散数值的基本波形</p><p><strong>基本编码方式</strong>：归零，不归零，曼彻斯特，差分曼彻斯特</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203051806123.png" alt="image-20220305180648904"></p><p>三种<strong>调制</strong>方式</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203051808599.png" alt="image-20220305180810505"></p><p><strong>信道复用技术</strong>: 频分复用(FDM)，时分复用(TDM)，波分复用(WDM)、码分复用(CDM)</p><p>CMDA = Code Division Multiple Access 码分多址</p><p>物理层接口的特性:</p><ul><li>机械特性，电气特性，功能特性，规程特性</li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>1、解决的问题</p><ul><li>封装成帧：在一段数据前后分别<strong>添加首部和尾部</strong></li><li>透明传输</li><li>差错检测 <strong>CRC循环冗余</strong></li></ul><p>2、点对点协议(PPP协议)</p><blockquote><p>用户使用拨号电话线接入互联网时，用户计算机和<code>ISP</code>进行通信时所使用的数据链路层协议</p></blockquote><p>3、广播信道 </p><p><strong>CSMA/CD协议</strong> =  载波监听多点接入/碰撞检测</p><p>4、以太网</p><p><strong>链路层寻址和ARP</strong></p><blockquote><p>ip地址和MAC地址</p></blockquote><p>链路层地址，又称MAC地址或物理地址，局域网地址</p><ul><li>用于把数据帧从一个节点传送到另一个节点(同一网络中)</li></ul><p><strong>MAC地址</strong></p><ul><li>节点”网卡” 本身所带的地址(唯一)</li><li>通常为6个字节，共2^48个</li><li>6字节地址用16进制表示，如:<code>1A-2F-BB-76-09-AD</code></li><li>网卡的mac地址是永久的(生产时固化在ROM里面)</li></ul><p><code>ARP地址解析协议</code>：将ip地址解析到MAC地址</p><ul><li>ARP只为用一个<strong>LAN</strong>上的节点解析IP地址</li></ul><p><code>DNS域名系统</code>：将主机名解析到IP地址</p><ul><li>DNS为在因特网中任何地方的主机解析主机名</li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><strong>核心设备：路由器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203091759297.png" alt="image-20220309175856087"></p><p><strong>子网掩码</strong></p><ul><li>减少IP地址的浪费，使网络的组织更加灵活，更便于维护和管理</li><li>可以方便找出IP地址中的子网部分</li></ul><p>默认子网掩码</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203091911974.png" alt="image-20220309191100664"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS题目</title>
    <link href="/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/"/>
    <url>/2022/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>什么是操作系统？</strong></p><blockquote><p>操作系统是运行在计算机上最重要的一种<strong>软件</strong>，管理计算机的资源和进程以及所有的硬件和软件，它为计算机软件和硬件提供了了一个中间层</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203042012304.png" alt="image-20220304201205174"></p><p><strong>操作系统的主要目的?</strong></p><ul><li>管理计算机资源，包括cpu,内存,磁盘驱动器，打印机</li><li>提供一种图形界面，提供了用户和计算机之间的桥梁</li><li>为其他软件提供服务，以便为其分配所需的资源</li></ul><p><strong>什么是按需分页？</strong></p><p>​        操作系统中，<strong>进程是以页为单位加载到内存中的</strong>，按需分页是一种<strong>虚拟内存</strong>的管理方式。在使用请求分页的系统中只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，就发现了<strong>缺页异常</strong>，操作系统才会将磁盘页面复制到内存中</p><p><strong>什么是内核？</strong></p><p>​        内核是一个计算机程序，是操作系统的<strong>核心</strong>，可以控制操作系统的所有内容。内核通过是在<code>boot loader</code>装载程序之前加载的第一个程序</p><blockquote><p><code>boot loader</code> 又称<strong>引导加载程序</strong>，它是一个程序，能够将计算机的操作系统放到内存中。在电源通电或计算机重启时，<code>BIOS</code> 会执行一些初始测试，然后将控制权转移到引导加载程序所在的<strong>主引导记录(MBR)</strong></p></blockquote><p><strong>什么是虚拟内存？</strong></p><p>虚拟内存是内存分配方案，是一项可以用来<strong>辅助内存分配</strong>的机制，允许执行进程不必完全处于内存。这种方案的一个主要优点就是，程序可以大于物理内存。</p><p>此外，虚拟内存将内存抽象成一个巨大的、统一的<strong>存储数组</strong>，进而实现了用户看到的逻辑内存与物理内存的分离。这种技术使得程序员不再担忧内存容量的限制。</p><p><strong>什么是线程，进程，两者的区别</strong></p><p><strong>导致死锁出现的条件</strong></p><p><strong>进程间通信的几种方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203042115650.png" alt="image-20220304211541548"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能基础</title>
    <link href="/2022/03/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能基础"><a href="#人工智能基础" class="headerlink" title="人工智能基础"></a>人工智能基础</h1><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203031121734.png" alt="image-20220303112113639"></p><p><strong>机器学习是一种功能，方法，或者说是一种算法，能赋予机器进行学习的能力，从而使机器完成一些通过编程无法直接实现的功能</strong></p><blockquote><p>机器学习是人工智能的核心</p></blockquote><p>即，<strong>利用大量数据训练出一个最优模型</strong>，然后利用此模型预测出其他数据的一种方法</p><blockquote><p>Q : 如何让计算机识别是一只狗还是一只猫呢？</p><p>特征！！ + 大量数据训练 &lt;===&gt;  类比认识新朋友，记住特征，也要常联系，多见面 </p></blockquote><p><strong>人工智能的发展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061450799.png" alt="image-20220306144955539"></p><p>辛顿(<code>BP算法</code> = 误差反向传播)</p><p>杨立昆(<code>CNN</code> = 卷积神经网络)</p><h2 id="机器学习形式"><a href="#机器学习形式" class="headerlink" title="机器学习形式"></a>机器学习形式</h2><ul><li><strong>监督学习</strong> 训练数据包括正确的结果<ul><li>线性回归，逻辑回归，决策树，神经网络，卷积神经网络，循环神经网络等</li></ul></li><li><strong>无监督学习</strong> 训练数据不包括正确的结果<ul><li>聚类算法</li></ul></li><li><strong>半监督学习</strong> 训练数据包含少量正确的结果</li><li><strong>强化学习</strong>   根据每次结果收获的奖惩进行学习，根据结果实现优化</li></ul><h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><ol><li><strong>模型</strong> ==&gt; 股票预测模型……..房价，天气，</li><li>数据集  ( 训练集 和 测试集 )</li><li>样本&amp;特征</li><li>向量和矩阵</li></ol><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202281439650.png" alt="image-20220228143911448"></p><p><strong>假设函数</strong> y = f(x)</p><p><strong>损失函数</strong>L(x) 又称目标函数,此时的x为假设函数得出的y，<strong>返回的越小则表示预测越接近</strong>“真实值”</p><p><strong>优化方法</strong></p><ul><li>梯度下降法</li><li>牛顿方与拟牛顿法</li><li>共轭梯度法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202281444796.png" alt="image-20220228144437739"></p><p><strong>拟合&amp;过拟合&amp;欠拟合</strong></p><blockquote><p>拟合形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法</p></blockquote><blockquote><p><strong>过拟合</strong>是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<strong>模型在训练集上表现很好，但在测试集上却表现很差</strong> </p><p><strong>为什么会出现过拟合现象？</strong></p><p>造成原因主要有以下几种：<br>1、<strong>训练数据集样本单一，样本不足</strong>。如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。<br>2、<strong>训练数据中噪声干扰过大</strong>。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。<br>3、<strong>模型过于复杂。</strong>模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</p></blockquote><blockquote><p><strong>欠拟合</strong>是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p><p>主要原因：<strong>没有选择好合适的特征值</strong></p><p>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<strong>增加网络复杂度</strong>或者在模型中<strong>增加特征</strong>，这些都是很好解决欠拟合的方法。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202281451431.png" alt="image-20220228145117375"></p><p><strong>神经网络</strong></p><p> <code>M-P模型 </code></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061513084.png" alt="image-20220306151322012"></p><p><strong>多层神经元</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061516750.png" alt="image-20220306151656644"></p><h2 id="人工智能框架"><a href="#人工智能框架" class="headerlink" title="人工智能框架"></a>人工智能框架</h2><p>1、Google的<code>TensorFlow</code></p><p>2、Facebook的 <code>pytorch</code></p><p>3、华为的<code>MindSpore</code>  </p><ul><li>自动并行</li><li>二阶优化</li><li>全场景协同</li><li>信息安全性高</li></ul><h2 id="图像识别入门"><a href="#图像识别入门" class="headerlink" title="图像识别入门"></a>图像识别入门</h2><h3 id="视觉原理"><a href="#视觉原理" class="headerlink" title="视觉原理"></a>视觉原理</h3><p><code>神经认知模型</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061532468.png" alt="image-20220306153203366"></p><h3 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h3><h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a><strong>卷积</strong></h4><p>利用数学方法提取出图像中的特征 </p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203311014462.png" alt="image-20220331101432429"></p><p>物理意义大概可以理解为：<strong>系统某一时刻的输出是由多个输入共同作用（叠加）的结果</strong></p><p><code>卷积核</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061539389.png" alt="image-20220306153906228"></p><p>然后不断平移卷积核,进行相对于的计算，得到<code>特征图</code></p><p>数字大的很能表示之前图形的特征，即之前那个卷积核对应一个<strong>斜右下的线条</strong></p><blockquote><p>通过不同的<strong>卷积核</strong>，可对图像进行不同的处理，将得到不同的<strong>特征图</strong>，则知道此特征具体分布在什么位置</p></blockquote><h4 id="池化和激活"><a href="#池化和激活" class="headerlink" title="池化和激活"></a>池化和激活</h4><blockquote><p>池化它实际上是一种形式的<strong>降采样</strong>。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出<strong>最大值</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061544740.png" alt="image-20220306154449666"></p><p><code>Sigmoid</code>函数</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203311014291.png" alt="image-20220331101410261"></p><blockquote><p>Sigmoid函数是一个在<a href="https://baike.baidu.com/item/%E7%94%9F%E7%89%A9%E5%AD%A6/1358">生物学</a>中常见的<a href="https://baike.baidu.com/item/S%E5%9E%8B%E5%87%BD%E6%95%B0/19178062">S型函数</a>，也称为<a href="https://baike.baidu.com/item/S%E5%9E%8B%E7%94%9F%E9%95%BF%E6%9B%B2%E7%BA%BF/5581189">S型生长曲线</a>。 [1] 在信息科学中，由于其单增以及反函数单增等性质，**Sigmoid函数常被用作神经网络的<a href="https://baike.baidu.com/item/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/2520792">激活函数</a>**，将变量映射到0,1之间</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203311013707.png" alt="image-20220331101326648"></p><p><strong>激活</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203061550518.png" alt="image-20220306155053452"></p><h4 id="算法、数据、算力"><a href="#算法、数据、算力" class="headerlink" title="算法、数据、算力"></a>算法、数据、算力</h4><p>人工智能处理器</p><ul><li><p><code>cpu</code>  中央处理器，通用性强，并行差</p></li><li><p><code>GPU</code> 图形处理器，互动性强，并行好</p></li><li><p><code>NPU</code> 神经网络处理器</p></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>python</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203031122108.png" alt="image-20220303112202070"></p><p>安装<code>anaconda</code> 继承了相关的工具</p><p><a href="https://www.anaconda.com/">https://www.anaconda.com/</a> </p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203031123783.png" alt="image-20220303112357673"></p><p>要配置环境变量</p><pre><code class="hljs latex">E:<span class="hljs-tag">\<span class="hljs-name">software</span></span><span class="hljs-tag">\<span class="hljs-name">Anaconda</span></span><span class="hljs-tag">\<span class="hljs-name">Library</span></span><span class="hljs-tag">\<span class="hljs-name">bin</span></span>E:<span class="hljs-tag">\<span class="hljs-name">software</span></span><span class="hljs-tag">\<span class="hljs-name">Anaconda</span></span>E:<span class="hljs-tag">\<span class="hljs-name">software</span></span><span class="hljs-tag">\<span class="hljs-name">Anaconda</span></span><span class="hljs-tag">\<span class="hljs-name">Scripts</span></span></code></pre><p><code>terminal</code> 运行</p><pre><code class="hljs shell">PS C:\Windows\System32&gt; conda -Vconda 4.10.3</code></pre><p><strong>numpy(矩阵运算)</strong></p><blockquote><p>科学计算的基础库，提供了多维数组处理，线代代数，傅里叶变换，随机数生成等工具</p></blockquote><p><strong>pandas（读取文件）</strong></p><blockquote><p>Pandas 属于 Python 第三方数据处理库，它基于 NumPy 构建而来，主要用于数据的处理与分析。我们知道对于机器学习而言数据是尤为重要，如果没有数据就无法训练模型。Pandas 提供了一个简单高效的 DataFrame 对象（类似于电子表格），它能够完成数据的清洗、预处理以及数据可视化工作等。除此之外，Pandas 能够非常轻松地实现对任何文件格式的读写操作，比如 CSV 文件、json 文件、excel 文件。视化软件包之一，支持跨平台运行，它是 Python 常用的 2D 绘图库，同时它也提供了一部分 3D 绘图接口。Matplotlib 通常与 NumPy、Pandas 一起使用，是数据分析中不可或缺的重要工具之一。</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt%matplotlib inlinex = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]y = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<span class="hljs-comment"># 绘制连线图</span>plt.plot(x,y)plt.title(<span class="hljs-string">&#x27;y vs x&#x27;</span>)plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)plt.show( )<span class="hljs-comment">#绘制散点图</span>plt.scatter(x,y)plt.show( )</code></pre><p><strong>Scikit-Learn（算法库）</strong></p><p>（官网：<a href="https://scikit-learn.org/stable/%EF%BC%89">https://scikit-learn.org/stable/）</a></p><blockquote><p>它是一个基于 Python 语言的机器学习算法库。Scikit-Learn 主要用 Python 语言开发，建立在 NumPy、Scipy 与 Matplotlib 之上，它提供了大量机器学习算法接口（API），因此你可以把它看做一本“百科全书”。由于 Scikit-Learn 的存在极大地提高了机器学习的效率，让开发者无须关注数学层面的公式、计算过程，有更多的更多的时间与精力专注于业务层面，从而解决实际的应用问题。</p><p>Scikit-Learn 的基本功能主要被分为六大部分：<strong>分类，回归，聚类，数据降维，模型选择和数据预处理</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="/2022/03/02/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/02/SpringBoot%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://spring.io/">官网</a></p><p>众所周知 Spring 应用需要进行大量的配置</p><p>各种 <strong>XML 配置和注解配置</strong>让人眼花缭乱，且极容易出错，因此 Spring 一度被称为“配置地狱”。</p><p><strong>为了简化 Spring 应用的搭建和开发过程</strong>，Pivotal 团队在 Spring 基础上提供了一套全新的开源的框架，它就是 <code>Spring Boot</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203020805993.png" alt="image-20220302080513818"></p><h2 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h2><ol><li><strong>独立运行的 Spring 项目</strong></li></ol><p>Spring Boot 可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令“ java–jar xx.jar” 即可运行。</p><ol start="2"><li><strong>内嵌 Servlet 容器</strong></li></ol><p>Spring Boot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertow 等），应用无需打成 WAR 包 。</p><ol start="3"><li><strong>提供 starter 简化 Maven 配置</strong></li></ol><p>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</p><ol start="4"><li><strong>提供了大量的自动配置</strong></li></ol><p>Spring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</p><ol start="5"><li><strong>自带应用监控</strong></li></ol><p>Spring Boot 可以对正在运行的项目提供监控。</p><ol start="6"><li><strong>无代码生成和 xml 配置</strong></li></ol><p>Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。</p><p><img src="http://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203020807461.png" alt="image-20220302080732368"></p><p><strong>springboot 并不是对spring功能上的增强，而是提供了一种快速使用spring的方式</strong></p><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><ul><li>在<code>spring-boot-starter-parent</code> 中定义了各种技术的版本信息，组合了一套最优搭配的技术版本</li><li>在各种<code>starter</code>中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程</li><li>工程继承于<code>parent</code>,引入<code>starter</code>后，通过<strong>依赖传递</strong>，就可以简单方便的获取需要的<code>jar</code>包,并且不存在版本冲突的问题</li></ul><h1 id="springboot的配置"><a href="#springboot的配置" class="headerlink" title="springboot的配置"></a>springboot的配置</h1><h2 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h2><p><code>properties</code> 和 <code>yaml</code></p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">server.address</span> = <span class="hljs-string">127.0.0.1</span></code></pre><p>若同时存在，优先级最高的为<code>properties</code> </p><h2 id="yaml-yml-推荐"><a href="#yaml-yml-推荐" class="headerlink" title="yaml/yml(推荐)"></a>yaml/yml(推荐)</h2><p><strong>注意空格</strong></p><p>YAML 是 <code>YAML Ain&#39;t a Markup Language</code>（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p><p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p><p>YAML 的配置文件后缀为 <strong>.yml</strong>，如：<strong>application.yml</strong></p><pre><code class="hljs yml"><span class="hljs-comment"># yml格式</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span>  <span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><p>对比<code>xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>YAML 支持以下几种数据类型：</p><ul><li>对象(map)：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）<ul><li>使用<code>-</code> 表示数组每个元素</li></ul></li><li>纯量（scalars）：单个的、不可再分的值</li></ul><pre><code class="hljs yml"><span class="hljs-attr">key:</span>     <span class="hljs-attr">child-key:</span> <span class="hljs-string">value</span>    <span class="hljs-attr">child-key2:</span> <span class="hljs-string">value2</span></code></pre><p>参数引用： <code>$&#123;key&#125;</code>  key为要引用的键</p><h2 id="读取配置文件内容"><a href="#读取配置文件内容" class="headerlink" title="读取配置文件内容"></a>读取配置文件内容</h2><p>1、**@Value**</p><p><code>yml</code>中</p><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">heng</span><span class="hljs-comment">#对象</span><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;name&#125;</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">20</span><span class="hljs-comment"># 数组</span><span class="hljs-attr">address:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">beijing</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">shanghai</span><span class="hljs-comment"># 纯量</span><span class="hljs-attr">msg1:</span> <span class="hljs-string">&#x27;hello \n world&#x27;</span><span class="hljs-attr">msg2:</span> <span class="hljs-string">&quot;hello \n world&quot;</span></code></pre><p><code>HelloController.java</code></p><pre><code class="hljs java"><span class="hljs-comment">//获取yml配置中的属性 , 利用@Value 读取</span><span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span> <span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span><span class="hljs-keyword">private</span> String name1;<span class="hljs-meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-meta">@Value(&quot;$&#123;address[0]&#125;&quot;)</span><span class="hljs-keyword">private</span> String address;<span class="hljs-meta">@Value(&quot;$&#123;msg1&#125;&quot;)</span><span class="hljs-keyword">private</span> String msg1;<span class="hljs-meta">@RequestMapping(&quot;/hello2&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(name);    System.out.println(name1);    System.out.println(age);    System.out.println(address);    System.out.println(msg1);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok!&quot;</span>;&#125;</code></pre><p>当运行时，访问<code>localhost:8080/hello2</code> 则控制台打印</p><pre><code class="hljs angelscript">hengheng<span class="hljs-number">20</span>beijinghello \n world</code></pre><p>2、<strong>Environment</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//第二种方法</span><span class="hljs-keyword">private</span> Environment env;System.out.println(env.getProperty(<span class="hljs-string">&quot;person.name&quot;</span>)); <span class="hljs-comment">//即可获取内容</span>System.out.println(env.getProperty(<span class="hljs-string">&quot;msg2&quot;</span>));</code></pre><p>同理访问时打印</p><pre><code class="hljs ebnf"><span class="hljs-attribute">heng</span><span class="hljs-attribute">hello</span> <span class="hljs-attribute"> world</span></code></pre><p>3、**@ConfigurationProperties**</p><p><code>yml</code>中的对象</p><pre><code class="hljs yaml"><span class="hljs-comment">#对象</span><span class="hljs-attr">person:</span>  <span class="hljs-comment">#name: $&#123;name&#125;</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">20</span></code></pre><p>新创建<code>Person</code>类，与之进行对应，然后注入</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo01.common;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span> <span class="hljs-comment">//让这个类成为bean，被识别</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span> <span class="hljs-comment">//提供前缀，识别yaml中的person对象，否则找的为普通的name</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><p>在<code>HelloController.java</code>中，同理进行测试</p><pre><code class="hljs java"><span class="hljs-comment">//第三种</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> Person person;System.out.println(person);</code></pre><p>运行，访问，控制台可得到</p><p><code>Person&#123;name=&#39;zhangsan&#39;, age=20&#125;</code></p><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p>开发spring boot时，通常同一套程序会被安装到不同环境，比如：开发，测试，生产等。其中数据库地址，服务器端等等配置均不同，如果每次打包时，都修改配置文件，会非常麻烦。**<code>profile</code>功能就是来进行动态配置切换的**</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p><strong>1、多<code>profile</code>文件方式</strong></p><p>新建springboot项目</p><p>创建<code>application-dev.properties</code>文件(当然可以为<code>yml</code>文件)，里面为开发环境</p><pre><code class="hljs properties"><span class="hljs-comment"># dev = develoment 开发环境</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span></code></pre><p>在<code>application.properties</code> 中激活</p><pre><code class="hljs properties"><span class="hljs-comment">#激活dev文件，使其生效</span><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">dev </span></code></pre><p>此时运行，可看到如下，端口号已生效</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203030700420.png" alt="image-20220303070044353"></p><p><strong>2、yml多文档方式</strong></p><ul><li>在<code>yml</code>中使用 <code>---</code>分割不同配置 (之前的配置方法已失效)</li></ul><pre><code class="hljs yml"><span class="hljs-comment"># 这个代表第一个文档块</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8085</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 当需要哪个环境配置的时候，只需要在这里修改值。</span><span class="hljs-meta">---</span><span class="hljs-comment"># 这个代表第二个文档块</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8086</span><span class="hljs-comment">#目前已被弃用</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 指定dev，代表开发环境 </span><span class="hljs-meta">---</span><span class="hljs-comment"># 这个代表第三个文档块</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8087</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span> <span class="hljs-comment"># 指定pro，代表生产环境</span></code></pre><p><code>profiles</code>激活方式</p><ul><li>配置文件： <code>spring.profiles.active: dev</code></li><li>虚拟机参数： 在<code>VM option</code>指定：<code>-Dspring.profiles.active=dev</code></li><li>命令行参数：<code>java -jar xxx.jar --spring.profiles.active=dev</code></li></ul><h2 id="内部和外部配置加载顺序"><a href="#内部和外部配置加载顺序" class="headerlink" title="内部和外部配置加载顺序"></a>内部和外部配置加载顺序</h2><h3 id="内部配置"><a href="#内部配置" class="headerlink" title="内部配置"></a>内部配置</h3><p><strong><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203030752821.png" alt="image-20220303075226606"></strong></p><h3 id="外部配置"><a href="#外部配置" class="headerlink" title="外部配置"></a>外部配置</h3><p>官网详情</p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/boot-features-external-config.html">https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/boot-features-external-config.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言刷题</title>
    <link href="/2022/02/27/C%E8%AF%AD%E8%A8%80%E5%88%B7%E9%A2%98/"/>
    <url>/2022/02/27/C%E8%AF%AD%E8%A8%80%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来自牛客网站C语言刷题的记录</p></blockquote><p><a href="https://www.nowcoder.com/">https://www.nowcoder.com/</a></p><h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>1、用变量a给出下面的定义:一个有<strong>10个指针的数组</strong>,该指针<strong>指向一个函数</strong>,该函数有<strong>一个整形参数</strong>并<strong>返回一个整型数</strong></p><p><a href="https://cdecl.org/">https://cdecl.org/</a>   可自动分析出对应c语言的声明</p><pre><code class="hljs c"><span class="hljs-comment">//1、 定义一个数组</span>a[<span class="hljs-number">10</span>]<span class="hljs-comment">// 2 、该数组元素是指针</span>*a[<span class="hljs-number">10</span>]<span class="hljs-comment">//3、该指针指向一个函数</span>(*a[<span class="hljs-number">10</span>]) ()<span class="hljs-comment">// 4.有一个整形参数</span>(*a[<span class="hljs-number">10</span>]) (<span class="hljs-keyword">int</span>)<span class="hljs-comment">// 5.并且返回整形</span><span class="hljs-keyword">int</span> (*a[<span class="hljs-number">10</span>])(<span class="hljs-keyword">int</span> )</code></pre><p><strong>经典例子</strong></p><p><strong>注意： 指向数组的指针和指针数组</strong></p><pre><code class="hljs C"><span class="hljs-comment">//a是一个数组，该数组的元素是指针，每个指针都指向一个int型==&gt;指向int类型的指针数组a[10]</span><span class="hljs-keyword">int</span> *a[<span class="hljs-number">10</span>]; <span class="hljs-comment">//a是一个指针，该指针指向一个数组，数组元素是int ==&gt; 指向有10个int类型数组的指针a</span><span class="hljs-keyword">int</span> (*a)[<span class="hljs-number">10</span>]; <span class="hljs-comment">//函数指针,指向有一个参数并且返回类型均为int的函数</span><span class="hljs-keyword">int</span> (*a)(<span class="hljs-keyword">int</span>);<span class="hljs-comment">//函数指针的数组 , 指向有一个参数并且返回类型均为int的函数的数组</span><span class="hljs-keyword">int</span> (*a[<span class="hljs-number">10</span>])(<span class="hljs-keyword">int</span>);</code></pre><p>2、 extern “c”的作用有哪些（）</p><p><strong>为了能够正确的实现 C++ 代码调用 C 语言代码</strong></p><blockquote><p>加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的</p></blockquote><p>3 、 </p><pre><code class="hljs c"><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">int</span> k = <span class="hljs-number">12</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x,%o,&quot;</span>, ch, ch, k);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k=%%d\n&quot;</span>,k);<span class="hljs-comment">//输出</span><span class="hljs-number">61</span>,<span class="hljs-number">141</span>,k=%d<span class="hljs-comment">/*</span><span class="hljs-comment">%是控制符，用 %% 表示输出一个百分号</span><span class="hljs-comment">*/</span></code></pre><p>4、</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;    <span class="hljs-keyword">int</span> *p, **k;    p = a;    k = &amp;p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *(p++));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, **k);    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);&#125;</code></pre><p>打印<code>12</code></p><blockquote><p><code>*(p++)</code> 等价 <code>*p++</code>  此时p自增后，但仍取*p之前的值，故为1，之后再打印为2</p></blockquote><p>5、</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">3</span>]=a; <span class="hljs-keyword">int</span> *q=*a;<span class="hljs-comment">//Q: 输出a[1][2]值的语句为</span>A:<span class="hljs-built_in">cout</span>&lt;&lt; *(*(a + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>);B:<span class="hljs-built_in">cout</span>&lt;&lt;p[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];C:<span class="hljs-built_in">cout</span>&lt;&lt;*(q+<span class="hljs-number">5</span>);D:<span class="hljs-built_in">cout</span>&lt;&lt;q[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];</code></pre><p><img src="https://uploadfiles.nowcoder.com/images/20190922/997783280_1569150818042_329343038B0C7F2960226D5BD19DA8B0" alt="img"></p><p>6、</p><p>64位系统下，<code>*p=NULL</code>和<code>*p=new char[100]</code>， sizeof(p)各为多少？</p><blockquote><p>指针类型，32位就是4，64位就是8  故均为 8</p></blockquote><p>7.</p><pre><code class="hljs c">指针函数是指带指针的函数，即本质是一个函数，函数返回类型是某一类型的指针。<span class="hljs-comment">//函数fun()是一个指针函数,返回值为一个整型的指针.</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;函数体语句&#125;函数指针是指向函数的指针变量，即本质是一个指针变量。<span class="hljs-keyword">int</span> (*f) (<span class="hljs-keyword">int</span> x); <span class="hljs-comment">/*声明一个函数指针 */</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203071824709.png" alt="image-20220307182411536"></p><p>8、</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.2</span>;<span class="hljs-keyword">int</span> x, y;x = <span class="hljs-number">1.2</span>;y = (x + <span class="hljs-number">3.8</span>)/<span class="hljs-number">5.0</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, d*y);</code></pre><p>有坑，注意变量类型</p><p>x为int类型，故y此时为 <code>(1+3.8) / 5.0 = 0</code> 最终打印0</p><p>9、char是有符号还是无符号类型（）   </p><blockquote><p><strong>取决于具体实现</strong>   </p><p>int，short，long都是signed的；</p><p>char可能是signed的，也可能是unsigned的；</p></blockquote><p>10、</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p1 =<span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> p2 = <span class="hljs-string">&quot;world&quot;</span>;</code></pre><p>哪些合法？</p><pre><code class="hljs c">A: p1++B: p1[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;C: p2[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;D: p2++;<span class="hljs-comment">//选A</span></code></pre><blockquote><p><strong>口诀：左定值，右定向。</strong></p><p><strong>即</strong> <strong>const在*的左边不能改变字符串常量的值，故B错；</strong></p><p><strong>const在*的右边不能改变指针的指向，故D错；</strong></p><p><strong>由于</strong> <strong>“world“存储在字符常量区，不能直接修改其值，故C错；</strong></p><p><strong>若要修改其值，应该改为char str []= “world”;</strong></p></blockquote><h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p>1、</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> str[<span class="hljs-number">4</span>][<span class="hljs-number">12</span>] = &#123;<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbbb&quot;</span>, <span class="hljs-string">&quot;ccccc&quot;</span>, <span class="hljs-string">&quot;dddddd&quot;</span>&#125;, *strp[<span class="hljs-number">4</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)    strp[i] = str[i];</code></pre><p>对字符串的正确引用是（），其中0≤k&lt;4</p><pre><code class="hljs c">A: *strpB： strpC ： str[k]D: strp[k]<span class="hljs-comment">//选ACD</span>A：*strp = strp[<span class="hljs-number">0</span>] = str[<span class="hljs-number">0</span>]。B：strp  = &amp;strp[<span class="hljs-number">0</span>] =  &amp;str[<span class="hljs-number">0</span>]C：str[k] = strp[k] = *(strp + k)D：strp[k] = *(strp + k) = str[k]</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue</title>
    <link href="/2022/02/18/vue/"/>
    <url>/2022/02/18/vue/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网<a href="https://vuejs.bootcss.com/guide/">https://vuejs.bootcss.com/guide/</a></p><ul><li>JavaScript框架</li><li>简化Dom操作</li><li>响应式数据驱动</li></ul><h2 id="七大属性"><a href="#七大属性" class="headerlink" title="七大属性"></a><strong>七大属性</strong></h2><ul><li><p><strong>el属性</strong></p><p>用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。</p></li><li><p><strong>data属性</strong></p><p>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</p></li><li><p><strong>template属性</strong></p><p>用来设置模板，会替换页面元素，包括占位符。</p></li><li><p><strong>methods属性</strong></p><p>放置页面中的业务逻辑，js方法一般都放置在methods中</p></li><li><p><strong>render属性</strong></p><p>创建真正的Virtual Dom</p></li><li><p><strong>computed属性</strong></p><p>用来计算</p></li><li><p><strong>watch属性</strong></p><ul><li><p>watch:function(new,old){}</p></li><li><p>监听data中数据的变化</p></li><li><p>两个参数，一个返回新值，一个返回旧值，</p></li></ul></li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>利用<code>vscode</code> 并且下载插件<code>Live Server</code> 可在后侧边写边展示页面</p><ul><li>导入<strong>开发版本</strong>的Vue.js</li><li>创建Vue实例对象，设置<code>el</code>属性和<code>data</code>属性</li><li>利用简单模板语法把数据渲染到页面上</li></ul><pre><code class="hljs vue">&lt;body&gt;&lt;div id &#x3D; &quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 导入vue.js--&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;创建vue实例    var app &#x3D; new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;你好 Vue!&quot;        &#125;    &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre><h2 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h2><p><strong>el是用来设置Vue挂载(管理)的元素</strong></p><p>vue实例的作用范围</p><blockquote><p>vue会管理el选项命中的元素以及内部的后代元素</p></blockquote><p>可以使用其他的选择器，但建议使用<code>id选择器</code>、</p><p>是否可以操作其他<code>dom</code>元素</p><blockquote><p>可以使用其他双标签，但是不能使用<code>html</code>和<code>body</code></p></blockquote><p><strong>data数据</strong></p><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &#123;&#123;message&#125;&#125;    &lt;h2&gt; &#123;&#123; school.name &#125;&#125; &lt;&#x2F;h2&gt;    &lt;ul&gt;        &lt;li&gt; &#123;&#123;campus[0]&#125;&#125; &lt;&#x2F;li&gt;        &lt;li&gt; &#123;&#123;campus[1]&#125;&#125; &lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script&gt;    var app &#x3D; new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            message: &quot;你好 Vue!&quot;,            school: &#123;                name: &quot;Yiheng&quot;,                mobile: 12314            &#125;,            campus: [&quot;北京&quot;, &quot;上海&quot;]        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203031429220.png" alt="image-20220303142917004"></p><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a><strong>Vue指令</strong></h2><p>1、<code>v-text</code> 设置标签的内容</p><p>默认会替换全部内容，使用<code>&#123;&#123;&#125;&#125; </code>可替换<strong>指定</strong>内容</p><pre><code class="hljs vue">&lt;h2 v-text&#x3D;&quot;message + &#39;haha&#39; &quot;&gt; &lt;&#x2F;h2&gt;</code></pre><p>页面将显示出<code>你好 Vue!haha</code></p><p>2、<code>v-html</code> 设置标签的<code>innerHTML</code></p><pre><code class="hljs vue">&lt;p v-html&#x3D;&quot;content&quot;&gt;&lt;&#x2F;p&gt;data: &#123;    content: &quot;&lt;a href&#x3D;&#39;http:&#x2F;&#x2F;www.baidu.com&#39;&gt;百度&lt;&#x2F;a&gt;&quot;&#125;</code></pre><p>此时将出现<code>百度</code>的超链接，点击则跳转</p><p>3、<code>v-on</code> 为元素绑定事件</p><ul><li>事件绑定的方法写成<strong>函数调用</strong>的形式，可以传入自定义参数</li><li>定义方法时需要定义形参来接受传入的实参</li><li>事件的后面跟上<code>.修饰符</code>可以对事件进行限制</li><li><code>.enter</code>可以限制触发的按键为回车</li></ul><pre><code class="hljs vue">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;v-on指令&quot; v-on:click&#x3D;&quot;doIt&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;v-on简写&quot; @click&#x3D;&quot;doIt&quot;&gt;&lt;h1 @click&#x3D;&quot;changeData&quot;&gt;&#123;&#123;food&#125;&#125;&lt;&#x2F;h1&gt;&lt;script&gt;    var app &#x3D; new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            food: &quot;土豆&quot;        &#125;,        methods: &#123;            doIt: function() &#123;                alert(&quot;hhhhhhhhhh&quot;) &#x2F;&#x2F;弹窗            &#125;,            changeData: function() &#123;                this.food +&#x3D; &quot;好吃&quot;  &#x2F;&#x2F;点击文字土豆，然后会拼接字符串            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre><p>4、<code>v-show</code> 根据表达式真假，切换元素的显示和隐藏</p><p>原理是修改元素的<code>display</code> </p><pre><code class="hljs vue">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;img.duoziwang.com&#x2F;2021&#x2F;01&#x2F;1618792249721642.jpg&quot; v-show&#x3D;&quot;isShow&quot; alt&#x3D;&quot;小图像&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;切换是否显示图片&quot; @click&#x3D;&quot;changeIsShow&quot;&gt;&lt;script&gt;    var app &#x3D; new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            isShow: false        &#125;,        methods: &#123;            changeIsShow: function() &#123;                this.isShow &#x3D; !this.isShow            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre><p>5、<code>v-if</code> 根据表达式真假切换元素的显示状态</p><p>本质是操作<code>dom</code>元素来切换显示状态</p><p>若为true，元素存在dom树中，为false，从dom树中移除</p><pre><code class="hljs vue">&lt;p v-if&#x3D;&quot;isShow1&quot;&gt;come on!!&lt;&#x2F;p&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点我切换&quot; @click&#x3D;&quot;toggleIsShow&quot;&gt;isShow1: falsetoggleIsShow: function() &#123;    this.isShow1 &#x3D; !this.isShow1&#125;</code></pre><p>6、<code>v-bind</code> 设置元素的<strong>属性</strong> ，比如(src,title,class)</p><p>完整写法: <code>v-bind:属性名 </code> <strong>v-bind可以省略</strong></p><pre><code class="hljs VUE">&lt;style&gt;    .active &#123;        border: 1px solid red;    &#125;&lt;&#x2F;style&gt;&lt;img :src&#x3D;&quot;imgSrc&quot; alt&#x3D;&quot;&quot; :title&#x3D;&quot;imgTitle&quot; :class&#x3D;&quot;&#123;active:isActive&#125;&quot; @click&#x3D;&quot;toggleActive &quot;&gt;&lt;script&gt;    var app &#x3D; new Vue(&#123;        el: &quot;#app &quot;,        data: &#123;            imgSrc: &quot;http:&#x2F;&#x2F;www.itheima.com&#x2F;images&#x2F;logo.png&quot;,            imgTitle: &quot;我是黑马！！&quot;,            isActive: false,        &#125;,        methods: &#123;            toggleActive: function() &#123;                this.isActive &#x3D; !this.isActive            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre><p>当点击图片时，class样式被激活，此时显示出来外边框</p><p>7、<code>v-for</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in arr&quot;</span>&gt;</span>        你好&#123;&#123;item &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>data: &#123;    arr: [1, 2, 3, 4, 5],&#125;</code></pre><p>8、<code>v-model</code> 获取和设置表单元素的值**(双向数据绑定)**</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;getM&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>data: &#123;    message: &quot;你好 Vue! &quot;,&#125;,methods: &#123;    getM: function() &#123;        alert(this.message)    &#125;&#125;</code></pre><p>运行时，会显示<code>你好 Vue!</code> 可进行修改，同时h2标签随着进行改变，当回车时，弹出对应的内容</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Linux Command Line</title>
    <link href="/2022/02/14/linux/"/>
    <url>/2022/02/14/linux/</url>
    
    <content type="html"><![CDATA[<blockquote><p>据《The Linux Command Line》记录学习</p></blockquote><h1 id="一-Shell简介"><a href="#一-Shell简介" class="headerlink" title="一.Shell简介"></a>一.Shell简介</h1><p>linux ==&gt; <strong>一切皆文件</strong></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序</p><p>bash = Bourne Again SHell</p><blockquote><p><strong>快速拷贝和粘贴技巧:</strong></p><p>​        如果你按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标中键， 这些文本就被粘贴到光标所在的位置</p></blockquote><h2 id="2-简单命令"><a href="#2-简单命令" class="headerlink" title="2.简单命令"></a>2.简单命令</h2><p><code>date</code></p><p><code>cal</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202141851256.png" alt="image-20220214185140150"></p><h3 id="2-1-文件系统中跳转"><a href="#2-1-文件系统中跳转" class="headerlink" title="2.1 文件系统中跳转"></a>2.1 文件系统中跳转</h3><ul><li>pwd — 打印出当前工作目录名</li></ul><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# pwd/root</code></pre><ul><li>cd — 更改目录</li></ul><p>绝对路径：开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件</p><p>比如</p><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# cd /usr/bin/[root@iZ2ze9nu608mhi5at5aufaZ bin]#<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#从根目录（用开头的”/”表示）开始，有一个叫 “usr” 的 目录包含了目录 “bin”</span></span></code></pre><p>相对路径： 开始于工作目录</p><h3 id="2-2-简单探究操作系统"><a href="#2-2-简单探究操作系统" class="headerlink" title="2.2 简单探究操作系统"></a>2.2 简单探究操作系统</h3><ul><li><code>ls</code> — 列出目录内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202141905661.png" alt="image-20220214190530605"></p><p>长格式列表的字段</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202141935979.png" alt="image-20220214193503927"></p><blockquote><p>-rw-r–r– </p><p>第一个字符指明文件类型。在不同类型之间， <strong>开头的“－”说明是一个普通文件</strong>，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限</p></blockquote><ul><li><code>file</code> — 确定文件类型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202141947784.png" alt="image-20220214194713740"></p><ul><li><p><code>less</code> — 浏览文件内容</p><blockquote><p>less is more</p><p>less 属于”页面调度器”类程序,允许以逐页方式轻松浏览长文本文档</p><p> more 程序只能向前翻页</p></blockquote></li></ul><p><code>less /etc/passwd</code></p><blockquote><p>若图床自动上次图片成功，但无法正常显示===&gt; <strong>将https 改为 http</strong></p></blockquote><p><img src="http://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202202141954020.png" alt="image-20220214195404955"></p><h3 id="Linux-系统中的目录"><a href="#Linux-系统中的目录" class="headerlink" title="Linux 系统中的目录"></a><em>Linux 系统中的目录</em></h3><table><thead><tr><th align="left">目录</th><th align="left">评论</th></tr></thead><tbody><tr><td align="left">/</td><td align="left">根目录，万物起源。</td></tr><tr><td align="left">/bin</td><td align="left">包含系统启动和运行所必须的二进制程序。</td></tr><tr><td align="left">/boot</td><td align="left">包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。</td></tr><tr><td align="left">/dev</td><td align="left">这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。</td></tr><tr><td align="left">/etc</td><td align="left">这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。</td></tr><tr><td align="left">/home</td><td align="left">在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。</td></tr><tr><td align="left">/lib</td><td align="left">包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。</td></tr><tr><td align="left">/lost+found</td><td align="left">每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。</td></tr><tr><td align="left">/media</td><td align="left">在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。</td></tr><tr><td align="left">/mnt</td><td align="left">在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。</td></tr><tr><td align="left">/opt</td><td align="left">这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。</td></tr><tr><td align="left">/proc</td><td align="left">这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。</td></tr><tr><td align="left">/root</td><td align="left">root 帐户的家目录。</td></tr><tr><td align="left">/sbin</td><td align="left">这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。</td></tr><tr><td align="left">/tmp</td><td align="left">这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。系统每次 重新启动时，都会清空这个目录。</td></tr><tr><td align="left">/usr</td><td align="left">在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。</td></tr><tr><td align="left">/usr/bin</td><td align="left">/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。</td></tr><tr><td align="left">/usr/lib</td><td align="left">包含由/usr/bin 目录中的程序所用的共享库。</td></tr><tr><td align="left">/usr/local</td><td align="left">这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。</td></tr><tr><td align="left">/usr/sbin</td><td align="left">包含许多系统管理程序。</td></tr><tr><td align="left">/usr/share</td><td align="left">/usr/share 目录包含许多由 /usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。</td></tr><tr><td align="left">/usr/share/doc</td><td align="left">大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。</td></tr><tr><td align="left">/var</td><td align="left">除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。</td></tr><tr><td align="left">/var/log</td><td align="left">这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是 /var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。</td></tr></tbody></table><h3 id="2-3操作文件和目录"><a href="#2-3操作文件和目录" class="headerlink" title="2.3操作文件和目录"></a>2.3操作文件和目录</h3><ul><li><strong>cp — 复制文件和目录(Copy files and directories)</strong></li></ul><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# touch hello.c[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsdir1  dir2  dir3  hello.c  install.sh  spring-boot-online-exam[root@iZ2ze9nu608mhi5at5aufaZ ~]# cp hello.c dir1[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsdir1  dir2  dir3  hello.c  install.sh  spring-boot-online-exam[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls dir1/hello.c</code></pre><p><code>cp</code>中的选项</p><table><thead><tr><th align="left">选项</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">-a, –archive</td><td align="left">复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常情况下，文件拷贝具有执行拷贝操作的用户的默认属性。</td></tr><tr><td align="left">-i, –interactive</td><td align="left">在覆盖已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认覆盖文件。</td></tr><tr><td align="left">-r, –recursive</td><td align="left">递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者 -a 选项）。</td></tr><tr><td align="left">-u, –update</td><td align="left">当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在文件的内容的文件。</td></tr><tr><td align="left">-v, –verbose</td><td align="left">显示翔实的命令操作信息</td></tr></tbody></table><p>示例</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cp file1 file2 dir1[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls dir1/dir2  dir3  file1  file2  hello.c<span class="hljs-meta">#</span><span class="bash">在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cp dir1/* dir2<span class="hljs-meta">#</span><span class="bash">复制目录 dir1 中的内容到目录 dir2。</span><span class="hljs-meta">#</span><span class="bash">如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 </span><span class="hljs-meta">#</span><span class="bash">如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cp -r dir1 dir2<span class="hljs-meta">#</span><span class="bash">从 /etc 目录复制 passwd 文件到当前工作目录下</span><span class="hljs-meta">#</span><span class="bash">使用命令末尾的一个圆点来简化当前工作目录的写法</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cp /etc/passwd .</code></pre><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><table><thead><tr><th align="left">通配符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配任意多个字符（包括零个或一个）</td></tr><tr><td align="left">?</td><td align="left">匹配任意一个字符（不包括零个）</td></tr><tr><td align="left">[characters]</td><td align="left">匹配任意一个属于字符集（characters）中的字符</td></tr><tr><td align="left">[!characters]</td><td align="left">匹配任意一个不是字符集中的字符</td></tr><tr><td align="left">[[:class:]]</td><td align="left">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><p><strong>示例</strong></p><table><thead><tr><th align="left">模式</th><th align="left">匹配对象</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">所有文件</td></tr><tr><td align="left">g*</td><td align="left">文件名以“g”开头的文件</td></tr><tr><td align="left">b*.txt</td><td align="left">以”b”开头，中间有零个或任意多个字符，并以”.txt”结尾的文件</td></tr><tr><td align="left">Data???</td><td align="left">以“Data”开头，其后紧接着3个字符的文件</td></tr><tr><td align="left">[abc]*</td><td align="left">文件名以”a”,”b”,或”c”开头的文件</td></tr><tr><td align="left"><code>BACKUP.[0-9][0-9][0-9]</code></td><td align="left">以”BACKUP.”开头，并紧接着3个数字的文件</td></tr><tr><td align="left">[[:upper:]]*</td><td align="left">以大写字母开头的文件</td></tr><tr><td align="left">[![:digit:]]*</td><td align="left">不以数字开头的文件</td></tr><tr><td align="left">*[[:lower:]123]</td><td align="left">文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</td></tr></tbody></table><ul><li><strong>mv — 移动/重命名文件和目录(Move/rename files and directories)</strong></li></ul><table><thead><tr><th>-i –interactive</th><th>在覆盖一个已经存在的文件之前，提示用户确认信息。 <strong>如果不指定这个选项，mv 命令会默认覆盖文件内容。</strong></th></tr></thead><tbody><tr><td>-u –update</td><td>当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容的文件。</td></tr><tr><td>-v –verbose</td><td>当操作 mv 命令时，显示翔实的操作信息。</td></tr></tbody></table><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# mv -v hello.c test.c‘hello.c’ -&gt; ‘test.c’</code></pre><ul><li><strong>mkdir — 创建目录( Create directories)</strong></li></ul><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# mkdir dir1 dir2 dir3[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsdir1  dir2  dir3  install.sh  spring-boot-online-exam</code></pre><ul><li><strong>rm — 删除文件和目录(Remove files and directories)</strong></li></ul><table><thead><tr><th>-i, –interactive</th><th>在删除已存在的文件前，提示用户确认信息。 <strong>如果不指定这个选项，rm 会默默地删除文件</strong></th></tr></thead><tbody><tr><td>-r, –recursive</td><td>递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td></tr><tr><td>-f, –force</td><td>忽视不存在的文件，不显示提示信息。这选项覆盖了“–interactive”选项。</td></tr><tr><td>-v, –verbose</td><td>在执行 rm 命令时，显示翔实的操作信息。</td></tr></tbody></table><blockquote><p><strong>ps: 小心使用rm</strong></p><p>使用带有通配符的 rm 命令时（除了仔细检查输入的内容外）， 先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls</p></blockquote><ul><li><strong>ln — 创建硬链接和符号链接（Create hard and symbolic links）</strong></li></ul><p><strong>硬链接</strong>：是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接， 这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项</p><p>​    当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被释放）， 直到所有关联这个文件的链接都删除掉</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">ln</span> <span class="hljs-built_in">file</span> link</code></pre><p><strong>符号链接</strong>生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的<strong>文本指针</strong></p><p>​    如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">ln</span> -s <span class="hljs-keyword">item</span> link</code></pre><h3 id="2-4使用命令"><a href="#2-4使用命令" class="headerlink" title="2.4使用命令"></a>2.4使用命令</h3><ul><li><p>type – 说明一个命令名是如何被解释的（这里的“解释”是一个计算机术语，例如，解释型语言）</p><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# type lsls is aliased to `ls --color=auto&#x27;</code></pre></li><li><p>which – 显示会执行哪个<strong>可执行</strong>程序</p></li></ul><ul><li>man – 显示命令手册页</li></ul><ul><li>apropos – 显示一系列适合的命令</li></ul><ul><li>info – 显示命令 info</li></ul><ul><li>whatis – 显示一个命令的简洁描述</li></ul><ul><li>alias – 创建命令别名</li></ul><h2 id="3-I-O重定向"><a href="#3-I-O重定向" class="headerlink" title="3.I/O重定向"></a>3.I/O重定向</h2><p>通过这个机制，你可以将命令的<strong>输入来源以及输出地点</strong>重定向为文件，或把多个命令连接起来组成一个强大的<strong>命令管道</strong></p><p><strong>标准输出重定向</strong></p><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls -l /usr/bin/ &gt; ls_output.txt [root@iZ2ze9nu608mhi5at5aufaZ ~]# ls -l ls_output.txt -rw-r--r-- 1 root root 58529 Mar  2 07:26 ls_output.txt</code></pre><blockquote><p>怎样才能把重定向结果<strong>追加到</strong>文件内容后面，而不是从开头重写文件？为了这个目的，<br>我们使用”&gt;&gt;“重定向符</p></blockquote><ul><li>cat － 连接文件</li></ul><p>你可以使用 cat 来显示文件而没有分页，cat 经常被用来显示<strong>简短的文本文件</strong></p><p>如果 cat 没有给出任何参数，它会<strong>从标准输入读入数据</strong>，</p><ul><li>sort － 排序文本行</li><li>uniq － 报道或省略重复行</li><li>grep － **打印匹配行 **==&gt; 正则表达式</li></ul><blockquote><p>“-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写敏感的）; “-v”选项会告诉 grep 只打印不匹配的行</p></blockquote><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls /bin /usr/bin/ | sort | uniq | grep zipbunzip2bzip2bzip2recoverfunzipgpg-zipgunzipgzipunzipunzipsfxzipzipcloakzipgrepzipinfozipnotezipsplit</code></pre><ul><li>wc － 打印文件中<strong>换行符，字，和字节个数</strong></li></ul><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# wc test_word.txt  2  4 25 test_word.txt # 行数，单词数和字节数[root@iZ2ze9nu608mhi5at5aufaZ ~]# cat test_word.txt hello worldhuang yiheng</code></pre><ul><li>head － 输出文件开头部分</li><li>tail - 输出文件结尾部分</li></ul><blockquote><p>tail 有一个选项允许你<strong>实时地浏览文件</strong>。当观察<strong>日志文件</strong>的进展时，这很有用，因为它们同时在<strong>被写入</strong></p></blockquote><ul><li>tee - 从标准输入读取数据，并同时写到标准输出和文件</li></ul><pre><code class="hljs shell">[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls /usr/bin/ | tee ls.txt | grep zipbunzip2bzip2bzip2recoverfunzipgpg-zipgunzipgzipunzipunzipsfxzipzipcloakzipgrepzipinfozipnotezipsplit[root@iZ2ze9nu608mhi5at5aufaZ ~]# ls -l ls.txt -rw-r--r-- 1 root root 8630 Mar  2 07:46 ls.txt</code></pre><p><strong>管道</strong></p><p>命令从<strong>标准输入读取数据并输送到标准输出</strong>的能力被一个称为<strong>管道线</strong>的 shell 功能所利用。<br>使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入</p><blockquote><p>管道线经常用来对数据完成<strong>复杂的</strong>操作。有可能会把几个命令放在一起组成一个管道线。<br>通常，以这种方式使用的命令被称为<strong>过滤器</strong></p></blockquote><h1 id="二、配置文件和-shell-环境"><a href="#二、配置文件和-shell-环境" class="headerlink" title="二、配置文件和 shell 环境"></a>二、配置文件和 shell 环境</h1><h1 id="三、常见任务和基本工具"><a href="#三、常见任务和基本工具" class="headerlink" title="三、常见任务和基本工具"></a>三、常见任务和基本工具</h1>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2022/02/08/mybatis/"/>
    <url>/2022/02/08/mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>MyBatis</code> 是一款优秀的<strong>持久层框架</strong>，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过<strong>简单的 XML 或注解</strong>来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p></li><li><p>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p></li><li><p>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。</li><li>框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</li><li>二级缓存机制不佳</li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="1-导入maven"><a href="#1-导入maven" class="headerlink" title="1.导入maven"></a>1.导入maven</h2><p><code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    mybatis依赖！--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!--   mysql--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!--   引入lombok,方便编写代码--&gt;</span>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h2 id="2-创建mysql数据库"><a href="#2-创建mysql数据库" class="headerlink" title="2.创建mysql数据库"></a>2.创建mysql数据库</h2><p>创建名为<code>mybatis</code>数据库，并且创建表，如下</p><pre><code class="hljs sql"><span class="hljs-keyword">use</span> mybatis;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_account(    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span> auto_increment,    username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">11</span>),    <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">11</span>),    age <span class="hljs-built_in">int</span>)</code></pre><h2 id="3-创建与数据库对应的实体类"><a href="#3-创建与数据库对应的实体类" class="headerlink" title="3.创建与数据库对应的实体类"></a>3.创建与数据库对应的实体类</h2><p><code>Account.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.entity;<span class="hljs-comment">//实体类对应mysql中的每个字段，ORMapping ==&gt; object relationship Mapping</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><h2 id="4-创建mybatis配置文件"><a href="#4-创建mybatis配置文件" class="headerlink" title="4.创建mybatis配置文件"></a>4.创建mybatis配置文件</h2><p>在<code>resources</code>文件下下创建<code>config.xml</code>(名字可随意)</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 这里写配置内容 --&gt;</span><span class="hljs-comment">&lt;!--    mybatis运行环境 default表示选择哪个environment的id --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--            配置jdbc的事务管理--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><span class="hljs-comment">&lt;!--            利用POOLED配置JDBC数据源连接池--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;diver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h2 id="5-进行开发"><a href="#5-进行开发" class="headerlink" title="5.进行开发"></a>5.进行开发</h2><h3 id="使用原生接口"><a href="#使用原生接口" class="headerlink" title="使用原生接口"></a>使用原生接口</h3><blockquote><p>自定义SQL语句，写在<code>mapper.xml</code>文件中，实际开发，为每个实体类创建对应的<code>mapper.xml</code>定义管理该对象数据的SQL</p></blockquote><p><strong>1、创建<code>mapper</code>文件夹，并创建<code>accountMapper.xml</code></strong></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.heng.mapper.accountMapper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- SQL语句 --&gt;</span><span class="hljs-comment">&lt;!--    id为调用mybatis时用的名字,parameterType传的参数,#&#123;&#125;代码从Account类中取值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>        insert into t_account(username, password, age) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><ul><li><code>namespace</code> 推荐写为 <strong>包+ 文件名</strong> 形式</li><li>insert，select，update，delete标签表示SQL对应操作</li><li><code>id</code> 为实际调用mybatis方法时，需要用的参数</li><li><code>parameterType</code>是调用对应方法时，参数的数据类型</li></ul><p><strong>2、在全局<code>config.xml</code>文件中进行注册<code>accountMapper.xml</code></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    注册accountMapper.xml--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/heng/mapper/accountMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><p><strong>3、调用mybatis的原生接口执行添加操作</strong></p><p><img src="/2022/02/08/mybatis/01.png" alt="image-20220208093026694"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.test;<span class="hljs-keyword">import</span> com.heng.entity.Account;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//加载mybatis配置文件</span>        InputStream stream = Test.class.getClassLoader().getResourceAsStream(&quot;config.xml&quot;);        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(stream);        SqlSession sqlSession =sqlSessionFactory.openSession();        <span class="hljs-comment">//找到之前那个id,并且实例化Account对象</span>        String statement = <span class="hljs-string">&quot;com.heng.mapper.accountMapper.save&quot;</span>;        Account account = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">20</span>); <span class="hljs-comment">//需要有对应的构造方法</span>        sqlSession.insert(statement, account);<span class="hljs-comment">//插入</span>        sqlSession.commit();<span class="hljs-comment">//执行！</span>        sqlSession.close();<span class="hljs-comment">// 关闭资源</span>    &#125;&#125;</code></pre><p>在<code>Account</code>类上方加入注解，则可以不用写之前形式的构造方法，将默认有生成了构造方法</p><p><code>lombok</code>中的用法！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.entity;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><blockquote><p><code>@Data</code>： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法<br> <code>@AllArgsConstructor</code> ： 注在类上，提供类的全参构造<br> <code>@NoArgsConstructor</code> ： 注在类上，提供类的无参构造</p></blockquote><p>执行</p><p><img src="/2022/02/08/mybatis/02.png" alt="image-20220208102746371"></p><p>可看到插入成功！</p><h3 id="Mapper代理实现自定义接口"><a href="#Mapper代理实现自定义接口" class="headerlink" title="Mapper代理实现自定义接口"></a>Mapper代理实现自定义接口</h3><p><strong>推荐使用这种！</strong></p><ul><li>自定义接口，定义相关业务方法</li><li>编写与方法对应的<code>mapper.xml</code> </li></ul><p><strong>1、自定义接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.repository;<span class="hljs-keyword">import</span> com.heng.entity.Account;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">save</span><span class="hljs-params">(Account account)</span></span>; <span class="hljs-comment">//增 返回的操作值int</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Account account)</span></span>; <span class="hljs-comment">//修改</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>; <span class="hljs-comment">//通过id删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Account&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//查询全部</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>; <span class="hljs-comment">//通过id进行查询</span>&#125;</code></pre><p><strong>2、创建接口对应的<code>mapper.xml</code></strong></p><p>定义接口方法对应的SQL语句， statement标签可根据SQL执行的业务，选择insert，delete，update，select</p><p>mybatis会<strong>根据规则</strong>自动创建接口实现类的代理对象</p><ul><li><code>mapper.xml</code>中的<code>namespace</code>为接口的全类</li><li><code>mapper.xml</code>中的<code>statement</code>的<code>id</code>为接口中的对应的方法名</li><li><code>mappe.xml</code>中的statement的<code>parameterType</code>和接口中对应方法的参数类型一致</li><li><code>mappe.xml</code>中的statement的<code>resulType</code>和接口中对应方法的返回值类型一致</li></ul><p><code>repository</code>文件夹中创建<code>AccountRepository.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;com.heng.repository.AccountRepository&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>        insert into t_account(username, password, age) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>        update t_account set username=#&#123;username&#125;,password=#&#123;password&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span>        delete from t_account where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-comment">&lt;!--resultMap为集合里面泛型的类型 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>        select *from t_account    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>        select *from t_account where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p><strong>3、将上述的xml文件在全局配置<code>config.xml</code>中进行注册</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/heng/repository/AccountRepostitory.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><p><strong>4、测试</strong></p><p>创建<code>Test02.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.test;<span class="hljs-keyword">import</span> com.heng.entity.Account;<span class="hljs-keyword">import</span> com.heng.repository.AccountRepository;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//加载mybatis配置文件</span>        InputStream stream = Test.class.getClassLoader().getResourceAsStream(&quot;config.xml&quot;);        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(stream);        SqlSession sqlSession =sqlSessionFactory.openSession();        <span class="hljs-comment">//获取实现接口的代理对象</span>        AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class);        <span class="hljs-comment">//查询全部</span>        List&lt;Account&gt; list = accountRepository.findAll();        <span class="hljs-keyword">for</span> (Account account:list) &#123;            System.out.println(account);        &#125;    &#125;&#125;</code></pre><p>结果如图  说明执行成功</p><p><img src="/2022/02/08/mybatis/03.png" alt="image-20220208154604772"></p><p><strong>测试增加数据</strong></p><pre><code class="hljs java"><span class="hljs-comment">//添加</span>Account account = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">30</span>);accountRepository.save(account);sqlSession.commit();<span class="hljs-comment">//只要是对数据库 增删改 都要进行commit！</span></code></pre><p><img src="/2022/02/08/mybatis/04.png" alt="image-20220208154948877"></p><p><strong>通过id进行查询</strong></p><pre><code class="hljs java"><span class="hljs-comment">//通过id进行查询</span>Account account = accountRepository.findById(<span class="hljs-number">3</span>);System.out.println(account);sqlSession.close();</code></pre><p><img src="/2022/02/08/mybatis/05.png" alt="image-20220208155157395"></p><p><strong>进行更改</strong></p><pre><code class="hljs java"><span class="hljs-comment">//测试update</span>Account account = accountRepository.findById(<span class="hljs-number">3</span>);account.setAge(<span class="hljs-number">18</span>);account.setUsername(<span class="hljs-string">&quot;小黄&quot;</span>);account.setPassword(<span class="hljs-string">&quot;119&quot;</span>);<span class="hljs-keyword">int</span> result = accountRepository.update(account); <span class="hljs-comment">//返回修改的行数</span>sqlSession.commit(); System.out.println(result); <span class="hljs-comment">//打印1</span>sqlSession.close();</code></pre><p>结果如图</p><p><img src="/2022/02/08/mybatis/06.png" alt="image-20220208155931846"></p><p><strong>通过id进行删除</strong></p><pre><code class="hljs java"><span class="hljs-comment">//删除</span><span class="hljs-keyword">int</span> result = accountRepository.deleteById(<span class="hljs-number">2</span>); <span class="hljs-comment">//id = 2的删除</span>System.out.println(result);sqlSession.commit();sqlSession.close();</code></pre><p>如图所示，id为2的已被删除</p><p><strong><img src="/2022/02/08/mybatis/07.png" alt="image-20220208160235781"></strong></p><h1 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h1><ul><li><p><code>statement</code>标签：select，update，delete，insert分别对应查询，修改，删除，添加</p></li><li><p><code>parameterType</code> ： 参数数据类型</p><p>1、基本数据类型，如上方的id对应long，通过id查询Account</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>  select *from t_account where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>2、String类型，比如通过name查询Account</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>  select *from t_account where username = #&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul><p>​        3、包装类，通过id查询Account</p><p>上述的<code>parameterType=&quot;long&quot;</code> 可写成 <code>parameterType=&quot;java.lang.Long&quot;</code></p><p>​        4、多个参数，通过name和age进行查询 （此时通过下标</p><pre><code class="hljs java"><span class="hljs-comment">//AccountRepository接口中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findByAgeAndName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age,String name)</span></span>;<span class="hljs-comment">//通过姓名和年龄查询</span>&#125;</code></pre><p><code>AccountRepository.xml</code> 中，不用写parameterType</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByAgeAndName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>    select *from t_account where age = #&#123;param1&#125; and  username = #&#123;param2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>​        5、java bean  比如修改</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.heng.entity.Account&quot;</span>&gt;</span>    update t_account set username=#&#123;username&#125;,password=#&#123;password&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre><ul><li>resultType 结果类型  (和<code>parameterType</code>基本相同)<ul><li>基本数据类型</li><li>包装类</li><li>java bean</li></ul></li></ul><h1 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/02/05/spring/"/>
    <url>/2022/02/05/spring/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p> Spring是一个<strong>轻量级</strong>的<strong>控制反转(IoC)**和</strong>面向切面(AOP)**的容器框架 (两个核心特性！！！)</p></blockquote><p>Spring框架是由于<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/3448966">软件开发</a>的复杂性而创建的，简化开发</p><p>Spring使用的是基本的<a href="https://baike.baidu.com/item/JavaBean/529577">JavaBean</a>来完成以前只可能由<a href="https://baike.baidu.com/item/EJB/144195">EJB</a>完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><ul><li>创建 Spring 的主要目的是用来替代更加重量级的企业级 Java 技术</li></ul><p><strong>优点</strong></p><ul><li>简化开发，解耦，集成其它框架。</li><li>低侵入式设计，代码污染级别较低。</li><li>Spring的DI机制降低了业务对象替换的复杂性，提高了软件之间的解耦。</li><li>Spring AOP支持将一些通用的任务进行集中式的管理，例如：安全，事务，日志等，从而使代码能更好的复用。</li></ul><p><strong>组成</strong></p><p>七大部分</p><p><img src="/2022/02/05/spring/01.png"></p><p>导入maven依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 整合jdbc --&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h1><blockquote><p>JavaBean就是有一定规范的Java实体类</p><p>跟普通类差不多，不同的是类内部提供了一些<strong>公共的方法</strong>以便外界对该对象内部属性进行操作\</p></blockquote><p>比如：</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><h1 id="Ioc思想"><a href="#Ioc思想" class="headerlink" title="Ioc思想"></a>Ioc思想</h1><p><strong>(Inversion of Control)</strong></p><p><strong>以前的思路</strong></p><p>1.UserDao接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//定义接口</span>&#125;</code></pre><p>2、UserDaoImpl实现类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;获取用户数据&quot;</span>);    &#125;&#125;</code></pre><p>3、UserService业务接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>4、UserServiceImpl业务接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;    <span class="hljs-comment">//引入Dao</span>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        userDao.getUser();<span class="hljs-comment">//业务层调用dao层</span>    &#125;&#125;</code></pre><p><code>Test</code>类，用户测试</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//实际调用业务层，dao层不接触</span>        UserService service = <span class="hljs-keyword">new</span> UserServiceImpl();        service.getUser();    &#125;&#125;</code></pre><p>由于<code>  private UserDao userDao = new UserDaoImpl();</code>是程序<strong>主动创建对象</strong></p><p>若又增加其他的内容，如<code>UsermysqlImpl</code>,<code>UserSqlserverImpl....</code></p><p>此时，将需要进行对业务层<code>UserServiceImpl.java</code>进行修改代码(<strong>繁琐！！</strong>)</p><p>如何解决？！</p><p>将<code>UserServiceImpl.java</code> 中那条语句进行修改</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> UserDao userDao;<span class="hljs-comment">//利用set动态实现值的注入</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;    <span class="hljs-keyword">this</span>.userDao = userDao;&#125;</code></pre><p>  测试类<code>MyTest.java</code>进行调用</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//实际调用业务层，dao层不接触</span>        UserService service = <span class="hljs-keyword">new</span> UserServiceImpl();        <span class="hljs-comment">//调用UserServiceImpl中set</span>        ( (UserServiceImpl) service).setUserDao(<span class="hljs-keyword">new</span> UserDaoImpl());        service.getUser();    &#125;&#125;</code></pre><p>若有mysql</p><pre><code class="hljs java"><span class="hljs-comment">//调mysql对应的</span>( (UserServiceImpl) service).setUserDao(<span class="hljs-keyword">new</span> UserMysqlImpl()); <span class="hljs-comment">//只需完成业务实现代码 即UserMysqlImpl.java的实现，  然后改变测试类即可</span></code></pre><p>此时使用set注入后，程序不再具有主动性，而是<strong>被动的接收对象</strong>！</p><p>这种思想，使得程序员不需要管理对象的创建了，系统耦合性降低，只需要专注业务实现</p><p>这中思想即<code>Ioc</code>的原型</p><p><img src="/2022/02/05/spring/02.png" alt="image-20220205072316986"></p><p><strong>DI(依赖注入)是实现IoC的一种方法</strong></p><p><code>Ioc</code>（控制反转）即获得依赖的方式反转了！  </p><p>总：</p><blockquote><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。</strong></p><p><strong>在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p></blockquote><p><strong>再探索</strong></p><p>创建<code>Hello.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.pojo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//字段</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello,&quot;</span>+ name );    &#125;&#125;</code></pre><p>在<code>resources</code>下创建<code>beans.xml</code>文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.pojo.Hello&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><blockquote><p>类型 变量名 = new 类型(); ==&gt; Hello hello = new Hello();</p><p>在xml文件中</p><p>bean中的id= 上方变量名，class = new的对象，property相当于给对象中的属性设值</p></blockquote><p>配置之后进行测试 <code>Test.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.heng.pojo.Hello;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span>        <span class="hljs-comment">//获得上下文，拿到spring容器(核心！)当然，也可以不用xml配置</span>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);        <span class="hljs-comment">//getBean : 参数即为spring配置文件中bean的id .</span>        Hello hello = (Hello) context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);        hello.show();    &#125;&#125;</code></pre><p>运行测试类中的<code>main</code>  打印出<code>Hello,Spring</code></p><ul><li><p>对象谁创建的==&gt; <code>spring</code></p></li><li><p>属性如何设置的===&gt; <code>spring容器</code></p></li></ul><p>即<strong>控制反转</strong>  </p><ul><li>控制 :  传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , <strong>对象是由Spring来创建的</strong></li><li>反转 : 程序本身不创建对象 , 而变成<strong>被动的接收对象</strong> .</li></ul><p><strong>只需要在xml配置文件中进行修改 , 所谓的IoC即对象由Spring 来创建 , 管理 , 装配 !</strong></p><p><img src="https://images0.cnblogs.com/blog/281227/201305/30131727-a8268fe6370049028078e6b8a1cbc88f.png" alt="img"></p><h1 id="spring开发步骤"><a href="#spring开发步骤" class="headerlink" title="spring开发步骤"></a>spring开发步骤</h1><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203100951372.png" alt="image-20220310095135197"></p><ul><li>1、导入spring开发的基本包</li></ul><p><code>xml中</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><ul><li>2、编写Dao接口以及实现类</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.dao;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<span class="hljs-comment">//定义接口</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>对应实现类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.dao.iml;<span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!!&quot;</span>);    &#125;&#125;</code></pre><ul><li>3、创建spring核心配置文件</li></ul><p>在<code>resources</code>下创建<code>applicationContext.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.dao.iml.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><ul><li>4、在spring配置文件中配置<code>UserDaoImpl</code></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.dao.iml.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li>5、使用spring的API获得<code>Bean</code>示例</li></ul><p>创建<code>UserDaoDemo.java</code>测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.demo;<span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        UserDao userDao =(UserDao) app.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);        userDao.save(); <span class="hljs-comment">//此时将打印出  hello!!</span>    &#125;&#125;</code></pre><h1 id="spring配置"><a href="#spring配置" class="headerlink" title="spring配置"></a>spring配置</h1><h2 id="Bean标签基本配置"><a href="#Bean标签基本配置" class="headerlink" title="Bean标签基本配置"></a>Bean标签基本配置</h2><p><strong><code>scope</code> 对象的作用范围 ：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203101028520.png" alt="image-20220310102804245"></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.dao.iml.UserDaoImpl&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>此时进行测试</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        ApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        UserDao userDao1 = (UserDao)app.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);        UserDao userDao2 = (UserDao)app.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);        System.out.println(userDao1);        System.out.println(userDao2);    &#125;&#125;</code></pre><p>控制台打印</p><p>com.heng.dao.iml.UserDaoImpl@6b57696f<br>com.heng.dao.iml.UserDaoImpl@5bb21b69</p><p><strong><code>Bean</code>标签范围</strong> :</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203101043641.png" alt="image-20220310104344523"></p><p><code>Bean</code> 生命周期配置 <strong>(了解)</strong></p><ul><li><code>init-method</code> 指定类中的<strong>初始化</strong>方法名称</li><li><code>destory-method</code> ：指定类中<strong>销毁</strong>方法名称</li></ul><p>在<code>UserDaoImpl.java</code>中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;初始化。。。。&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;销毁。。。。&quot;</span>);&#125;</code></pre><p>配置文件中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.dao.iml.UserDaoImpl&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>进行测试</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        ApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        UserDao userDao1 = (UserDao)app.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);        System.out.println(userDao1);    &#125;&#125;</code></pre><blockquote><p><strong>打印：</strong></p><p>UserDaoImpl创建。。。。<br>初始化。。。。<br>com.heng.dao.iml.UserDaoImpl@e874448</p></blockquote><p>此时并没有打印<code>销毁</code> 因为没来得及打印就执行结束</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    ClassPathXmlApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);    UserDao userDao1 = (UserDao)app.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);    System.out.println(userDao1);    app.close();&#125;<span class="hljs-comment">/* 此时进行打印可得:</span><span class="hljs-comment">UserDaoImpl创建。。。。</span><span class="hljs-comment">初始化。。。。</span><span class="hljs-comment">com.heng.dao.iml.UserDaoImpl@e874448</span><span class="hljs-comment">销毁。。。。</span><span class="hljs-comment">*/</span></code></pre><p><strong>bean实例化的三种方式</strong></p><ul><li>无参构造**(重要)**</li><li>工厂静态 方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.factory;<span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">import</span> com.heng.dao.iml.UserDaoImpl;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDao <span class="hljs-title">getUserDao</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> UserDaoImpl(); <span class="hljs-comment">//返回对应实例</span>    &#125;&#125;</code></pre><p>配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.factory.StaticFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getUserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li>工厂实例方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.factory;<span class="hljs-keyword">import</span> com.heng.dao.UserDao;<span class="hljs-keyword">import</span> com.heng.dao.iml.UserDaoImpl;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDao <span class="hljs-title">getUserDao</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> UserDaoImpl(); <span class="hljs-comment">//返回对应实例</span>    &#125;&#125;</code></pre><p>配置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--工厂实例方法--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;factory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.factory.StaticFactory&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;factory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getUserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>当有两个需要加载时，默认是按照书写的顺序进行</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Student&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Card&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>分别调用对应<code>构造方法</code> 打印，当进行测试时</p><pre><code class="hljs routeros">Student被构造<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>Card被构造<span class="hljs-built_in">..</span>.</code></pre><p>可以通过<code>depends-on</code> 来改变顺序</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Student&quot;</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Card&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>此时打印</p><pre><code class="hljs routeros">Card被构造<span class="hljs-built_in">..</span>.Student被构造<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span></code></pre><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul><li>构造方法</li><li>set方法</li></ul><blockquote><p>注入默认的类型，自己定义的类，集合，以及map</p></blockquote><ol><li>先在类中进行相对应的定义</li><li>写默认的<code>set方法(或构造方法)</code>，表示从外界进行注入时，就调用它</li><li>配置<code>xml</code></li><li>测试</li></ol><p><code>Student.java</code> 实体类中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.entity;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    String name; <span class="hljs-comment">//基本类型</span>    <span class="hljs-keyword">int</span> age;    Card card; <span class="hljs-comment">// 自己定义类,进行注入</span>    List&lt;Double&gt; list; <span class="hljs-comment">// 注入list(集合类型</span>    Map&lt;String,Double&gt; map; <span class="hljs-comment">// 通过map注入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCard</span><span class="hljs-params">(Card card)</span> </span>&#123;        <span class="hljs-keyword">this</span>.card = card;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setList</span><span class="hljs-params">(List&lt;Double&gt; list)</span> </span>&#123;        <span class="hljs-keyword">this</span>.list = list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMap</span><span class="hljs-params">(Map&lt;String, Double&gt; map)</span> </span>&#123;        <span class="hljs-keyword">this</span>.map = map;    &#125;&#125;</code></pre><p>配置<code>xml</code> 文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;userDao&quot; class=&quot;com.heng.factory.StaticFactory&quot; factory-method=&quot;getUserDao&quot;&gt;&lt;/bean&gt;--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Card&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.entity.Student&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;double&quot;</span>&gt;</span>100.0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;double&quot;</span>&gt;</span>20.0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;double&quot;</span>&gt;</span>30.0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;数学&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;语文&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>测试控制台打印</p><pre><code class="hljs apache"><span class="hljs-attribute">Student</span>(name=小明, age=<span class="hljs-number">20</span>, card=com.heng.entity.Card@<span class="hljs-number">67784306</span>, list=[<span class="hljs-number">100</span>.<span class="hljs-number">0</span>, <span class="hljs-number">20</span>.<span class="hljs-number">0</span>, <span class="hljs-number">30</span>.<span class="hljs-number">0</span>], map=&#123;数学=<span class="hljs-number">100</span>.<span class="hljs-number">0</span>, 语文=<span class="hljs-number">80</span>.<span class="hljs-number">0</span>&#125;)</code></pre><p>也可以不用默认的无参构造，而使用有参构造进行注入</p><p>在<code>Student.java</code> 下 添加有参构造</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;</code></pre><p>配置<code>xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;heng&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>此时已经注入</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><blockquote><p>自动在容器中查找是否存在<strong>对应类型</strong>或是<strong>对应名称</strong>以及对应构造方法的Bean</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Card&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span></code></pre><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>(Aspect Oriented Programming)  面向切面编程</p><p><strong>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程</strong></p><blockquote><p>旨在将**<a href="https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9">横切关注点</a>与业务主体<strong>进行进一步分离，以提高程序代码的<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B">模块化</a>程度。通过在现有代码基础上增加额外的</strong>通知**（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以<code>set*</code>开头的方法添加后台日志”。</p><p>该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。</p></blockquote><p>相当于我们的整个业务流程，被直接斩断，并<strong>在断掉的位置添加了一个额外的操作</strong>，再连接起来，也就是在一个切点位置插入内容。<strong>它的原理实际上就是通过动态代理机制实现的</strong></p><p><code>Spring</code>底层不是使用的<code>JDK</code>提供的动态代理，而是<strong>使用的第三方库</strong>实现，它能够以父类的形式代理，而不是接口</p><h2 id="使用springAOP"><a href="#使用springAOP" class="headerlink" title="使用springAOP"></a>使用springAOP</h2><p>实际上它整合了<code>AspectJ</code>框架的一部分</p><p>1、导入对应依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2、明确以下动作</p><ul><li>需要切入的类，类的哪个方法是需要被切入</li><li>切入后执行什么动作</li><li>是在方法前还是方法后进行切入</li><li>如何告诉spring进行切入</li></ul><p>例如：</p><p>先在<code>Student.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.entity;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//要在say之前和之后实现 切入(完成打印日志的操作)</span>    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String meg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我叫&quot;</span> + name + <span class="hljs-string">&quot;今年&quot;</span> + age + <span class="hljs-string">&quot;我说&quot;</span> + meg);    &#125;&#125;</code></pre><p>定义单独的类，来完成相应的操作 ，在<code>AopTest.java</code> 中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.aop;<span class="hljs-keyword">import</span> lombok.extern.java.Log;<span class="hljs-meta">@Log</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;after....&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;before....&quot;</span>);    &#125;&#125;</code></pre><p>现在将新对应的<code>Student</code> 和 <code>AopTest</code> 类 注册为<code>Bean</code> ，配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aopTest&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.aop.AopTest&quot;</span>/&gt;</span></code></pre><p>此时就交给了<code>spring</code> 进行管理</p><p>改变<code>xml</code>头部，引入<code>aop</code> 相关标签</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;userDao&quot; class=&quot;com.heng.factory.StaticFactory&quot; factory-method=&quot;getUserDao&quot;&gt;&lt;/bean&gt;--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;aopTest&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.aop.AopTest&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aopTest&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.heng.entity.Student.say(String))&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;stu&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:after-returning</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aopTest&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu2&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;@annotation(Deprecated)&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;stu2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:before</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>在测试类<code>StudentDemo.java     </code>中运行测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.demo;<span class="hljs-keyword">import</span> com.heng.entity.Student;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ClassPathXmlApplicationContext app = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        Student student = (Student) app.getBean(Student.class);        System.out.println(student.getClass()); <span class="hljs-comment">//看一下对应的类</span>        student.say(<span class="hljs-string">&quot;你好&quot;</span>);    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203120707346.png" alt="image-20220312070709204"></p><p>发现在打印<code>say</code>前后，均打印出了日志</p><p><strong>配置文件说明</strong></p><p>​    通过<code>aop:config</code> 来添加一个新的<code>aop</code>配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre><p><code>aop:pointcut</code> 告诉spring，要切入的是哪个类/哪个方法</p><p><code>expression</code>属性的<code>execution</code>填写格式如下：</p><pre><code class="hljs gcode">修饰符 包名.类名.方法名称<span class="hljs-comment">(方法参数)</span></code></pre><ul><li>修饰符：<code>public</code>、<code>protected</code>、<code>private</code>、包括返回值类型、<code>static</code>等等（使用*代表任意修饰符）</li><li>包名：如com.test（*代表全部，比如com.*代表com包下的全部包）</li><li>类名：使用*也可以代表包下的所有类</li><li>方法名称：可以使用*代表全部方法</li><li>方法参数：填写对应的参数即可，比如(String, String)，也可以使用*来代表任意一个参数，使用..代表所有参数。</li></ul><p>也可以使用其他属性来进行匹配，比如<code>@annotation</code>可以用于表示标记了哪些注解的方法被切入。</p><p>之后可添加执行前和执行后的动作 <code>aop:after-returning</code> 和 <code>aop:before</code></p><blockquote><p>我们想得到方法执行的<strong>一些参数</strong>，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等。</p></blockquote><p>在对应方法上加上<code>JoinPoint point </code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">(JoinPoint point)</span> </span>&#123;    System.out.println(Arrays.toString(point.getArgs()));<span class="hljs-comment">//获得传入的参数，打印[你好]</span>    log.info(<span class="hljs-string">&quot;after....&quot;</span>);&#125;</code></pre><p><strong>环绕方法</strong></p><p>在<code>aopTest.java</code> 中添加</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;around....&quot;</span>);&#125;</code></pre><p><code>xml</code> 中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aopTest&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu3&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;@annotation(Deprecated)&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;around&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;stu3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:around</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203121548849.png" alt="image-20220312154811727"></p><p>发现之前的<code>say</code> 方法并没有打印输出了</p><blockquote><p>环绕方法相当于<strong>完全代理</strong>了此方法，它完全将此方法包含在中间，需要我们<strong>手动调用</strong>才可以执行此方法</p></blockquote><p><code>around</code>方法中提供参数<code>ProceedingJoinPoint joinPoint</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    joinPoint.proceed();<span class="hljs-comment">//利用joinPoint这个对象，让原来方法执行</span>    System.out.println(<span class="hljs-string">&quot;around....&quot;</span>);&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203121553345.png" alt="image-20220312155327260"></p><h2 id="使用接口实现AOP"><a href="#使用接口实现AOP" class="headerlink" title="使用接口实现AOP"></a>使用接口实现AOP</h2><p>新建<code>AopTest02.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.aop;<span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">//此处也可以继承AfterReturningAdvice 来实现方法之后的操作</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法名字&quot;</span> + method.getName());        System.out.println(<span class="hljs-string">&quot;方法参数&quot;</span> + Arrays.toString(objects));         System.out.println(<span class="hljs-string">&quot;方法执行的对象&quot;</span> + o);        System.out.println(<span class="hljs-string">&quot;通过接口实现aop&quot;</span>);    &#125;&#125;</code></pre><p>进行对应配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aopTest02&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.heng.aop.AopTest02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu4&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.heng.entity.Student.say(String))&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;aopTest02&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;stu4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203121614769.png" alt="image-20220312161407696"></p><p><strong>一些术语</strong></p><ul><li>通知（Advice）: AOP 框架中的增强处理，通知描述了切面何时执行以及如何执行增强处理，也就是我们上面编写的方法实现。</li><li>连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。</li><li>切点（PointCut）: 可以插入增强处理的连接点，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。</li><li>切面（Aspect）: 切面是通知和切点的结合，我们之前在xml中定义的就是切面，包括很多信息。</li><li>引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li><li>织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，我们之前都是在将我们的增强处理添加到目标对象，也就是织入</li></ul><h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><p><code>xml</code> 了解即可！</p><h2 id="注解实现配置文件"><a href="#注解实现配置文件" class="headerlink" title="注解实现配置文件"></a>注解实现配置文件</h2><p>需要配置类加上<code>@Configuration</code> 此注解来配置即可</p><p>创建<code>MainConfig.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.Config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//表示是配置的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;  &#125;</code></pre><p>等价上 <code>xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 没有配置任何Bean --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h3 id="利用bean注解"><a href="#利用bean注解" class="headerlink" title="利用bean注解"></a>利用bean注解</h3><p>在类中的方法中 只需要编写一个方法，并返回我们要创建的<code>Bean</code>的对象即可，并在其上方添加<code>@Bean</code>注解</p><p>比如先创建<code>Student.java</code> 类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.bean;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p>只需在刚刚的<code>MainConfig.java</code> 中添加</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">// @Scope(&quot;prototype&quot;) 可以指定范围</span><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span> </span>&#123;    Student student = <span class="hljs-keyword">new</span> Student();    student.setName(<span class="hljs-string">&quot;yiheng&quot;</span>); <span class="hljs-comment">//设置对应的名字</span>    <span class="hljs-keyword">return</span> student; <span class="hljs-comment">//进行返回</span>&#125;</code></pre><p>在主类<code>Main.java</code>中进行测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.test;<span class="hljs-keyword">import</span> com.heng.Config.MainConfig;<span class="hljs-keyword">import</span> com.heng.bean.Student;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);        Student student = context.getBean(Student.class);        System.out.println(student);    &#125;&#125;</code></pre><p>运行打印出 <code>Student(name=yiheng, age=0)</code> 同时可观察具体信息</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203131039588.png" alt="image-20220313103858428"></p><p>还一种<strong>更常用的方式</strong></p><h3 id="利用Component注解"><a href="#利用Component注解" class="headerlink" title="利用Component注解"></a>利用Component注解</h3><p>直接在类上添加<code>@Component</code>注解来将一个类进行注册，但要添加相关扫描</p><p>来告诉Spring需要在哪些包中查找我们提供<code>@Component</code>声明的Bean</p><p>即在配置类上添加一个<code>@ComponentScan</code>注解</p><p>此时配置类变为</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(&quot;com.heng.bean&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;   &#125;</code></pre><p>对应的Student类上加上<code>@Component</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.bean;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@ToString</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    String name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p>只需在主测试中调用方法赋予<code>name</code>值即可</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.test;<span class="hljs-keyword">import</span> com.heng.Config.MainConfig;<span class="hljs-keyword">import</span> com.heng.bean.Card;<span class="hljs-keyword">import</span> com.heng.bean.Student;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);        Student student = context.getBean(Student.class);        student.setName(<span class="hljs-string">&quot;yiheng&quot;</span>);        System.out.println(student);    &#125;&#125;</code></pre><p>可看到打印成功</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203131056902.png" alt="image-20220313105645837"></p><p><strong>自动装配</strong></p><ul><li><p><code>@Resource</code>注解</p></li><li><p><code>@Autowired</code> 注解（IDEA不推荐将其使用在字段上，会出现黄标，但是可以放在方法或是构造方法上）</p><ul><li>@Resource默认<strong>ByName</strong>如果找不到则<strong>ByType</strong>，可以添加到set方法、字段上。</li></ul><ul><li>@Autowired默认是<strong>byType</strong>，可以添加在构造方法、set方法、字段、方法参数上。</li></ul></li></ul><p>还可以通过<code>@PostConstruct</code>注解来添加构造后执行的方法，它等价于之前讲解的<code>init-method</code></p><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;我是初始化方法！&quot;</span>);&#125;</code></pre><p><strong>执行顺序</strong>：Constructor(构造方法) –&gt; @Autowired(依赖注入) –&gt; @PostConstruct</p><p>同时也要对应销毁方法<code>@PreDestory</code>注解</p><ul><li>如果要注册为Bean的类是由<strong>其他框架</strong>提供，我们<strong>无法修改其源代码</strong>，那么我们就使用第一种方式进行配置。</li><li>如果要注册为Bean的类是我们<strong>自己编写</strong>的，我们就可以直接在类上添加注解，并在配置中添加扫描。</li></ul><h2 id="注解实现AOP"><a href="#注解实现AOP" class="headerlink" title="注解实现AOP"></a>注解实现AOP</h2><p>在配置类中添加<code>@EnableAspectJAutoProxy</code></p><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-meta">@ComponentScan(&quot;com.test.bean&quot;)</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfiguration</span> </span>&#123;&#125;</code></pre><p>定义<code>aop</code>操作的类，只需在类上面添加<code>@Aspect</code>注解和<code>@Component</code>将其注册为Bean即可</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;&#125;</code></pre><p>别忘记在配置类中，将其配置上自动扫描，这样才可以识别</p><p>则<code>MainConfig.java</code> 中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.Config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScans;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScans( &#123;</span><span class="hljs-meta">        @ComponentScan(&quot;com.heng.bean&quot;),</span><span class="hljs-meta">        @ComponentScan(&quot;com.heng.aop&quot;)</span><span class="hljs-meta">&#125;)</span><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;&#125;</code></pre><p>在<code>Student.java</code> 中添加对应的方法，比如<code>say</code>表明要在此方法前/后切入对应的操作</p><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(String msg)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;我是say...&quot;</span>);    <span class="hljs-keyword">return</span> msg;&#125;</code></pre><p>在aop类中，添加<code>before</code>和 <code>after</code>逻辑</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.aop;<span class="hljs-keyword">import</span> lombok.extern.java.Log;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span> <span class="hljs-meta">@Log</span> <span class="hljs-comment">//利用log打印一些信息</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;    <span class="hljs-meta">@Before(&quot;execution(* com.heng.bean.Student.say(String))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;我是before要在say之前执行....&quot;</span>);    &#125;    <span class="hljs-meta">@After(&quot;@annotation(Deprecated)&quot;)</span> <span class="hljs-comment">//因为say方法前添加了对应注解，故可以利用此方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;我是after，在say之后切入执行&quot;</span>);    &#125;&#125;</code></pre><p>主类<code>Main.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.test;<span class="hljs-keyword">import</span> com.heng.Config.MainConfig;<span class="hljs-keyword">import</span> com.heng.bean.Student;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);        Student student = context.getBean(Student.class);        System.out.println(student.say(<span class="hljs-string">&quot;yh&quot;</span>));    &#125;&#125;</code></pre><p>运行如图</p><p><img src="https://cdn.jsdelivr.net/gh/codeheng/personPic@main/imgBlog/202203132037251.png" alt="image-20220313203722098"></p><p>也可以用样的使用<code>JoinPoint point</code> 作为参数来获取切入点信息</p><p>或使用<code>@AfterReturning</code>注解来指定方法返回后的操作</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有可能会根据模块划分，定义<strong>多个配置文件</strong>，这个时候，可能会出现很多个配置类</p><p>如果我们需要<code>@Import</code>注解来快速将某个类加入到容器中</p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤器和监听器</title>
    <link href="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <url>/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h1><blockquote><p><code>Model</code> 模型：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</p><p><code>View</code> 视图 ： 界面设计人员进行图形界面设计。</p><p><code>Controller控制器</code>:  负责转发请求，对请求进行处理。</p></blockquote><p><strong>以前的架构</strong></p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/01.png" alt="image-20220204091903472"></p><blockquote><p>servlet ==&gt; CRUD ==&gt; 数据库</p><p>不利于维护</p><p>如何解决：再加一层！</p></blockquote><p><strong>如今的架构(微服务之后又变了)</strong></p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/02.png" alt="image-20220204092139132"></p><p><code>Model</code></p><ul><li>业务处理 : 业务相关的逻辑(Service)</li><li>数据持久层: crud （dao)</li></ul><p><code>View</code></p><ul><li>展示数据</li><li>提供链接发起<code>Servlet</code>请求（a标签，form，img….)</li></ul><p><code>Controller</code> (servlet)</p><ul><li>接收用户请求 (请求参数，session信息)</li><li>交给业务层处理对应的代码</li><li>控制视图的跳转</li></ul><blockquote><p>登陆 ==&gt; 接收用户的登陆请求 ==&gt; 处理用的请求(获取登陆参数:用户名和密码) ==&gt; 交给业务层处理登陆业务(判断是否正确：事务) </p><p>===&gt; Dao层查询用户和密码是否做正确  ==&gt; 数据库</p></blockquote><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><blockquote><p>  <strong>Filter</strong>是一个可重复使用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一资源的响应。</p></blockquote><p><code>Filter</code> 过滤网站的数据</p><ul><li>处理乱码</li><li>登陆验证….</li></ul><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/03.png" alt="image-20220204103114809"></p><p><strong>1.添加<code>maven</code>依赖，导包</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Servlet依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-comment">&lt;!-- jsp依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- JSTL表达式依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- standard标签库依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!-- JDBC依赖 mysql此时版本8.026--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p><strong>2、重写方法，并配置</strong></p><p>​    <code>Filter01.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.filter;<span class="hljs-keyword">import</span> javax.servlet.*; <span class="hljs-comment">//是servlet中的 Filter</span><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">//过滤 ==&gt; 编码均设为utf-8</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filter01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-comment">//初始化，web服务器一启动就初始化，随时等待过滤</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        System.out.println(<span class="hljs-string">&quot;初始化....&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//设置编码</span>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);        System.out.println(<span class="hljs-string">&quot;执行前!!!&quot;</span>);        filterChain.doFilter(servletRequest,servletResponse);<span class="hljs-comment">//此时才执行，不写则无效，将停止</span>        System.out.println(<span class="hljs-string">&quot;执行后！！！&quot;</span>);    &#125;    <span class="hljs-comment">//销毁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;销毁....&quot;</span>);    &#125;&#125;</code></pre><p><code>ShowServlet.java</code> 提供页面文字，让过滤器过滤成正确文本</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        resp.getWriter().write(<span class="hljs-string">&quot;你好！世界&quot;</span>);<span class="hljs-comment">//中文，若不设置编码，则出现乱码</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>showServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/show<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>showServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/show<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.heng.filter.Filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>filter01<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--        只要/servlet下任何请求，将经过过滤器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/show</code>时，则出现乱码</p><p>当访问<code>http://localhost:8080/servlet/show</code>时，则正确输出，进行了过滤</p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><blockquote><p>​    <strong>Listener</strong>是监听器，通过Listener可以监听Web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的来说就是在Application，Session，Request三个对象创建、消亡或者往其中添加、修改、删除属性时自动执行代码功能的组件。</p></blockquote><p>先导包(和上面同)</p><p>创建<code>Listener01.java</code></p><pre><code class="hljs java"><span class="hljs-comment">//统计网站在线人数</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;    <span class="hljs-comment">//创建session监听,一旦创建session就会触发</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        ServletContext context = se.getSession().getServletContext();        System.out.println(se.getSession().getId());<span class="hljs-comment">//打印session的id</span>        Integer count = (Integer) context.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) &#123;            count = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            count = <span class="hljs-keyword">new</span> Integer( count.intValue() + <span class="hljs-number">1</span>);        &#125;        context.setAttribute(<span class="hljs-string">&quot;count&quot;</span>,count);    &#125;    <span class="hljs-comment">//销毁session监听</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        ServletContext context = se.getSession().getServletContext();        Integer count = (Integer) context.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) &#123;            count = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            count = <span class="hljs-keyword">new</span> Integer( count.intValue() - <span class="hljs-number">1</span>);        &#125;        context.setAttribute(<span class="hljs-string">&quot;count&quot;</span>,count);    &#125;&#125;</code></pre><p><code>index.jsp</code>中添加</p><pre><code class="hljs jsp">&lt;h1&gt; 当前有 &lt;span&gt; &lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;count&quot;)%&gt; 人&lt;/span&gt; &lt;/h1&gt;</code></pre><p>配置<code>web.xml </code>添加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.heng.listener.Listener01<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre><p>运行可能会显示<code>3</code>个,再重新<code>redeploy部署</code>一下，此时将成为1人，当开启多个浏览器打开此页面时，人数将会变多，不同id打印输出</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/04.png" alt="image-20220204121053597"></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p><strong>权限拦截</strong></p><ul><li>用户登陆正确才可以进入主页，进入之后可以注销，注销了就不可以直接再进入了，除非再登陆，输入不对，则返回错误页面</li><li>进入主页要判断是否已经登陆 (过滤器)</li></ul><p><code>login.jsp</code> 登陆页面</p><pre><code class="hljs jsp">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;/servlet/login&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> &gt;    用户:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt; &lt;br&gt;    密码:&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>LoginServlet.java</code></p><p> 对登陆页面进入处理，若输入用户名<code>root</code>和密码<code>123</code>则登陆成功，进行跳转重定向到<code>success.jsp</code>，否则到<code>error.jsp</code>中</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/servlet/login&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);        <span class="hljs-comment">//登陆成功</span>        <span class="hljs-keyword">if</span> (username.equals(<span class="hljs-string">&quot;root&quot;</span>) &amp;&amp; password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;            req.getSession().setAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>,req.getSession().getId());            resp.sendRedirect(<span class="hljs-string">&quot;/sys/success.jsp&quot;</span>);        &#125;        <span class="hljs-comment">//失败</span>        <span class="hljs-keyword">else</span> &#123;            resp.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>success.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登陆成功！&lt;/h1&gt;&lt;p&gt; &lt;a href=&quot;/servlet/logout&quot;&gt;注销&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>error.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;a href=&quot;/login.jsp&quot;&gt;返回登陆页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>LogoutServlet.java</code> 登陆成功后，可进行注销，点击<strong>注销</strong>到此处进行处理</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/servlet/logout&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogoutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        Object user_session = req.getSession().getAttribute(Constant.USER_SESSION);<span class="hljs-comment">//取得信息</span>        <span class="hljs-keyword">if</span> (user_session != <span class="hljs-keyword">null</span>) &#123;            req.getSession().removeAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>);<span class="hljs-comment">//移除session的信息</span>            resp.sendRedirect(<span class="hljs-string">&quot;/login.jsp&quot;</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            resp.sendRedirect(<span class="hljs-string">&quot;/login.jsp&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>由于文件中多次使用<code>&quot;USER_SESSION&quot;</code> 故可以保存到一文件<code>Constant.java</code>中，作为常量，便于取出</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.util;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Constant</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String USER_SESSION = <span class="hljs-string">&quot;USER_SESSION&quot;</span>; <span class="hljs-comment">//用户保存常量</span>&#125;</code></pre><p><code>SysFilter.java</code> 实现过滤，没有登陆的信息，不可以登陆！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.filter;<span class="hljs-keyword">import</span> javax.servlet.*;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletRequest request = (HttpServletRequest) servletRequest; <span class="hljs-comment">//强转为HttpServletRequest</span>        HttpServletResponse response = (HttpServletResponse) servletResponse;        <span class="hljs-keyword">if</span> ( request.getSession().getAttribute(<span class="hljs-string">&quot;USER_SESSION&quot;</span>) == <span class="hljs-keyword">null</span> ) &#123;            response.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);        &#125;        filterChain.doFilter(request,response); <span class="hljs-comment">//必须要有</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><p>配置 <code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>sysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.heng.filter.SysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>sysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/sys/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><p>访问<code>http://localhost:8080/login.jsp</code> 输入正确账号密码</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/05.png" alt="image-20220204172704815"></p><p>点击提交，进行跳转 <img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/06.png" alt="image-20220204172717608"></p><p>注销之后，若直接访问<code>http://localhost:8080/sys/success.jsp</code> 跳转至错误页面，被拦截</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/07.png" alt="image-20220204172824426"></p><p>结构如图：</p><p><img src="/2022/02/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/08.png" alt="image-20220204172935107"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>过滤器</tag>
      
      <tag>监听器</tag>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie和session</title>
    <link href="/2022/02/03/cookie%E5%92%8Csession/"/>
    <url>/2022/02/03/cookie%E5%92%8Csession/</url>
    
    <content type="html"><![CDATA[<blockquote><p>会话是指一个终端用户与交互系统进行通讯的过程。</p></blockquote><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><strong>客户端技术</strong></p><blockquote><p> 当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？</p></blockquote><p>HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。</p><p>为了跟踪用户状态，服务器可以<strong>向浏览器分配一个唯一ID</strong>，并以<code>Cookie</code>的形式发送到浏览器，浏览器在后续访问时总是附带此<code>Cookie</code>，这样，服务器就可以识别用户身份。     </p><blockquote><p><code>cookie</code>实际上是一小段的<strong>文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户的状态，就使用<code>response</code>向客户端浏览器颁发一个<code>cookie</code>。客户端浏览器会把<code>cookie</code>保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和<code>cookie</code>一同给服务器。服务器检查该<code>cookie</code>，从而判断用户的状态。服务器还可以根据需要修改<code>cookie</code>的内容。</p></blockquote><p><img src="/2022/02/03/cookie%E5%92%8Csession/03.png" alt="image-20220203185519600"></p><p>例子：保存用户上次访问的时间</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/c1&quot;)</span> <span class="hljs-comment">//利用注解配置访问路径</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cookie01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//设置编码</span>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        PrintWriter out = resp.getWriter();        <span class="hljs-comment">//服务端获取cookie</span>        Cookie[] cookies = req.getCookies();<span class="hljs-comment">//返回数组，可能有多个</span>        <span class="hljs-comment">//判断是否存在</span>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) &#123;            out.write(<span class="hljs-string">&quot;Time : &quot;</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cookies.length; i++) &#123;                <span class="hljs-keyword">if</span> ( cookies[i].getName().equals(<span class="hljs-string">&quot;lastTime&quot;</span>)) &#123;                    <span class="hljs-comment">//获取值</span>                    <span class="hljs-keyword">long</span> l = Long.parseLong(cookies[i].getValue());<span class="hljs-comment">//string ==&gt; long</span>                    Date date = <span class="hljs-keyword">new</span> Date(l); <span class="hljs-comment">//利用时间类操作，转为时间</span>                    out.write(date.toLocaleString());                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            out.write(<span class="hljs-string">&quot;这是第一次访问！&quot;</span>);        &#125;        <span class="hljs-comment">//服务端相应cookie</span>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastTime&quot;</span>,System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-comment">//设置有效期</span>        cookie.setMaxAge(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>); <span class="hljs-comment">//cookie有效期一天！</span>        resp.addCookie(cookie);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><blockquote><p>设置默认Tomcat8080端口访问</p></blockquote><p>当访问第一次访问<code>http://localhost:8080/c1</code>时，并无cookie相应，再次访问此时将有</p><p><img src="/2022/02/03/cookie%E5%92%8Csession/01.png" alt="image-20220203175754579"></p><p><img src="/2022/02/03/cookie%E5%92%8Csession/02.png" alt="image-20220203175850394"></p><h1 id="session-重点"><a href="#session-重点" class="headerlink" title="session(重点)"></a>session(重点)</h1><p><strong>服务端技术</strong></p><p>利用此技术可以保存用户的会话信息，把信息或数据放到<code>session</code>中,把这种基于<strong>唯一ID识别用户身份的机制</strong>称为Session。</p><p>每个用户第一次访问服务器后，会自动获得一个<code>Session ID</code>。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的<code>Session ID</code>访问，服务器也认为这是一个新用户，会分配新的Session ID。</p><blockquote><p><code>session</code>是另一种记录客户状态的机制。不同的是<code>cookie</code>保存在<strong>客户端浏览器</strong>中，而<code>session</code>保存在<strong>服务器</strong>上。</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是<code>session</code>。客户端浏览器再次访问时只需要从该<code>session</code>中查找该客户的状态就可以了。<br>如果说<code>cookie</code>机制是通过检查客户身上的“通信证”，那么<code>session</code>机制就是通过 检查服务器上的“ 客户明细表”来确认客户身份</p></blockquote><p><img src="/2022/02/03/cookie%E5%92%8Csession/04.png" alt="image-20220203185701027"></p><p> <code>Session01.java中 </code> 获得<code>session ID</code></p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/ss1&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>); <span class="hljs-comment">//浏览器上的格式</span>        <span class="hljs-comment">//得到session</span>        HttpSession session = req.getSession();        <span class="hljs-comment">//给session存东西</span>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;一恒&quot;</span>);        <span class="hljs-comment">//获取id</span>        String id = session.getId();        <span class="hljs-keyword">if</span> ( session.isNew() ) &#123;            resp.getWriter().write(<span class="hljs-string">&quot;session创建成功！id = &quot;</span>+ id);        &#125;        <span class="hljs-keyword">else</span> &#123;            resp.getWriter().write(<span class="hljs-string">&quot;session已存在！id = &quot;</span> + id);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>Session02.java</code>中，获取<code>session</code>中信息</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/ss2&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);        <span class="hljs-comment">//获取session01中的值</span>        HttpSession session = req.getSession();        resp.getWriter().write( (String) session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>) ); <span class="hljs-comment">//打印到浏览器窗口</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>Session03.java</code> 删除session信息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);        HttpSession session = req.getSession();        session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//删除session中的值</span>        session.invalidate();<span class="hljs-comment">//注销session，此时再次访问出现新的id</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>也可以在<code>web.xml</code>中配置会话自动过期</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>    <span class="hljs-comment">&lt;!--    可设置失效时间，单位为分钟--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre><p><strong>使用场景</strong></p><ul><li>保存登陆用户的信息</li><li>购物车信息</li><li>网站中经常使用的数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>session</tag>
      
      <tag>cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/01/29/JDBC/"/>
    <url>/2022/01/29/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JDBC简介"><a href="#1-JDBC简介" class="headerlink" title="1.JDBC简介"></a>1.JDBC简介</h1><p>​    <code>Java DataBase Connectivity</code>（Java语言连接数据库）</p><p>JDBC的本质是什么？</p><ul><li><p>JDBC是SUN公司制定的一套接口（<code>interface</code>)</p><p>在包 <code>java.sql.*;</code>中 </p></li></ul><blockquote><p>接口都有调用者和实现者。<br>面向接口调用、面向接口写实现类，这都属于<strong>面向接口编程</strong>。</p><p><strong>为什么要面向接口编程？</strong><br>    解耦合：降低程序的耦合度，提高程序的扩展力。<br>    多态机制就是非常典型的：面向抽象编程。（不要面向具体编程）</p></blockquote><pre><code class="hljs java">建议：    Animal a = <span class="hljs-keyword">new</span> Cat();    Animal a = <span class="hljs-keyword">new</span> Dog();<span class="hljs-comment">// 喂养的方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Animal a)</span></span>&#123; <span class="hljs-comment">// 面向父类型编程。</span>&#125;不建议：    Dog d = <span class="hljs-keyword">new</span> Dog();    Cat c = <span class="hljs-keyword">new</span> Cat();思考：为什么SUN制定一套JDBC接口呢？    因为每一个数据库的底层实现原理都不一样。    Oracle数据库有自己的原理。    MySQL数据库也有自己的原理。    MS SqlServer数据库也有自己的原理。    ....    每一个数据库产品都有自己独特的实现原理。JDBC的本质到底是什么？    一套接口。</code></pre><h1 id="2-JDBC六步"><a href="#2-JDBC六步" class="headerlink" title="2.JDBC六步"></a>2.JDBC六步</h1><p>（背会）</p><blockquote><p>第一步：<strong>注册驱动</strong>（作用：告诉Java程序，即将要连接的是哪个品牌的数据库）</p><p>第二步：<strong>获取连接</strong>（表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完之后一定要关闭通道。）</p><p>第三步：<strong>获取数据库操作对象</strong>（专门执行sql语句的对象）</p><p>第四步：<strong>执行SQL语句</strong>（DQL DML….）</p><p>第五步：<strong>处理查询结果集</strong>（只有当第四步执行的是select语句的时候，才有这第五步处理查询结果集。）</p><p>第六步：<strong>释放资源</strong>（使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭。）</p></blockquote><p><strong>示例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.jdbc;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Statement statement = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.注册驱动</span>            Driver driver = <span class="hljs-keyword">new</span> com.mysql.jdbc.Driver();            DriverManager.registerDriver(driver);            <span class="hljs-comment">//2.获取连接(需要知道url,用户名,密码)</span>            String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;            String username = <span class="hljs-string">&quot;root&quot;</span>;            String pwd = <span class="hljs-string">&quot;123&quot;</span>;            connection = DriverManager.getConnection(url,username,pwd);            System.out.println(<span class="hljs-string">&quot;数据库对象&quot;</span> + connection);<span class="hljs-comment">//打印查看sql对象 </span>            <span class="hljs-comment">//结果：数据库对象com.mysql.cj.jdbc.ConnectionImpl@587c290d</span>            <span class="hljs-comment">//3.获取sql对象</span>            statement = connection.createStatement();            <span class="hljs-comment">//4执行sql语句</span>            String sql = <span class="hljs-string">&quot;insert into class(class_no,class_name) value(&#x27;5&#x27;,&#x27;数学班&#x27;)&quot;</span>;            <span class="hljs-comment">//执行,为(insert,delete,update)提供的方法</span>            <span class="hljs-comment">//返回值是 影响数据库中的记录条数</span>            <span class="hljs-keyword">int</span> count = statement.executeUpdate(sql);            System.out.println( count == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;sql success!&quot;</span> : <span class="hljs-string">&quot;Not！&quot;</span>);               <span class="hljs-comment">//5.处理sql结果集，因为没有查询，</span>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">/*6.关闭连接</span><span class="hljs-comment">                遵循从大到小的依次关闭</span><span class="hljs-comment">                connection开启的statement,所以statement先关闭</span><span class="hljs-comment">                分别try..catch</span><span class="hljs-comment">            * */</span>            <span class="hljs-keyword">if</span> (statement != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    statement.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    connection.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>结果如图</p><p><img src="/2022/01/29/JDBC/01.png" alt="image-20220130154506756"></p><p>(上述方式不常用)</p><p><strong>类加载的方式注册驱动</strong>(常用)</p><blockquote><p>为何常用===&gt; 因为参数是一个字符串，可以写到<code>xxx.properties</code>文件中！</p></blockquote><p>看源码</p><p><img src="/2022/01/29/JDBC/02.png" alt="image-20220130173422726"></p><pre><code class="hljs java"><span class="hljs-comment">//注册驱动的第二种方式 </span><span class="hljs-keyword">package</span> com.heng.jdbc;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2.连接</span>            Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);            System.out.println(conn); <span class="hljs-comment">//成功</span>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>将数据库文件放到<strong>配置文件</strong>中<code>jdbc.properties</code></p><p>如图，必须同一级目录</p><p>而且要求mysql版本和导入的jar包版本类似</p><p>此电脑</p><blockquote><p>Server version: <strong>8.0.26 MySQL</strong> Community Server - GPL</p><p>故若导入mysql5的包则会出现错误！</p></blockquote><p><img src="/2022/01/29/JDBC/03.png" alt="image-20220130190259222"></p><p><code>jdbc.properties</code>文件中</p><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">123</span></code></pre><p><code>JDBCtest03.java</code>文件</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">import</span> java.util.ResourceBundle;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCtest03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//通过资源绑定器绑定配置文件</span>        ResourceBundle bundle = ResourceBundle.getBundle(<span class="hljs-string">&quot;jdbc&quot;</span>);        String driver = bundle.getString(<span class="hljs-string">&quot;driver&quot;</span>);        String url = bundle.getString(<span class="hljs-string">&quot;url&quot;</span>);        String username = bundle.getString(<span class="hljs-string">&quot;username&quot;</span>);        String password = bundle.getString(<span class="hljs-string">&quot;password&quot;</span>);        Connection conn = <span class="hljs-keyword">null</span>;        Statement state = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Class.forName(driver);<span class="hljs-comment">//1</span>            conn = DriverManager.getConnection(url,username,password);<span class="hljs-comment">//2</span>            state = conn.createStatement();     <span class="hljs-comment">//3</span>            String sql = <span class="hljs-string">&quot;insert into class(class_no,class_name) value(&#x27;6&#x27;,&#x27;外语班&#x27;)&quot;</span>;<span class="hljs-comment">//4</span>            <span class="hljs-keyword">int</span> count = state.executeUpdate(sql);            System.out.println(count == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;sql success!&quot;</span> : <span class="hljs-string">&quot;Not！&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//6</span>            <span class="hljs-keyword">if</span> (state != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    state.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>完成查询</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcExec</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        Statement state = <span class="hljs-keyword">null</span>;        ResultSet rs = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//查询出来的结果集合</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2.获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3.获取sql对象</span>            state = conn.createStatement();            <span class="hljs-comment">//4执行sql语句，此时执行查询语句</span>            String sql = <span class="hljs-string">&quot;select *from class&quot;</span>;            rs = state.executeQuery(sql);            <span class="hljs-comment">//5.处理sql结果集</span>            <span class="hljs-keyword">while</span> ( rs.next() != <span class="hljs-keyword">false</span>) &#123;                <span class="hljs-comment">//next()相当于光标，持续下移，若有数据返回true</span>                <span class="hljs-comment">//jdbc中下标中1开始，此时表示取光标第一行第一列 也可以用 最终查询表的列名(推荐)</span>                <span class="hljs-comment">//String no = rs.getString(1);</span>                String no = rs.getString(<span class="hljs-string">&quot;class_no&quot;</span>);                String name = rs.getString(<span class="hljs-string">&quot;class_name&quot;</span>);<span class="hljs-comment">//第一行第二列</span>                System.out.println(no + <span class="hljs-string">&quot;,&quot;</span> + name);            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;         <span class="hljs-comment">//释放资源，先查询结果集==&gt;再数据库操作对象===&gt;最后连接</span>        <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                        rs.close();                    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                        e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (state != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    state.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p><code>statement = connection.createStatement();</code></p><p>增删改：<code>statement.executeUpdate(sql);</code> 返回<code>int</code></p><p> 查询： <code>statement.executeUpdate(sql);</code> 返回<code>ResultSet</code></p></blockquote><h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h1><blockquote><p><strong>简单模仿登陆</strong></p><p>1让用户输入 账号密码</p><p>2 和sql中的数据，进行比较，若存在相同，则登陆成功，否则失败</p></blockquote><p>创建表</p><p><img src="/2022/01/29/JDBC/04.png" alt="image-20220131095024031"></p><p>编写<code>JdbcLogin.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcLogin</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1提供用户输入,初始化 返回 账号和密码</span>        Map&lt;String,String&gt; rs = init();        System.out.println(rs);        <span class="hljs-comment">//2.jdbc操作判断是否相等</span>        System.out.println(login(rs) == <span class="hljs-keyword">true</span> ? <span class="hljs-string">&quot;登陆成功&quot;</span> : <span class="hljs-string">&quot;失败!&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Map&lt;String, String&gt; rs)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        Statement statement = <span class="hljs-keyword">null</span>;        ResultSet result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> flagSuccess = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//标志是否登陆成功</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2 获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3获得sql对象</span>            statement = conn.createStatement();            <span class="hljs-comment">//4执行sql </span>            String sql = <span class="hljs-string">&quot;select name,password from t_user where name=&#x27;&quot;</span>+rs.get(<span class="hljs-string">&quot;inputName&quot;</span>)+<span class="hljs-string">&quot;&#x27; &quot;</span> +                    <span class="hljs-string">&quot;and password=&#x27;&quot;</span>+rs.get(<span class="hljs-string">&quot;inputPwd&quot;</span>)+<span class="hljs-string">&quot;&#x27;   &quot;</span>;            <span class="hljs-comment">//5 处理结果集</span>            result = statement.executeQuery(sql);            <span class="hljs-keyword">if</span> ( result.next() != <span class="hljs-keyword">false</span> ) &#123;                flagSuccess = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//登陆成功！</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//6 释放资源</span>            <span class="hljs-keyword">if</span> (result !=<span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">try</span> &#123;                            result.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (statement !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    statement.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> flagSuccess;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        Scanner s = <span class="hljs-keyword">new</span> Scanner(System.in);        System.out.print(<span class="hljs-string">&quot;用户名：&quot;</span>);        String inputName = s.nextLine(); <span class="hljs-comment">//获得输入，为字符串</span>        System.out.print(<span class="hljs-string">&quot;密码：&quot;</span>);        String inputPwd = s.nextLine();        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;inputName&quot;</span>,inputName); <span class="hljs-comment">//组装成map(key,value)</span>        map.put(<span class="hljs-string">&quot;inputPwd&quot;</span>,inputPwd);        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre><p>经过测试，当输入数据库存在的数据时，均登陆成功，但存在bug，会导致**SQL注入 ** 如图</p><p><img src="/2022/01/29/JDBC/05.png" alt="image-20220131095833876"></p><p>此时输入<code>qza&#39; or &#39;1&#39;=&#39;1</code>  则会将<code>or</code>参与到sql语句中，导致sql语句查询恒为真   如图<code>debug</code>查看</p><p><img src="/2022/01/29/JDBC/06.png" alt="image-20220131100603852"></p><blockquote><p> 注入原因：输入的信息含sql关键字，并且这些关键字<strong>参与到了sql的编译</strong>，导致原意扭曲</p></blockquote><p>如何解决：</p><p>只要提供的信息，不参与sql语句编译即可！</p><p>利用<code>java.sql.preparedStatement</code> 此接口继承了<code>java.sql.Statement</code></p><p>属于<strong>预编译的数据库操作对象</strong>  (预先对sql语句的框架进行编译，然后再给sql传值)</p><p><strong>改进如下</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Map&lt;String, String&gt; rs)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        PreparedStatement ps = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//采用预编译对象</span>        ResultSet result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> flagSuccess = <span class="hljs-keyword">false</span>;        String name = rs.get(<span class="hljs-string">&quot;inputName&quot;</span>);<span class="hljs-comment">// 获取输入的用户和密码</span>        String pwd = rs.get(<span class="hljs-string">&quot;inputPwd&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1 注册驱动</span>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            <span class="hljs-comment">//2 获取连接</span>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);            <span class="hljs-comment">//3获得sql对象 ?代表占位符，用来接收一个值</span>            String sql = <span class="hljs-string">&quot;select name,password from t_user where name=? and password=?&quot;</span>;            ps = conn.prepareStatement(sql);            <span class="hljs-comment">//给问号传值，第一个?下标索引1...</span>            ps.setString(<span class="hljs-number">1</span>,name);            ps.setString(<span class="hljs-number">2</span>,pwd);            <span class="hljs-comment">//4执行sql</span>            result = ps.executeQuery();            <span class="hljs-comment">//5 处理结果集</span>            <span class="hljs-keyword">if</span> ( result.next() != <span class="hljs-keyword">false</span> ) &#123;                <span class="hljs-comment">//登陆成功！</span>                flagSuccess = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (result !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    result.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (ps !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    ps.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (conn !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> flagSuccess;    &#125;</code></pre><p>总结：</p><p><code>Statement</code>存在sql注入问题，并且是编译一次执行一次，因为sql语句根据每次用户输入，都会变化</p><p><code>PreparedStatement</code>解决了sql注入问题，编译一次，可执行N次，效率更好，而且在编译阶段会做安全检查</p><p>故大多数用<code>PreparedStatement</code>，除非业务方面需要sql注入进行拼接，才使用<code>Statement</code>,比如商城按照xx排序即<code>order by desc</code>，则此是需要sql注入</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><h2 id="1-maven配置"><a href="#1-maven配置" class="headerlink" title="1.maven配置"></a>1.maven配置</h2><p><code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--mysql的驱动，注意mysql版本与之对应--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h2 id="2-idea中进行连接"><a href="#2-idea中进行连接" class="headerlink" title="2.idea中进行连接"></a>2.idea中进行连接</h2><p><img src="/2022/01/29/JDBC/07.png" alt="image-20220204203513733"></p><h2 id="3-编写代码"><a href="#3-编写代码" class="headerlink" title="3.编写代码"></a>3.编写代码</h2><p><code>Jdbc01.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heng.jdbc;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jdbc01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;        <span class="hljs-comment">//配置信息</span>        String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;        String username = <span class="hljs-string">&quot;root&quot;</span>;        String password = <span class="hljs-string">&quot;123&quot;</span>;        <span class="hljs-comment">//1驱动</span>        Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);        <span class="hljs-comment">//2连接数据库</span>        Connection connection = DriverManager.getConnection(url, username, password);        <span class="hljs-comment">//3获得sql对象</span>        Statement statement = connection.createStatement();        <span class="hljs-comment">//4执行sql</span>        ResultSet rs = statement.executeQuery(<span class="hljs-string">&quot;select *from t_user &quot;</span>);        <span class="hljs-comment">//5结果集</span>        <span class="hljs-keyword">while</span> ( rs.next() ) &#123;            System.out.println(<span class="hljs-string">&quot;name = &quot;</span>+ rs.getObject(<span class="hljs-string">&quot;name&quot;</span>));            System.out.println(<span class="hljs-string">&quot;password =&quot;</span> + rs.getObject(<span class="hljs-string">&quot;password&quot;</span>));        &#125;        <span class="hljs-comment">//6断开连接,释放资源   </span>        rs.close();        statement.close();        connection.close();    &#125;&#125;</code></pre><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h2><p>要么都成功，要么都失败</p><p><code>ACID</code> 保证数据的安全</p><blockquote><p><a href="https://zh.wikipedia.org/w/index.php?title=%E5%8E%9F%E5%AD%90%E6%80%A7&action=edit&redlink=1">原子性</a>（atomicity，或称不可分割性）、<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E6%80%A7_(%E6%95%B0%E6%8D%AE%E5%BA%93)">一致性</a>（consistency）、<a href="https://zh.wikipedia.org/wiki/%E9%9A%94%E9%9B%A2%E6%80%A7">隔离性</a>（isolation，又称独立性）、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8C%81%E4%B9%85%E6%80%A7&action=edit&redlink=1">持久性</a>（durability）</p></blockquote><pre><code class="hljs mysql">开启事务事务提交 commit()事务回滚 rollback()关闭事务</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>servlet</title>
    <link href="/2022/01/27/servlet/"/>
    <url>/2022/01/27/servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Servlet简介"><a href="#1-Servlet简介" class="headerlink" title="1.Servlet简介"></a>1.Servlet简介</h1><p><strong>Ser</strong>ver App<strong>let</strong></p><p>是用Java编写的<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>端程序。其主要功能在于交互式地浏览和修改数据，<strong>生成动态内容</strong>。</p><p>狭义的Servlet是指Java语言实现的一个<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3">接口</a></p><p>广义的Servlet是指任何实现了这个Servlet接口的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>，一般情况下，人们将Servlet理解为后者。</p><p>Servlet运行于支持Java的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">应用服务器</a>中。</p><p>从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE">协议</a>的<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">Web服务器</a>。</p><p>故这些api中提供的一个接口叫做：<code>servlet</code>。若要开发<code>servlet</code>程序</p><ul><li>1.编写一个类，实现<code>servlet</code>接口</li><li>2.把开发好的java类部署到web服务器中</li></ul><blockquote><p>ps: <strong>Servlet接口</strong>SUN公司定义了两个<strong>默认实现类</strong>，分别为：<strong>GenericServlet、HttpServlet</strong></p></blockquote><h1 id="2-Servlet项目"><a href="#2-Servlet项目" class="headerlink" title="2.Servlet项目"></a>2.Servlet项目</h1><p>(1). 建立<strong>普通的maven项目</strong>，删除里面的src目录，之后再建立项目，就在此项目中建立<code>Model</code>即可，即<strong>主工程</strong></p><p><img src="/2022/01/27/servlet/01.png" alt="image-20220128173531354"></p><p>添加<code>servlet-api</code> 和 <code>jsp-api</code>依赖 ==&gt; <code>setting.xml</code>如图</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span> </code></pre><p>(2).里面可进行<strong>新建web-maven项目</strong>，如图</p><p><img src="/2022/01/27/servlet/02.png" alt="image-20220128173705675"></p><p>创建完成后，<code>setting.xml</code>如图</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">connectors</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">connector</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8888<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">maxIdleTime</span>&gt;</span>30000<span class="hljs-tag">&lt;/<span class="hljs-name">maxIdleTime</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">connector</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">connectors</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">webAppSourceDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;pom.artifactId&#125;-$&#123;pom.version&#125;                    <span class="hljs-tag">&lt;/<span class="hljs-name">webAppSourceDirectory</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">contextPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">contextPath</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--dependency&gt;</span><span class="hljs-comment">      &lt;groupId&gt;com.heng&lt;/groupId&gt;</span><span class="hljs-comment">      &lt;artifactId&gt;[the artifact id of the block to be mounted]&lt;/artifactId&gt;</span><span class="hljs-comment">      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><span class="hljs-comment">    &lt;/dependency--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><img src="/2022/01/27/servlet/03.png" alt="image-20220128174332786"></p><p><strong>两者为父子工程</strong></p><p>父项目中会有</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></code></pre><p> 子项目中有</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>父项目中的jar包 子项目可以直接使用，反之不可以</p><p><strong>(3).maven环境进行优化</strong></p><ul><li>修改web.xml</li><li>将maven结构弄完成 ==&gt;  main下添加<code>java</code> 和 <code>resources文件夹</code></li></ul><p><strong>目录结构</strong></p><p><img src="/2022/01/27/servlet/04.png" alt="image-20220128192003127"></p><p><strong>(4).编写servlet</strong></p><ul><li>创建普通类</li><li>实现<code>servlet</code>接口，可以继承<code>HttpServlet</code></li></ul><p>观察源码</p><p><img src="/2022/01/27/servlet/05.png" alt="image-20220128182305203"></p><p><img src="/2022/01/27/servlet/06.png" alt="image-20220128182336364"></p><p><img src="/2022/01/27/servlet/07.png" alt="image-20220128182420504"></p><p><strong>(5).重写<code>doGet</code>和<code>doPost</code>方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-comment">//进行重写</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        PrintWriter writer = resp.getWriter();        writer.print(<span class="hljs-string">&quot;hello servlet!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><strong>(6).写servlet映射</strong></p><blockquote><p>因为写的是java，但想在浏览器上进行访问，需要连接web服务器</p><p>故需要在web服务中注册<code>servlet</code>,并且给出访问的路径</p></blockquote><p>在<code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--进行映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p><strong>(7)配置Tomcat</strong></p><p><img src="/2022/01/27/servlet/08.png" alt="image-20220128184145818"></p><p><strong>(8)启动</strong></p><p>查看结果</p><p><img src="/2022/01/27/servlet/09.png" alt="image-20220128192055844"></p><p><img src="/2022/01/27/servlet/10.png" alt="image-20220128192111911"></p><h1 id="3-servlet原理-本质"><a href="#3-servlet原理-本质" class="headerlink" title="3.servlet原理/本质"></a>3.servlet原理/本质</h1><blockquote><p>浏览器发送一个HTTP请求，HTTP请求由<strong>Web容器</strong>(比如tomcat)分配给特定的Servlet进行处理<br><strong>Servlet的本质是一个Java对象</strong>，这个对象拥有一系列的方法来处理HTTP请求。常见的方法有**doGet()，doPost()**等。</p><p>Web容器中包含了多个Servlet，特定的HTTP请求该由哪一个Servlet来处理是由Web容器中的<code>web.xml</code>来决定的。</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-1cb5b57ffab54838ad59983a8adbcdc8_720w.jpg?source=1940ef5c" alt="img"></p><p>Servlet工作流程分为三个阶段。init(初始化)，service(运行)，destroy(销毁)</p><p>Servlet没有<a href="https://www.zhihu.com/search?q=main%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:82511153%7D">main方法</a>，所有行为由Container控制。Container就是一个java程序。</p><p>在加载Servlet的.class后，Servlet会由<a href="https://www.zhihu.com/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:82511153%7D">构造函数</a>生成一个实例，然后Container调用<code>init()</code>方法完成参数的初始化，接着调用<code>service()</code>方法，service会根据网页的请求，调用doGet或者doPost方法(<strong>一般需要重写</strong>)，最后调用销毁方法。如图：</p><p><img src="https://pic1.zhimg.com/80/3fdb2abf692cb5edb833e139504ede39_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="1-mapping问题"><a href="#1-mapping问题" class="headerlink" title="1.mapping问题"></a>1.mapping问题</h2><ul><li>一个servlet可以指定一个映射路径</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.一对一映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><ul><li>一个servlet可以指定多个映射路径</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--2 一对多映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当输入<code>http://localhost:8080/s1/hello</code>或 <code>http://localhost:8080/s1/hello1</code>或<code>http://localhost:8080/s1/hello2</code></p><p>均可以访问</p><ul><li>一个servlet可以指定通用映射路径    </li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--3 通用映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>/hello/xxxx</code> xxxx即*  ==&gt; 代指任何均可以访问</p><p>若改为<code>&lt;url-pattern&gt;*&lt;/url-pattern&gt;</code>则报错<br>若改为<code> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code> 则默认启动即相应的页面，<code>index.jsp</code>内容无法看到</p><ul><li><p>可以指定前缀或后缀</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>只要访问是以<code>.heng</code>为后缀则访问成功</p></li></ul><h2 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2.优先级"></a>2.优先级</h2><ul><li><p>指定了固有的路径优先级最高，如果找不到找默认的</p><p>示例：编写<code>ErrorServlet</code>  目的==&gt; 访问错误到自己的页面，显示404</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);        PrintWriter writer = resp.getWriter();        writer.print(<span class="hljs-string">&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;</span>); <span class="hljs-comment">//页面显示404</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>配置<code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.ErrorServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--进行映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>默认访问404,只有当指定<code>/heng</code>时才访问写的<code>HelloServlet.java</code>，然后展示内容</p><h1 id="4-ServletContext"><a href="#4-ServletContext" class="headerlink" title="4.ServletContext"></a>4.ServletContext</h1><p>web容器启动时，为每个web程序都创建了对应的<code>ServletContext</code>对象，代表当前的web应用</p><h2 id="4-1可共享数据"><a href="#4-1可共享数据" class="headerlink" title="4.1可共享数据"></a>4.1可共享数据</h2><p>( 在这个servlet保存的数据，可在另一个servlet中拿到)</p><p><code>HelloServlet02.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();<span class="hljs-comment">//servlet上下文</span>        String myName = <span class="hljs-string">&quot;Yiheng&quot;</span>;        <span class="hljs-comment">//将myName保存到ServletContext中</span>        context.setAttribute(<span class="hljs-string">&quot;Name&quot;</span>,myName);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>GetServlet.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//拿到HelloServlet02中保存的名字</span>        String usrName = (String) context.getAttribute(<span class="hljs-string">&quot;Name&quot;</span>);        resp.getWriter().print(<span class="hljs-string">&quot;Name &quot;</span> + usrName); <span class="hljs-comment">//在浏览器中打印显示</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.HelloServlet02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getName<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello02<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello02<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getName<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/Name<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>先访问<code>/s2/hello02</code>获取数据，然后通过<code>http://localhost:8080/s2/Name</code> 拿到数据，则此是进行显示</p><p><img src="/2022/01/27/servlet/11.png" alt="image-20220129103546867"></p><blockquote><p>会用cookie 和 session 替代</p></blockquote><h2 id="4-2可获取初始化参数"><a href="#4-2可获取初始化参数" class="headerlink" title="4.2可获取初始化参数"></a>4.2可获取初始化参数</h2><p><code>web.xml</code>中 新加入参数</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre><p>创建<code>GetParam.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//通过ServletContext获得初始化的参数</span>        String url = context.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>);        resp.getWriter().print(url);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中加入对应配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetParam<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/gp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/gp</code> 则数据已获取，即<code>jdbc:mysql://localhost:3306/mybatis</code>显示出来</p><h2 id="3-可进行转发"><a href="#3-可进行转发" class="headerlink" title="3.可进行转发"></a>3.可进行转发</h2><p>新建<code>Forward_demo.java</code> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Forward_demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();        <span class="hljs-comment">//设置转发的请求路径</span>        RequestDispatcher requestDispatcher = context.getRequestDispatcher(<span class="hljs-string">&quot;/gp&quot;</span>);        <span class="hljs-comment">//forward方法进行转发</span>        requestDispatcher.forward(req,resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code> 加入配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.Forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>forward_demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/fd<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/fd</code>时，此是会将<code>/gp</code>映射的内容转发过来，最终显示出来了<code>jdbc:mysql://localhost:3306/mybatis</code></p><h2 id="4-读取资源文件"><a href="#4-读取资源文件" class="headerlink" title="4.读取资源文件"></a>4.读取资源文件</h2><p><img src="/2022/01/27/servlet/12.png" alt="image-20220129143356510"></p><p><code>db.properties</code>内容</p><pre><code class="hljs properties"><span class="hljs-attr">username</span> = <span class="hljs-string">root</span><span class="hljs-attr">password</span> = <span class="hljs-string">123</span></code></pre><p><code>xx.properties</code>内容</p><pre><code class="hljs properties"><span class="hljs-attr">username</span> = <span class="hljs-string">myRoot</span><span class="hljs-attr">password</span> = <span class="hljs-string">123123</span></code></pre><blockquote><p>ps： <code>db.properties</code>默认可以正常在<code>target/classess中</code>到处，而<code>xx.properties</code>则不可以，因为在java内部</p></blockquote><p>需要进行处理，在<code>pom.xml</code>中加入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-comment">&lt;!--主要就是下面这个--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>加入之后，运行，观察可发现</p><p><img src="/2022/01/27/servlet/13.png" alt="image-20220129144057553"></p><p>两个均正常生成</p><p>在<code>GetResources.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetResources</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//找到xx.properties资源目录，输入为流</span>        InputStream stream = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/com/heng/xx.properties&quot;</span>);        <span class="hljs-comment">//找db.properties</span>        <span class="hljs-comment">//InputStream stream = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);</span>        Properties prop = <span class="hljs-keyword">new</span> Properties();        prop.load(stream); <span class="hljs-comment">//加载</span>        String name = prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>);        String pwd = prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>);        resp.getWriter().println(<span class="hljs-string">&quot;name : &quot;</span> + name);        resp.getWriter().println(<span class="hljs-string">&quot;password : &quot;</span> + pwd);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>web.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>resources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.GetResources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>resources<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/res<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当访问<code>http://localhost:8080/s2/res</code>则可看到对应资源被展示出来</p><p><img src="/2022/01/27/servlet/14.png" alt="image-20220129144517696"></p><h1 id="5-Response重定向"><a href="#5-Response重定向" class="headerlink" title="5.Response重定向"></a>5.Response重定向</h1><p>新建<code>RedirectServlet.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedirectServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//重定向</span>        resp.sendRedirect(<span class="hljs-string">&quot;/s2/Name&quot;</span>);     &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>配置<code>web.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>redirect<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.RedirectServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>redirect<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/rs<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>当输入<code>http://localhost:8080/s2/rs</code> 直接就跳转至<code>http://localhost:8080/s2/Name</code>进行访问</p><p><img src="/2022/01/27/servlet/15.png" alt="image-20220129150919064"></p><blockquote><p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是<strong>转发给另一个Servlet处理</strong>。</p><p><strong>重定向</strong>是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用<strong>新的URL再重新发送</strong>新请求。</p><p>相同点：页面均会跳转 </p><p>不同：请求转发时，url不会发生变化(307)，而重定向(302)会  </p></blockquote><p><strong>小案例 ==&gt;</strong> </p><p>通过<code>index.jsp</code>上form表单输入账号，密码，进行提交，跳转到另一个页面，显示成功</p><p><strong>需要在表单上指定action具体路径</strong> <code>$&#123;pageContext.request.contextPath&#125;</code>指代当前项目</p><p><code>index.jsp</code></p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--此时action找到当前项目，然后在当前项目找到login，进行请求--%&gt;&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;    用户名: &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name = <span class="hljs-string">&quot;username&quot;</span>&gt; &lt;br&gt;    密码 : &lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;pwd&quot;</span>&gt; &lt;br&gt;    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>新建<code>RequestServlet.java</code> 进行处理，当点击提交之后<strong>重定向</strong>到相对页面<code>success.jsp</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>); <span class="hljs-comment">//获取账号密码</span>        String pwd = req.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);        System.out.println(<span class="hljs-string">&quot;账号:&quot;</span> + username); <span class="hljs-comment">//控制台打印对应账号密码</span>        System.out.println(<span class="hljs-string">&quot;密码:&quot;</span> + pwd);        resp.sendRedirect(<span class="hljs-string">&quot;/s2/success.jsp&quot;</span>); <span class="hljs-comment">//重定向到对应页面，显示成功</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p>新建<code>success.jsp</code> 和<code>index.jsp</code>同级</p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success!!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>配置<code>web.xml</code> 添加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>request<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.RequestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>request<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/login<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>如图</p><p><img src="/2022/01/27/servlet/16.png" alt="image-20220129154351011"></p><p>点击提交</p><p><img src="/2022/01/27/servlet/17.png" alt="image-20220129154855656"></p><p>控制台<img src="/2022/01/27/servlet/18.png" alt="image-20220129154905692"></p><p>若显示中文乱码，则在Tomcat配置中加入<code>-Dfile.encoding=UTF-8</code>  如图</p><p><img src="/2022/01/27/servlet/19.png" alt="image-20220129154937940"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/study/"/>
    <url>/2022/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/study/</url>
    
    <content type="html"><![CDATA[<p>在<strong>学习该项技术的细节之前</strong>都得知道：</p><p><strong>这项技术是什么，为什么我要学习这项技术，学习了这项技术有什么好处</strong>。</p><p>===&gt; <strong>如果你不知道学习某项技术是干嘛用的，那先不要学</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2022/01/24/http/"/>
    <url>/2022/01/24/http/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是http"><a href="#1-什么是http" class="headerlink" title="1. 什么是http"></a>1. 什么是http</h1><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。</p><ul><li>文本：html，字符串</li><li>超文本：图片，音乐，视频，定位，地图</li><li>端口：80</li></ul><h1 id="2-两个时代"><a href="#2-两个时代" class="headerlink" title="2.两个时代"></a>2.两个时代</h1><ul><li>http1.0<ul><li>http/1.0 : 客户端对web服务器连接后，只能获得一个web资源，断开连接</li></ul></li><li>http2.0<ul><li>http/1.1：客户端对web服务器连接后，可以获得多个web资源，</li></ul></li></ul><h1 id="3-http请求"><a href="#3-http请求" class="headerlink" title="3 .http请求"></a>3 .http请求</h1><ul><li>客服端–&gt;发请求(request) –&gt; 服务器</li></ul><p>百度：</p><blockquote><p>Request URL: <a href="https://www.baidu.com/">https://www.baidu.com/</a><br>Request method: GET<br>Status code: 200 OK<br>Remote address: 127.0.0.1:7890</p><p>Accept: text/html<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9<br>Cache-Control: max-age=0<br>Connection: keep-alive</p></blockquote><h2 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<strong>请求行</strong></h2><ul><li>请求方式：get / post<ul><li>get:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li><li>post：请求能够携带的参数和大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效</li></ul></li></ul><h2 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2.消息头"></a>2.消息头</h2><pre><code class="hljs shell">Accept: 告诉浏览器，支持的数据类型Accept-Encoding: 支持哪种编码格式 gbk utf-8 GB2312 ISO8859-1Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接host: 主机</code></pre><h1 id="4-http响应"><a href="#4-http响应" class="headerlink" title="4. http响应"></a>4. http响应</h1><pre><code class="hljs java">Cache-Control: <span class="hljs-keyword">private</span>Connection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-<span class="hljs-number">8</span> </code></pre><h2 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1.响应体"></a>1.<strong>响应体</strong></h2><pre><code class="hljs groovy"><span class="hljs-attr">Accept:</span> 告诉浏览器，支持的数据类型Accept-<span class="hljs-attr">Encoding:</span> 支持哪种编码格式 gbk utf<span class="hljs-number">-8</span> GB2312 ISO8859<span class="hljs-number">-1</span>Accept-<span class="hljs-attr">Language:</span> 告诉浏览器，他的语言环境Cache-<span class="hljs-attr">Control:</span> 缓存控制<span class="hljs-attr">Connection:</span> 告诉浏览器，请求完是断开还是保持连接<span class="hljs-attr">host:</span> 主机<span class="hljs-attr">refresh :</span> 告诉客户端，多久刷新一次location ： 让网页重新定位 </code></pre><h2 id="2-响应状态码"><a href="#2-响应状态码" class="headerlink" title="2.响应状态码"></a>2.响应状态码</h2><ul><li>200 ：请求相应成功</li><li>3xx : 请求重定向 （你重新到我给你的新位置去</li><li>4xx：找不到资源 404 </li><li>5xx: 服务器代码错误  502 网关错误</li></ul><blockquote><p>面试题：当浏览器输入网址并回车一瞬间到页面显示出来，经历了什么？！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven</title>
    <link href="/2022/01/24/maven/"/>
    <url>/2022/01/24/maven/</url>
    
    <content type="html"><![CDATA[<p>为何要学习Maven</p><blockquote><p>1.在javaweb开发中，需要使用大量的jar包，我们手动去导入</p><p>2.如何才能让一个东西自动帮我导入和配置这些jar包</p><p>于是  maven就诞生了！</p></blockquote><h1 id="1-maven项目管理工具"><a href="#1-maven项目管理工具" class="headerlink" title="1.maven项目管理工具"></a>1.maven项目管理工具</h1><p>方便导入jar包</p><p><strong>核心思想: 约定大于配置</strong></p><ul><li>有约束，不要去违反</li></ul><p>他会规定你如何去编写java代码，必须安装这个规范</p><h1 id="2-下载maven"><a href="#2-下载maven" class="headerlink" title="2. 下载maven"></a>2. 下载maven</h1><p><a href="https://maven.apache.org/">maven官网 </a>下载完解压即可</p><p><img src="/2022/01/24/maven/10.png" alt="image-20220101144018665"></p><h1 id="3-配置maven"><a href="#3-配置maven" class="headerlink" title="3.配置maven"></a>3.配置maven</h1><p>环境变量</p><p><img src="/2022/01/24/maven/10_1.png" alt="image-20220128153722723"></p><ul><li>M2_HOME : maven目录下的bin目录</li><li>MAVEN_HOME ：maven 的目录</li><li>在系统的path中配置%MAVEN_HOME%\bin </li></ul><blockquote><p>命令行输入 <code>mvn -v</code> 进行验证环境变量</p></blockquote><h1 id="4-阿里云镜像"><a href="#4-阿里云镜像" class="headerlink" title="4 .阿里云镜像"></a>4 .阿里云镜像</h1><p>在<code>E:\environment\apache-maven-3.6.2\conf ==&gt;  setting.xml</code>中添加 <strong>镜像和本地仓库</strong></p><p>mirrors(镜像)</p><ul><li>加速我们的下载</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置中央仓库的镜像（改用：阿里云中央仓库镜像）--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun-maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><h1 id="5-本地仓库"><a href="#5-本地仓库" class="headerlink" title="5.本地仓库"></a>5.本地仓库</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:\environment\apache-maven-3.8.4\maven_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h1 id="6-在idea中使用IDEA"><a href="#6-在idea中使用IDEA" class="headerlink" title="6.在idea中使用IDEA"></a>6.在idea中使用IDEA</h1><p>创建maven web项目 如图</p><p><img src="/2022/01/24/maven/11.png" alt="image-20220101192126444"></p><p><img src="/2022/01/24/maven/12.png" alt="image-20220101192357597"></p><p><img src="/2022/01/24/maven/13.png" alt="image-20220101192825075"></p><p>成功后  若报错==&gt; 上述直接弄成idea的默认，然后新创建maven项目</p><p>进行疯狂下东西</p><p><img src="/2022/01/24/maven/14.png" alt="image-20220101194550504"></p><p>出现 BUILD SUCESS 代表成功</p><p><img src="/2022/01/24/maven/15.png" alt="image-20220101201841681"></p><p>在文件中多了文件</p><p><img src="/2022/01/24/maven/16.png" alt="image-20220101195042365"></p><p>也没配置本地仓库，比如在d盘。而这个.m2文件是系统默认的，自动生成的</p><p>在maven web程序下</p><p><img src="/2022/01/24/maven/17.png" alt="image-20220102085500377"></p><h1 id="7-创建普通的maven项目"><a href="#7-创建普通的maven项目" class="headerlink" title="7. 创建普通的maven项目"></a>7. 创建普通的maven项目</h1><p>不勾选模板<img src="/2022/01/24/maven/18.png" alt="image-20220102084704298"></p><p> 干净的maven项目 <img src="/2022/01/24/maven/19.png" alt="image-20220102085250133"></p><h1 id="8-标记文件夹功能"><a href="#8-标记文件夹功能" class="headerlink" title="8.标记文件夹功能"></a>8.标记文件夹功能</h1><p>在idea中对文件夹右键 </p><p><img src="/2022/01/24/maven/20.png" alt="image-20220102085749308"></p><h1 id="9-配置tomcat"><a href="#9-配置tomcat" class="headerlink" title="9.配置tomcat"></a>9.配置tomcat</h1><p><img src="/2022/01/24/maven/21.png" alt="image-20220102090742277"></p><p><img src="/2022/01/24/maven/22.png" alt="image-20220102090805674"></p><p><img src="/2022/01/24/maven/23.png" alt="image-20220102091333094"></p><p><img src="/2022/01/24/maven/24.png" alt="image-20220102091453659"></p><p><img src="/2022/01/24/maven/25.png" alt="image-20220128152412421"></p><p>进行启动</p><p><img src="/2022/01/24/maven/26.png" alt="image-20220102092343654"></p><p>成功会进行弹出！</p><p><img src="/2022/01/24/maven/27.png" alt="image-20220102092357538"></p><p>显示出的<code>hello world</code> 就是<code>index.jsp</code>中的内容</p><p><img src="/2022/01/24/maven/28.png" alt="image-20220102092513473"></p><p>此时成功！</p><p><strong>maven结构</strong></p><p><img src="/2022/01/24/maven/29.png" alt="image-20220102092717582"></p><h1 id="10-pom-xml文件"><a href="#10-pom-xml文件" class="headerlink" title="10. pom.xml文件"></a>10. pom.xml文件</h1> <pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-comment">&lt;!--maven版本和头文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-comment">&lt;!--  下面这是我们配置的GAV--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--  package 项目的打包方式</span><span class="hljs-comment">jar：java应用</span><span class="hljs-comment">war：javaweb应用</span><span class="hljs-comment">--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-comment">&lt;!--name url 可删除--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>untitled Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-comment">&lt;!--配置--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--    项目的默认构建编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-comment">&lt;!--    编码版本--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!--项目依赖--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--    具体依赖的jar包配置文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5-20081211<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--  项目构建用的--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>untitled<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><strong>maven高级之处就在于他帮你导入这个jar包所依赖的其他jar包</strong></p><p><a href="https://mvnrepository.com/">maven仓库</a></p><p>只需加上dependency。在maven仓库中，选择自己需要的即可，maven将自己导入</p><p><img src="/2022/01/24/maven/30.png" alt="image-20220102095217578"></p><p>由于maven 约定大于配置 的规定，所以再之后写的配置文件，<strong>会出现无法导出或生效的问题</strong>，解决方法：</p><p>在mybatis 会遇到</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><p>若每次都需要重新配置，修改<strong>全局配置</strong></p><p><img src="/2022/01/24/maven/31.png" alt="image-20220128151726838"></p><p><img src="/2022/01/24/maven/32.png" alt="image-20220128151823590"></p><p>若maven配置完之后，创建项目出现<code>Error reading file E:/idea_project/Maven_pro/pom.xml</code></p><p>重新安装maven，然后配置环境，则可进行解决</p><h1 id="11-简单编写HelloServlet"><a href="#11-简单编写HelloServlet" class="headerlink" title="11.简单编写HelloServlet"></a>11.简单编写HelloServlet</h1><p>maven app结构</p><p><img src="/2022/01/24/maven/32_1.png" alt="image-20220128152809852"></p><p><code>HelloServlet.java</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-comment">//重写doGet 和 doPost方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);        response.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);  <span class="hljs-comment">//解决中文乱码！</span>        PrintWriter out = response.getWriter();        out.println(<span class="hljs-string">&quot;&lt;html&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;head&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;title&gt;你好&lt;/title&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/head&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;body&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&quot;</span>);        out.println(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre><p><code>index.jsp</code>中</p><pre><code class="hljs jsp">&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>header.html</code>中</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><code>web.xml</code>中</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">web-app</span> <span class="hljs-meta-keyword">PUBLIC</span></span><span class="hljs-meta"> <span class="hljs-meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><span class="hljs-meta"> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>  <span class="hljs-comment">&lt;!--  web.xml是web的核心应用</span><span class="hljs-comment">注册servlet--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.heng.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>  <span class="hljs-comment">&lt;!--  一个servlet对应一个mapping 映射--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--    映射请求路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/heng<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><p><strong>结果展示</strong></p><p>默认通过<code>localhost:8080/hello</code> 展示如图，<code>index.jsp</code>文件展示出来</p><p><img src="/2022/01/24/maven/33.png" alt="image-20220128153227229"></p><p>访问<code>header.html</code></p><p><img src="/2022/01/24/maven/34.png" alt="image-20220128153244534"></p><p>通过<code>servlet</code>进行映射访问，编写的<code>HelloServlet</code>展示出来</p><p><img src="/2022/01/24/maven/35.png" alt="image-20220128153300993"></p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2022/01/21/JavaScript/"/>
    <url>/2022/01/21/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>(行为层)</p><h2 id="1-1什么是JavaScript？"><a href="#1-1什么是JavaScript？" class="headerlink" title="1.1什么是JavaScript？"></a>1.1什么是JavaScript？</h2><p><img src="/2022/01/21/JavaScript/01.png" alt="image-20220121194910154"></p><p><em>合格的后端开发人员必须<strong>精通</strong> JavaScript！</em></p><p><strong>JavaScript框架</strong></p><p><img src="/2022/01/21/JavaScript/02.png" alt="image-20220121194953823"></p><p><strong>主流框架：VUE.js</strong></p><p><img src="/2022/01/21/JavaScript/03.png" alt="image-20220121195301812"></p><h2 id="1-2-js历史"><a href="#1-2-js历史" class="headerlink" title="1.2 js历史"></a>1.2 js历史</h2><p><strong><a href="https://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">JavaScript历史</a></strong></p><h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h1><p><strong>引入js</strong></p><pre><code class="hljs javascript"><span class="hljs-comment">//内部引用 script必须成对出现</span>&lt;script&gt;        alert(<span class="hljs-string">&quot;Hello World!&quot;</span>); <span class="hljs-comment">//弹出HelloWord </span>&lt;/script&gt;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//在index.html同级目录中建立js文件夹，然后里面进行js文件，写入js语句</span><span class="hljs-comment">//外部引用(规范写法) 在index.html中  </span> &lt;script src=<span class="hljs-string">&quot;js/new.js&quot;</span>&gt;&lt;/script&gt; <span class="hljs-comment">//new.js中</span>alert(<span class="hljs-string">&quot;Hello World!&quot;</span>);</code></pre><h2 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a><strong>2.1变量</strong></h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> number = <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;</code></pre><p><img src="/2022/01/21/JavaScript/04.png" alt="image-20220122083505160"></p><p>可在浏览器此处进行输入js代码，观察</p><h2 id="2-2数据类型"><a href="#2-2数据类型" class="headerlink" title="2.2数据类型"></a>2.2<strong>数据类型</strong></h2><p><strong>number</strong></p><pre><code class="hljs js"><span class="hljs-number">123</span> <span class="hljs-comment">//整数123</span><span class="hljs-number">123.1</span> <span class="hljs-comment">//浮点数123.1</span><span class="hljs-number">1.123e3</span> <span class="hljs-comment">//科学计数法</span><span class="hljs-number">-99</span> <span class="hljs-comment">//复数</span><span class="hljs-literal">NaN</span> <span class="hljs-comment">// not a number</span><span class="hljs-literal">Infinity</span> <span class="hljs-comment">//表示无穷大</span></code></pre><p><strong>字符串</strong></p><p>单引号or双引号  注意转义字符</p><pre><code class="hljs js"><span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a\&#x27;&quot;</span>)  <span class="hljs-comment">//打印 a&#x27;</span><span class="hljs-comment">//多行字符串 tab上方键引起来</span><span class="hljs-keyword">var</span> msg = <span class="hljs-string">`</span><span class="hljs-string">hello</span><span class="hljs-string">world</span><span class="hljs-string">你好！</span><span class="hljs-string">`</span><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;heng&quot;</span>;<span class="hljs-keyword">let</span> print = <span class="hljs-string">`你好， <span class="hljs-subst">$&#123;name&#125;</span>`</span>  <span class="hljs-comment">//可以这样引用</span><span class="hljs-comment">//字符串长度,并且可以通过下标进去取字符(java不可以)，但字符串不可变</span>str.length<span class="hljs-comment">//大小写转换</span>student.toUpperCase()student.toLowerCase()</code></pre><p><strong>布尔值</strong></p><p><code>true</code> <code>false</code></p><p><strong>逻辑运算</strong></p><p><code>&amp;&amp; || !</code>  与或非</p><p><strong>比较运算符</strong></p><pre><code class="hljs js">=  <span class="hljs-comment">//赋值</span>==    <span class="hljs-comment">// 等于(类型不一样，值一样，为true)</span>    <span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment">//是true</span>===  <span class="hljs-comment">// 绝对等于(类型一样并且值也要一样)</span></code></pre><blockquote><p>ps: NaN == NaN 为false，即NaN与所有的数值均不等，包括自己</p><p>只能通过isNaN(NaN) 来判断是否为NaN</p></blockquote><p>浮点数问题  (会有精度) </p><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>-(<span class="hljs-number">1</span><span class="hljs-number">-2</span>/<span class="hljs-number">3</span>)) &lt; <span class="hljs-number">0.0000000001</span> <span class="hljs-comment">//此时认为相等</span></code></pre><p><strong>null 和 undefined</strong></p><ul><li>null 表示空     undefined表示未定义</li></ul><p><strong>数组</strong>(关键如何<strong>存和取</strong>)</p><p>js中数组里面不需要相同的类型,可以包含任意类型</p><pre><code class="hljs js"><span class="hljs-comment">//1 推荐使用</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>];<span class="hljs-comment">//2 </span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>);</code></pre><p>若下标越界，则会出现 <code>undefined</code></p><pre><code class="hljs js"><span class="hljs-comment">//可以给arr.length 赋值，此时数组长度会变化</span>arr.indexOf(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2在数组中出现的下标索引</span>slice()  ==&gt; 截取数组的一部分，并返回新数组 类似于字符串中的substringarr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>]arr.slice(<span class="hljs-number">3</span>) <span class="hljs-comment">//[4,5,6,&quot;1&quot;,&quot;2&quot;]</span>arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[2,3,4,5]arr.push(&quot;a&quot;,&quot;b&quot;) </span><span class="hljs-comment">//对数组arr进行添加元素</span>arr.push() <span class="hljs-comment">//&quot;b&quot;被弹出 ，push，pop均 是尾部  若要头部===&gt; unshift(),shift()arr.sort()</span><span class="hljs-comment">//数组排序</span>arr.reverse() <span class="hljs-comment">//数组反转</span>arr.concat([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment">//在arr后面连接上数组[1,2,3],并没有改变数组，只是返回一个新数组</span>arr.join(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">//将数组元素用-连接起来</span></code></pre><p><strong>对象</strong></p><p>大括号括起来，每个属性之间逗号隔开，最后一个不需要加</p><p><strong>js中的所有键均是字符串，值是任意对象</strong></p><p>格式：</p><p><code>var 对象名 = &#123;         属性名: 属性值,         属性名: 属性值,         属性名: 属性值 &#125;</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> person =  &#123;       name: <span class="hljs-string">&quot;heng&quot;</span>,        age : <span class="hljs-number">20</span>,        flag:[<span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;js&#x27;</span>]&#125;可以通过<span class="hljs-keyword">delete</span>删除对象属性也可以直接动态添加属性，直接给属性赋值即可person.id = <span class="hljs-string">&quot;123&quot;</span>;<span class="hljs-comment">//xxx in xxx 可以判断属性值是否在对象中,同时继承父类</span><span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> person <span class="hljs-comment">//true</span><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> person <span class="hljs-comment">//true </span></code></pre><p><strong>Map和Set</strong></p><p>es6新特性</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">100</span>],[<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-number">90</span>],[<span class="hljs-string">&#x27;heng&#x27;</span>,<span class="hljs-string">&#x27;80&#x27;</span>]]);       <span class="hljs-keyword">var</span> s = map.get(<span class="hljs-string">&#x27;jack&#x27;</span>);       <span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">//打印90</span><span class="hljs-comment">//Set 无序不重复的集合</span><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">//只有3,1，可去重</span>set.add(<span class="hljs-number">2</span>);set.delete(<span class="hljs-number">1</span>);<span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">3</span>)); <span class="hljs-comment">//判断set中是否含有3</span></code></pre><h2 id="2-3严格检查格式"><a href="#2-3严格检查格式" class="headerlink" title="2.3严格检查格式"></a>2.3严格检查格式</h2><pre><code class="hljs js"><span class="hljs-comment">/*  idea开启es6语法 ==&gt; settings,javascript version </span><span class="hljs-comment">&#x27;use strict&#x27;; 严格检查模式，必须写第一行，防止js的随意性产生问题</span><span class="hljs-comment">局部变量定义建议用let定义  */</span><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;</code></pre><h2 id="2-4-流程控制"><a href="#2-4-流程控制" class="headerlink" title="2.4 流程控制"></a>2.4 流程控制</h2><p>和java一样</p><pre><code class="hljs js"><span class="hljs-comment">//判断</span><span class="hljs-keyword">if</span>... else <span class="hljs-keyword">if</span>...else... <span class="hljs-comment">//循环</span><span class="hljs-keyword">for</span>，<span class="hljs-keyword">while</span>，<span class="hljs-keyword">do</span>...while <span class="hljs-keyword">var</span> num = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>];<span class="hljs-comment">//forEach调用函数进行遍历</span>num.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span><span class="hljs-function"></span>&#123;        <span class="hljs-built_in">console</span>.log(value)&#125;)<span class="hljs-comment">//iterator迭代器(es6引入)</span><span class="hljs-comment">//for..in ===&gt;  for(var index in object) &#123;&#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> numKey <span class="hljs-keyword">in</span> num) &#123;    <span class="hljs-built_in">console</span>.log(num[numKey]);&#125;<span class="hljs-comment">//for..of </span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sElement <span class="hljs-keyword">of</span> num) &#123;    <span class="hljs-built_in">console</span>.log(sElement);&#125;</code></pre><h1 id="3-函数及面向对象"><a href="#3-函数及面向对象" class="headerlink" title="3.函数及面向对象"></a>3.函数及面向对象</h1><h2 id="3-1-函数定义及变量作用域"><a href="#3-1-函数定义及变量作用域" class="headerlink" title="3.1 函数定义及变量作用域"></a>3.1 函数定义及变量作用域</h2><p><strong>定义函数</strong> </p><pre><code class="hljs js"><span class="hljs-comment">//1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> -x;    &#125;&#125;<span class="hljs-comment">//2</span><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123; ...  &#125;</code></pre><blockquote><p>js函数调用可以传递任意多个参数，也可以不传递参数，不报错，可进行手动定义异常</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//手动定义异常</span><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Not a number&quot;</span>;&#125;<span class="hljs-comment">//可利用arguments获得传递来的参数，是一个数组</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x = &quot;</span>+x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[i]);&#125;</code></pre><p><img src="/2022/01/21/JavaScript/05.png" alt="image-20220122181527949"></p><p>问题：因为arguments获取所有的参数，如果我们想获取除传递以外的参数，如何办？</p><blockquote><p>rest ===&gt; es6引入的新特性，可获取除定义外的所有参数</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//以前获取</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">arguments</span>; i++) &#123;        <span class="hljs-comment">//....   </span>    &#125;&#125;<span class="hljs-comment">//现在rest==&gt;   只能写在最后面，用...标识</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a,b,...rest</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span> + a);        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;b&quot;</span> + b);        <span class="hljs-built_in">console</span>.log(rest);&#125;</code></pre><p><img src="/2022/01/21/JavaScript/06.png" alt="image-20220122183233655"></p><p><strong>作用域</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;    x = x + <span class="hljs-number">1</span>;&#125;x = x +<span class="hljs-number">2</span>;<span class="hljs-comment">//Uncaught ReferenceError: x is not defined</span></code></pre><p>若函数外想访问里面的变量，如何操作===&gt;  <strong>闭包</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<span class="hljs-comment">//内部函数可以访问外部函数,反之可以</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> y = x + <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">var</span> z = y + <span class="hljs-number">1</span>;<span class="hljs-comment">//Uncaught ReferenceError: z is not defined</span>&#125;</code></pre><blockquote><p>提升作用域问题===&gt;  <strong>故所有的变量定义均放在头部(规范)</strong></p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;x &quot;</span> + y;    <span class="hljs-built_in">console</span>.log(x);    <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;y&#x27;</span>; <span class="hljs-comment">//此时y的定义将提升，但是对其赋值并不会</span>&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> y;    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;x &quot;</span> + y;    <span class="hljs-built_in">console</span>.log(x);    y = <span class="hljs-string">&#x27;y&#x27;</span>; <span class="hljs-comment">//此时y的定义将提升，但是对其赋值并不会</span>&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//格式:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>,         y = x + <span class="hljs-number">1</span>,         z,i,a;<span class="hljs-comment">//undefined    </span>    <span class="hljs-comment">//之后进行使用，若再需要新变量，上面继续添加</span>&#125;</code></pre><p><strong>全局变量</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">//x为全局变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(x);&#125;f1();<span class="hljs-built_in">console</span>.log(x);<span class="hljs-comment">//打印：  1  1</span></code></pre><p>js实际上只有一个全局作用域，**任何变量(函数也可当做变量)**，假设没有在函数的作用范围内找到，则向外查找，如果全局作用域都没找到，则报错<code>RefrenceError</code></p><blockquote><p>规范：</p><p>因为<strong>所有的全局变量均绑定到我们的windows对象上</strong>(alert也是在windows上的)，故如果不同的js文件，若使用了相同的全局变量。</p><p>则造成冲突，如何解决？===&gt;</p><p><strong>把自己的代码全部放在自己定义的唯一空间名字中，降低全局命名冲突的问题</strong></p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> Yiheng = &#123;&#125;; <span class="hljs-comment">//自己定义的唯一全局变量  ===&gt;  jQuery就是如此操作的</span><span class="hljs-comment">//若定义其他的，则进行如下操作</span>Yiheng.name = <span class="hljs-string">&quot;yiheng&quot;</span>;Yiheng.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;</code></pre><p><strong>局部作用域 ==&gt; <code>let</code>关键字定义变量</strong></p><p><strong>常量</strong> ==&gt; <code>const</code></p><blockquote><p>在es6之前，定义常量是规定用大写字母进行定义，然后建议不修改！(有点扯….2333)</p><p>故es6引入了const用于修饰常量</p></blockquote><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a><strong>3</strong>.2 方法</h2><p>方法即是把函数放在对象的里面，<strong>对象只有：属性和方法</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> heng = &#123;    name : <span class="hljs-string">&quot;yiheng&quot;</span>,    brith : <span class="hljs-string">&#x27;2000&#x27;</span>,     <span class="hljs-comment">//方法    </span>    age : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();         <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.brith;  <span class="hljs-comment">//this默认指向调用它的对象    </span>    &#125;&#125;<span class="hljs-comment">//调属性</span>heng.name;<span class="hljs-comment">//调方法</span>heng.age();</code></pre><p>在js中，可以控制this的指向 ===&gt; 通过<code>apply</code>,所有的函数均有</p><pre><code class="hljs js"><span class="hljs-comment">//可将方法定义在外面</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();       <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.brith;&#125;<span class="hljs-keyword">var</span> heng = &#123;     name : <span class="hljs-string">&quot;yiheng&quot;</span>,      brith : <span class="hljs-string">&#x27;2000&#x27;</span>,        <span class="hljs-comment">//方法    </span>    age : getAge&#125;<span class="hljs-comment">//调用调用    </span>heng.age() <span class="hljs-comment">//打印22    </span>getAge()  <span class="hljs-comment">//打印NaN  this并没有指向heng    </span>getAge.apply(heng,[]);  <span class="hljs-comment">//此时this指向了heng，打印22</span></code></pre><h2 id="3-3创建对象"><a href="#3-3创建对象" class="headerlink" title="3.3创建对象"></a>3.3创建对象</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> student  =  &#123;        name : <span class="hljs-string">&quot;jack&quot;</span>,        age : <span class="hljs-string">&#x27;20&#x27;</span>,        run : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run...&quot;</span>);       &#125;&#125;<span class="hljs-keyword">var</span> heng = &#123;    name : <span class="hljs-string">&quot;heng&quot;</span>&#125;heng.__proto__ = student; <span class="hljs-comment">//将heng指向student，即heng的原型为student</span></code></pre><h2 id="3-4class继承-新特性"><a href="#3-4class继承-新特性" class="headerlink" title="3.4class继承(新特性)"></a>3.4class继承(新特性)</h2><blockquote><p><code>class</code>在es6引入</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//定义Student类，js中叫做  原型对象 JavaScript仍然是基于原型的。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name) &#123;        <span class="hljs-built_in">this</span>.name = name;        &#125;        hello() &#123;                alert(<span class="hljs-string">&quot;hello!&quot;</span>);        &#125;&#125;<span class="hljs-comment">//声明对象</span><span class="hljs-keyword">var</span> heng = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Yiheng&quot;</span>);</code></pre><pre><code class="hljs js"><span class="hljs-comment">//继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pupil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name,grade) &#123;         <span class="hljs-built_in">super</span>();                <span class="hljs-built_in">this</span>.grade = grade;     &#125;       my() &#123;         alert(<span class="hljs-string">&quot;我是小学生&quot;</span>);     &#125;&#125;<span class="hljs-keyword">var</span> jack = <span class="hljs-keyword">new</span> pupil(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">2</span>);</code></pre><h2 id="3-5原型链继承-难"><a href="#3-5原型链继承-难" class="headerlink" title="3.5原型链继承(难)"></a>3.5原型链继承(难)</h2><blockquote><ul><li><p>每个对象都有一个<code>__proto__</code>，它指向它的<code>prototype</code>原型对象，而<code>prototype</code>原型对象又具有一个自己的<code>prototype</code>原型对象，就这样层层往上直到一个对象的原型<code>prototype</code>为<code>null</code></p><p>这个查询的路径就是<code>原型链</code></p></li></ul></blockquote><p><img src="/2022/01/21/JavaScript/07.png" alt="image-20220123155241306"></p><h1 id="4-常用对象"><a href="#4-常用对象" class="headerlink" title="4.常用对象"></a>4.常用对象</h1><h2 id="4-1Date"><a href="#4-1Date" class="headerlink" title="4.1Date"></a>4.1Date</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();date.getFullYear();date.getMonth();date.getDate();date.getDay();date.getHours();date.getMinutes();date.getSeconds();date.getTime(); <span class="hljs-comment">//时间戳==&gt; 1970-1-1-0:00 到今天的毫秒数</span>date.toDateString()<span class="hljs-string">&#x27;Sun Jan 23 2022&#x27;</span>date.toGMTString()<span class="hljs-string">&#x27;Sun, 23 Jan 2022 06:48:52 GMT&#x27;</span></code></pre><h2 id="4-2-JSON"><a href="#4-2-JSON" class="headerlink" title="4.2 JSON"></a>4.2 JSON</h2><blockquote><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2">资料交换格式</a>,采用<strong>完全独立于编程语言的文本格式</strong>来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率</p></blockquote><p>在js中，一切均对象，任何js支持的类型均可以用JSON进行表示</p><p>格式：  </p><ul><li>对象都用 {}</li><li>数组用 []</li><li>所有的键值对 用key : value</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;    name:<span class="hljs-string">&quot;heng&quot;</span>,     age : <span class="hljs-number">20</span>,    <span class="hljs-attr">sex</span> : <span class="hljs-string">&#x27;男&#x27;</span>&#125;<span class="hljs-comment">//对象转json字符串</span><span class="hljs-built_in">JSON</span>.stringify(obj)<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;heng&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span><span class="hljs-comment">// json字符串解析为对象</span><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;heng&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span>)&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;heng&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;</code></pre><p><strong>Ajax</strong></p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术）</p><p>指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术</p></blockquote><ul><li>原生的js写法 ==&gt; xhr 异步请求</li><li>jQuery封装的方法 ==&gt; $(“#name”).ajax(“”)</li><li>axios请求</li></ul><h1 id="5操作Dom元素"><a href="#5操作Dom元素" class="headerlink" title="5操作Dom元素"></a>5操作Dom元素</h1><p>Document Object Model  文档对象化模型</p><p><strong>浏览器网页即是一个Dom树结构</strong></p><p><img src="/2022/01/21/JavaScript/08.png" alt="image-20220123183002561"></p><p><strong>核心：增删改查</strong></p><p>要操作Dom结点，则必须<strong>获得此节点</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;father&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>h1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;p1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-comment">//对应css选择器</span></span><span class="javascript">    <span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> p1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;p2&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;father&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">var</span> childrens = father.children; <span class="hljs-comment">//获得父节点下的所有子节点</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>上面均是原生代码，之后将使用<code>jQuery</code>代替</p><h2 id="5-1插入Dom"><a href="#5-1插入Dom" class="headerlink" title="5.1插入Dom"></a>5.1插入Dom</h2><p>获得Dom结点后。若dom结点为空，则通过<code>innerHTML</code>就可以增加一个元素</p><p>若这个dom结点存在元素，则会导致覆盖，不采用！  采用<code>append</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;js&quot;</span>&gt;</span>javaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;se&quot;</span>&gt;</span>javase<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;ee&quot;</span>&gt;</span>javaee<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;me&quot;</span>&gt;</span>javaMe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span>  js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;js&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-comment">//浏览器执行追加</span>list.append(js)</code></pre><p>如图<img src="/2022/01/21/JavaScript/09.png" alt="image-20220123200924488"></p><p><strong>创建新结点</strong></p><pre><code class="hljs js"><span class="hljs-comment">//通过js创建新结点</span><span class="hljs-keyword">var</span> newP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);newP.id = <span class="hljs-string">&quot;newP&quot;</span>;newP.innerText = <span class="hljs-string">&quot;hello!&quot;</span>;<span class="hljs-comment">//追加newp到list后面 </span>list.append(newP);<span class="hljs-comment">//还可以利用 insertBefore() 方法在已有的子节点前插入一个新的子节点。</span>node.insertBefore(要插入的节点对象,要添加新的节点前的子节点)</code></pre><p>可看到<img src="/2022/01/21/JavaScript/10.png" alt="image-20220123201719110"></p><pre><code class="hljs js"><span class="hljs-comment">//可以插入各种标签，比如js</span><span class="hljs-keyword">var</span> myScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)myScript.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>,<span class="hljs-string">&#x27;text/javascript&#x27;</span>);list.append(myScript);</code></pre><p><img src="/2022/01/21/JavaScript/11.png" alt="image-20220123202857433"></p><pre><code class="hljs js"><span class="hljs-comment">//甚至修改body的属性，可以添加css进行改变</span><span class="hljs-keyword">var</span> myStyle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>);myStyle.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>,<span class="hljs-string">&#x27;text/css&#x27;</span>);myStyle.innerHTML = <span class="hljs-string">&#x27;body&#123;background-color:chartreuse&#125;&#x27;</span>; <span class="hljs-comment">//设置样式</span><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].append(myStyle); <span class="hljs-comment">//在head内部添加css代码，此时就会生效</span></code></pre><p><img src="/2022/01/21/JavaScript/12.png" alt="image-20220123203852757"></p><p><img src="/2022/01/21/JavaScript/13.png" alt="image-20220123204006113"></p><h2 id="5-2-更新Dom"><a href="#5-2-更新Dom" class="headerlink" title="5.2 更新Dom"></a>5.2 更新Dom</h2><p><strong>操作文本</strong>  设置之后将会在对应网页显示出来</p><pre><code class="hljs js">id1.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span><span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span>id1.innerText = <span class="hljs-string">&quot;123&quot;</span><span class="hljs-string">&#x27;123&#x27;</span></code></pre><p><strong>操作css</strong></p><pre><code class="hljs js">id1.style.color = <span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-string">&#x27;red&#x27;</span>id1.style.fontSize = <span class="hljs-string">&#x27;100px&#x27;</span><span class="hljs-string">&#x27;100px&#x27;</span></code></pre><h2 id="5-3删除Dom"><a href="#5-3删除Dom" class="headerlink" title="5.3删除Dom"></a>5.3删除Dom</h2><p>步骤：先获取它父节点，然后通过父节点删除它</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> self = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);<span class="hljs-keyword">var</span> father = self.parentElement;father.removeChild(self);<span class="hljs-comment">//获得自己，然后得到自己的父亲，然后通过父亲杀死自己</span></code></pre><p>删除结点的时候，是动态的过程，children是时刻变化的</p><h1 id="6-操作Bom元素-重点"><a href="#6-操作Bom元素-重点" class="headerlink" title="6.操作Bom元素(重点)"></a>6.操作Bom元素(重点)</h1><p><strong>Browser Object Model</strong> (浏览器对象模型)</p><blockquote><p> js的出现就是为了能让它在浏览器中运行！</p></blockquote><h2 id="6-1Windows"><a href="#6-1Windows" class="headerlink" title="6.1Windows"></a>6.1Windows</h2><p>浏览器窗口 </p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.outerHeight<span class="hljs-number">824</span><span class="hljs-built_in">window</span>.outerWidt<span class="hljs-number">1536</span><span class="hljs-built_in">window</span>.innerHeight<span class="hljs-number">287</span><span class="hljs-built_in">window</span>.innerWidth<span class="hljs-number">1536</span><span class="hljs-comment">//....</span></code></pre><h2 id="6-2-navigator"><a href="#6-2-navigator" class="headerlink" title="6.2 navigator"></a>6.2 navigator</h2><pre><code class="hljs js">navigator.appName<span class="hljs-string">&#x27;Netscape&#x27;</span>navigator.appVersion<span class="hljs-string">&#x27;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&#x27;</span>navigator.userAgent<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&#x27;</span>navigator.platform<span class="hljs-string">&#x27;Win32&#x27;</span></code></pre><p>不建议使用这个属性来判断或编写代码，因为会被人为修改</p><h2 id="6-3-screen"><a href="#6-3-screen" class="headerlink" title="6.3 screen"></a>6.3 screen</h2><pre><code class="hljs js">screen.width1536 <span class="hljs-comment">//pxscreen.height864 //px</span></code></pre><h2 id="6-4-location"><a href="#6-4-location" class="headerlink" title="6.4 location"></a>6.4 location</h2><p>定位==&gt; <strong>Location 对象包含有关当前 URL 的信息</strong></p><pre><code class="hljs awk">location.reload()  <span class="hljs-regexp">//</span>重新加载页面，即刷新<span class="hljs-regexp">//</span> 跳转到指定页面,设置新的地址location.assign(<span class="hljs-string">&quot;URL&quot;</span>)</code></pre><h2 id="6-5-Document"><a href="#6-5-Document" class="headerlink" title="6.5 Document"></a>6.5 Document</h2><p><strong>代表当前页面</strong>，html dom文档树</p><p>可获取具体的文档树节点，则可以动态增删节点，即修改网页</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaEE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaSE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> test_dl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//打印 test_dl  可获取具体内容//可获取cookiedocument.cookie</code></pre><p>当<a href="https://www.taobao.com/">淘宝</a>在网址上登陆时，此时<a href="https://www.tmall.com/">天猫</a>也进行同步登陆了===&gt; 拿到cookie就可以访问你的信息，故尽量不要暴露cookie</p><p>服务器端可以设置cookie：httpOnly</p><h2 id="6-6-History"><a href="#6-6-History" class="headerlink" title="6.6 History"></a>6.6 History</h2><p>代表浏览器的历史记录</p><pre><code class="hljs awk">history.back() <span class="hljs-regexp">//</span>后退history.forward() <span class="hljs-regexp">//</span>前进</code></pre><h2 id="6-7-操作表单"><a href="#6-7-操作表单" class="headerlink" title="6.7 操作表单"></a>6.7 操作表单</h2><p>网站怎样与用户进行交互？==&gt;使用HTML表单(form)。</p><p><strong>表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</strong><br> 语法：<code>&lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt;</code></p><p>什么是表单？</p><ul><li>文本框 text</li><li>下拉框 <select></select></li><li>单选框 radio</li><li>多选框 checkbox</li><li>隐藏框 hidden</li><li>密码框 password…..</li></ul><p>表单的目的  ===&gt;  <strong>提交信息</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;username&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   <span class="hljs-keyword">var</span> input_text = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><span class="javascript">  <span class="hljs-comment">//得到输入框的值： 浏览器console中输入===&gt;  input_text.value</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>前端一般会采用<code>MD5</code>进行加密</p><h1 id="7-jQuery"><a href="#7-jQuery" class="headerlink" title="7.jQuery"></a>7.jQuery</h1><p>是一个库，里面包含了大量的js函数</p><p> <a href="https://jquery.com/download/">jQuery下载</a></p><pre><code class="hljs html">//引用<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中</p><p>而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名</p><p><strong>公式</strong>: <code>$(css选择器).事件(事件函数)</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span> =<span class="hljs-string">&quot;test&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    $(<span class="hljs-string">&#x27;#test&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        alert(<span class="hljs-string">&quot;hello jQuery!&quot;</span>)</span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><a href="https://jquery.cuishifeng.cn/">jQuery API中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>普通 vs 多线程</p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/01.png" alt="image-20220120175224495"></p><ul><li><p>程序：指指令和数据的有序集合，其本身没有任何含义，是一个<strong>静态</strong>的概念</p></li><li><p>进程：指程序的一次执行过程，<strong>动态</strong>的概念，是系统资源分配的单位</p><ul><li>通常一个进程包含多个<strong>线程</strong>。<strong>线程是CPU调度和执行的单位</strong></li></ul></li></ul><p><strong>主要概念：</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/02.png" alt="image-20220120175908442"></p><h1 id="二-线程实现-重点"><a href="#二-线程实现-重点" class="headerlink" title="二.线程实现(重点)"></a>二.线程实现(重点)</h1><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/03.png" alt="image-20220126091456256"></p><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><ul><li>自定义线程类继承<strong>Thread类</strong></li><li>重写**run()**方法，编写线程执行体</li><li>创建线程对象，调用**start()**方法启动线程</li></ul><blockquote><p>线程开启不一定立刻执行，由cpu调度</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    <span class="hljs-comment">//主线程</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程对象</span>        Main testThread = <span class="hljs-keyword">new</span> Main();        <span class="hljs-comment">//调用start方法，开启线程</span>        testThread.start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习main线程&quot;</span> + i);        &#125;     &#125;     <span class="hljs-comment">//run方法线程</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习run线程&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><ul><li><p>定义MyRunnable类实现<strong>Runnable接口</strong></p></li><li><p><strong>实现run()方法</strong>，编写线程执行体</p></li><li><p>创建线程对象，调用**start()**方法启动线程</p><blockquote><p>由于java的单继承 ,故推荐使用<strong>Runnable接口</strong> 来进行实现多线程</p><p>方便同一个对象被多个线程使用</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-comment">//创建线程==&gt; 2.实现Runnable接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread_03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建实现Runnable接口对象</span>        TestThread_03 t = <span class="hljs-keyword">new</span> TestThread_03();        <span class="hljs-comment">//创建线程对象，通过对象，开启线程 ==&gt; ( 代理 )</span>        <span class="hljs-keyword">new</span> Thread(t).start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习main线程&quot;</span> + i);        &#125;    &#125;    <span class="hljs-comment">//run方法线程</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;我在学习run线程&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><p>两者对比：</p><pre><code class="hljs java"><span class="hljs-comment">//1.继承Thread类</span>PrimeThread p = <span class="hljs-keyword">new</span> PrimeThread();p.start();  <span class="hljs-comment">//2.实现Runnable接口 </span>PrimeRun p = <span class="hljs-keyword">new</span> PrimeRun();<span class="hljs-keyword">new</span> Thread(p).start();</code></pre><p><strong>并发</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.week03.day01.thread_01;<span class="hljs-comment">//模拟多线程抢票 ==&gt; 即多个线程共享同一个资源 （ 会导致资源同时被占用 )</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread04</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tick_num = <span class="hljs-number">10</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (tick_num &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢走了第&quot;</span> + (tick_num--) + <span class="hljs-string">&quot;票&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TestThread04 t4 = <span class="hljs-keyword">new</span> TestThread04();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;jack&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;Tom&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(t4,<span class="hljs-string">&quot;rogue&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="3-实现callable接口"><a href="#3-实现callable接口" class="headerlink" title="3.实现callable接口"></a>3.实现callable接口</h2><p>(了解)</p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/04.png" alt="image-20220126104754812"></p><p>  具体==&gt; 多线程下载图片  (利用callable) </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Boolean</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> String url; <span class="hljs-comment">//图片地址</span>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//图片名字</span>    <span class="hljs-comment">//构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestCallable</span><span class="hljs-params">(String url, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.url = url;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-comment">//重写call方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        WebDownloader webDownloader = <span class="hljs-keyword">new</span> WebDownloader();        webDownloader.downloader(url, name);        System.out.println(<span class="hljs-string">&quot;Ok ==&gt; &quot;</span> + name);<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        TestCallable t1 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx3.sinaimg.cn/mw2000/007ZMXFDly1gym8x8f8okj30gu0nk0ub.jpg&quot;</span>, <span class="hljs-string">&quot;math01.jpg&quot;</span>);        TestCallable t2 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx4.sinaimg.cn/mw2000/007ZMXFDly1gym8x8o91gj30h10lcwfz.jpg&quot;</span>, <span class="hljs-string">&quot;math02.jpg&quot;</span>);        TestCallable t3 = <span class="hljs-keyword">new</span> TestCallable(<span class="hljs-string">&quot;https://wx1.sinaimg.cn/mw2000/008buUVXgy1gyoro1n27aj31410u0whn.jpg&quot;</span>, <span class="hljs-string">&quot;math03.jpg&quot;</span>);        <span class="hljs-comment">//创建执行服务</span>        ExecutorService ser = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-comment">//提交执行</span>        Future&lt;Boolean&gt; result1 = ser.submit(t1);        Future&lt;Boolean&gt; result2 = ser.submit(t2);        Future&lt;Boolean&gt; result3 = ser.submit(t3);        <span class="hljs-comment">//执行结果</span>        <span class="hljs-keyword">boolean</span> r1 = result1.get();        <span class="hljs-keyword">boolean</span> r2 = result2.get();        <span class="hljs-keyword">boolean</span> r3 = result3.get();        <span class="hljs-comment">//关闭服务</span>        ser.shutdownNow();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebDownloader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloader</span><span class="hljs-params">(String url,String name)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> URL(url),<span class="hljs-keyword">new</span> File(name));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;io异常，downloader方法出错！&quot;</span>);        &#125;    &#125;&#125;</code></pre><h2 id="4-静态代理"><a href="#4-静态代理" class="headerlink" title="4.静态代理"></a>4.静态代理</h2><p>真实对象和代理对象都要实现同一个接口</p><p>代理对象要代理真实目标角色    </p><blockquote><p><strong>代理模式</strong>给某一个对象提供一个代理对象，并<strong>由代理对象控制对原对象的引用</strong>  即</p><p>就是提供一个对象相当于中介者，他可以帮我们调用目标的功能，同时我们可以在使用目标功能的同时扩展其他功能，而不需要直接改到目标类。</p></blockquote><p>代理的好处：</p><ul><li><strong>中介隔离</strong>作用：在某些情况下，如果某个类并不想被直接调用，那么通过创建代理类，就可以避免目标类被直接调用，这样可以保护目标类不会被曝光</li><li>可以<strong>扩展功能而不用影响目标类</strong>：假设有一个核心类提供了一些核心业务，而我们希望使用这个功能时上报日志，或者某个业务要先进行某些处理才调用，那这样如果直接改核心类，就会给核心功能加上了一些无关的内容，变得这个功能与业务有很大关联，难以复用。这时我们使用代理类的话，就可以在代理类中添加自己的业务逻辑，而不需要破坏原有的核心功能。</li></ul><blockquote><p><strong>静态代理</strong>指是由程序员手动编写或者自动生成的代理类，在程序编译的时候就可以生成对应的class文件，在运行时可以直接使用。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StaticProxy staticProxy = <span class="hljs-keyword">new</span> StaticProxy(<span class="hljs-keyword">new</span> User_01());        staticProxy.sayHello();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User_01</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-keyword">private</span> User_01 target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxy</span><span class="hljs-params">(User_01 target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;before hello&quot;</span>);        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;            target.sayHello(); <span class="hljs-comment">// 实际调用目标功能</span>        &#125;        System.out.println(<span class="hljs-string">&quot;after hello&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISayHello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*打印：</span><span class="hljs-comment">before hello</span><span class="hljs-comment">hello!</span><span class="hljs-comment">after hello</span><span class="hljs-comment">*/</span></code></pre><h2 id="5-Lamda表达式"><a href="#5-Lamda表达式" class="headerlink" title="5.Lamda表达式"></a>5.Lamda表达式</h2><p>避免匿名内部类定义过多</p><p>实质属于<strong>函数式编程</strong>的概念</p><p><code>(parama) -&gt; expression[表达式]</code></p><p><code>(params) -&gt; statement[语句] </code></p><p><code>(params) -&gt; &#123;statements&#125;</code></p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread( ()-&gt; System.out.println(<span class="hljs-string">&quot;多线程学习.....&quot;</span>) ).start();</code></pre><p><strong>Functional Interface ( 函数式接口 )</strong>  学习java8 lamda表达式的关键</p><pre><code class="hljs java"><span class="hljs-comment">//定义： 任何接口，若只包含唯一一个抽象方法，则就是一个函数式接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>对于函数式接口，我们可以通过lamda表达式来创建该接口的对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLamda</span> </span>&#123;    <span class="hljs-comment">//3.静态内部类</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like2</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">&quot;I like lamda2...&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//调用2</span>        <span class="hljs-keyword">new</span> like().lamda();        <span class="hljs-comment">//调用3</span>        <span class="hljs-keyword">new</span> like2().lamda();        <span class="hljs-comment">//4局部内部类</span>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like3</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;I like lamda3...&quot;</span>);            &#125;        &#125;        <span class="hljs-comment">//调用4</span>        <span class="hljs-keyword">new</span> like3().lamda();        <span class="hljs-comment">//5.匿名内部类</span>        Ilike like = <span class="hljs-keyword">new</span> like();        like = <span class="hljs-keyword">new</span> Ilike() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;I like lamda4...&quot;</span>);            &#125;        &#125;;        <span class="hljs-comment">//调用5</span>        like.lamda();        <span class="hljs-comment">//6 lamda表达式</span>        like = () -&gt;  &#123;            System.out.println(<span class="hljs-string">&quot;I like lamda5...&quot;</span>);        &#125;;        like.lamda();    &#125;&#125;<span class="hljs-comment">//1接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Ilike</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//2.实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">like</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Ilike</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lamda</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;I like lamda1...&quot;</span>);    &#125;&#125;</code></pre><h1 id="三-线程状态"><a href="#三-线程状态" class="headerlink" title="三.线程状态"></a>三.线程状态</h1><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/05.png" alt="image-20220127111512199"></p><p><strong>线程方法</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/06.png" alt="image-20220127112036363"></p><h2 id="1-线程停止"><a href="#1-线程停止" class="headerlink" title="1.线程停止"></a>1.线程停止</h2><ul><li><p>不推荐jdk推荐的<code>stop()</code> 和 <code>destroy()</code> 方法  (官方已废弃)</p></li><li><p>推荐让线程自己停下来</p></li><li><p>建议使用标志位进行中止，当<code>flag = false</code>,则中止</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-comment">//标志位</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (flag) &#123;          System.out.println(<span class="hljs-string">&quot;run..&quot;</span> + i++);      &#125;  &#125;  <span class="hljs-comment">//提供方法停止线程</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;      flag = <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      TestStop testStop = <span class="hljs-keyword">new</span> TestStop();      <span class="hljs-keyword">new</span> Thread(testStop).start(); <span class="hljs-comment">//启动线程</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(<span class="hljs-string">&quot;main...&quot;</span> + i);          <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">80</span> ) &#123;              testStop.stop();              System.out.println(<span class="hljs-string">&quot;this thread stopped!&quot;</span>);          &#125;      &#125;  &#125;&#125;</code></pre></li></ul><h2 id="2-线程睡眠"><a href="#2-线程睡眠" class="headerlink" title="2.线程睡眠"></a>2.线程睡眠</h2><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/07.png" alt="image-20220127113355513"> </p> <pre><code class="hljs java"><span class="hljs-comment">//倒计时</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSleep</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            tenDown();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;     <span class="hljs-comment">//获取系统时间,并进行比变化</span>        Date date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);                System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(date));                date = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());<span class="hljs-comment">//更新时间</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tenDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//每一次一秒钟进行倒计时</span>            Thread.sleep(<span class="hljs-number">1000</span>) ;            System.out.println(num --);            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="3-线程礼让"><a href="#3-线程礼让" class="headerlink" title="3.线程礼让"></a>3.线程礼让</h2><ul><li>让正在执行的线程暂停，但不阻塞</li><li>将线程从运行变为就绪</li><li>cpu重新调度，是否礼让成功，根据cpu而定，仍然又可能让了之后，还继续执行 </li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestYield</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyYield myYield = <span class="hljs-keyword">new</span> MyYield();        <span class="hljs-keyword">new</span> Thread(myYield,<span class="hljs-string">&quot;a==&gt;&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(myYield,<span class="hljs-string">&quot;b==&gt;&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyYield</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;start...&quot;</span>); <span class="hljs-comment">//线程开始</span>        Thread.yield(); <span class="hljs-comment">//当前线程进行礼让</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;end...&quot;</span>); <span class="hljs-comment">//线程结束</span>    &#125;&#125;</code></pre><p><strong>Join 合并线程</strong></p><ul><li>让线程强制等待，待此线程执行完成后，再执行其他线程，其他线程阻塞 ( <strong>理解为插队</strong> )</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJoin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        TestJoin testJoin = <span class="hljs-keyword">new</span> TestJoin();        Thread thread = <span class="hljs-keyword">new</span> Thread(testJoin);        thread.start(); <span class="hljs-comment">//启动run</span>        <span class="hljs-comment">//主线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">if</span>( i == <span class="hljs-number">50</span>) &#123;                System.out.println(<span class="hljs-string">&quot;插队!main等待我执行完才可执行!!&quot;</span>);                thread.join(); <span class="hljs-comment">//进行插队,此时vip一直打印到结束</span>            &#125;            System.out.println(<span class="hljs-string">&quot;main ..&quot;</span> +i);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;I am vip ..&quot;</span> + i) ;        &#125;    &#125;&#125;</code></pre><p><code>Thread.state</code> <strong>线程状态</strong></p><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/blog\source_posts\java多线程\08.png" alt="image-20220127121229233"></p><p><strong>线程优先级</strong></p><ul><li><p>java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p></li><li><p>优先级用数字表示，0~10</p><pre><code class="hljs JAVA">Thread.MIN_PRIORITY = <span class="hljs-number">1</span>;Thread.MAX_PRIORITY = <span class="hljs-number">10</span>;Thread.NORM_PRIORITY = <span class="hljs-number">5</span>;</code></pre></li><li><p>使用<code>getPriority().setPriority(int xx)</code>改变优先级</p></li></ul><blockquote><p>优先级低，不代表调度概论低，要看cpu调度</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPriority</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + Thread.currentThread().getPriority());        MyPriority myPriority = <span class="hljs-keyword">new</span> MyPriority();        Thread t1 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t2 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t3 = <span class="hljs-keyword">new</span> Thread(myPriority);        Thread t4 = <span class="hljs-keyword">new</span> Thread(myPriority);        <span class="hljs-comment">//先设置优先级，再启动</span>        t1.start(); <span class="hljs-comment">//t1默认优先级</span>        t2.setPriority(<span class="hljs-number">1</span>);        t2.start(); <span class="hljs-comment">//t2优先级设置为1</span>        t3.setPriority(<span class="hljs-number">6</span>);        t3.start(); <span class="hljs-comment">//t3.</span>        t4.setPriority(Thread.MAX_PRIORITY);        t4.start();<span class="hljs-comment">//t4..</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPriority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>  </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + Thread.currentThread().getPriority());    &#125;&#125;</code></pre><p><strong>守护线程</strong> <code>daemon</code></p><ul><li>线程分为<strong>用户线程和守护线程</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕 ==&gt; 如：后台记录操作日志，监控内存，垃圾回收…..</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDaemon</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        God god = <span class="hljs-keyword">new</span> God();        You you = <span class="hljs-keyword">new</span> You();        Thread thread = <span class="hljs-keyword">new</span> Thread(god);        thread.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//默认false是用户进程</span>        thread.start(); <span class="hljs-comment">//守护线程启动</span>        <span class="hljs-comment">//用户线程开启</span>        <span class="hljs-keyword">new</span> Thread(you).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;God always bless you!&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">365</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;I...&quot;</span> + i);        &#125;        System.out.println(<span class="hljs-string">&quot;bye!!!!&quot;</span>);    &#125;&#125;</code></pre><h1 id="四-线程同步-重点"><a href="#四-线程同步-重点" class="headerlink" title="四.线程同步(重点)"></a>四.线程同步(重点)</h1><p>多个线程操作同一个资源 </p><blockquote><p>并发： <strong>同一个对象</strong>被<strong>多个线程</strong>同时操作</p></blockquote><p>当多个线程访问一个对象，并且某些线程要修改对象，这时需要<strong>线程同步</strong></p><p>线程同步其实是一种<strong>等待机制</strong>，多个需要同时访问此对象的线程进入这个<strong>对象的等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用</p><blockquote><p><strong>队列 + 锁</strong> 才可保证线程同步的安全性</p></blockquote><p><img src="/2022/01/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/09.png" alt="image-20220127152403260"></p><pre><code class="hljs java"><span class="hljs-comment">//线程不安全的集合，因为线程会操作同一个地方，导致覆盖，最终打印并非10000</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnSafeList</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String &gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread( ()-&gt; &#123;                list.add(Thread.currentThread().getName());            &#125;).start();        &#125;        System.out.println(list.size());    &#125;&#125;</code></pre><p>在这个例子里，有两个问题</p><ul><li>第一是有些线程执行的太慢了，main线程执行完了，还有部分线程没执行完</li><li>第二是是可能会好多线程操作list的同一个l位置。</li></ul><p>加上<code>synchronized  (list) &#123; &#125;</code>之后解决了第二个问题。</p><p>第一个问题的原因，是<code>main</code>线程执行完了之后，还会有部分线程没执行完，在最后加上<code>sleep</code>，使得main线程先停止下，等待其他的线程执行完，然后输出就能正常了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnSafeList</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String &gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread( ()-&gt; &#123;                <span class="hljs-keyword">synchronized</span> (list) &#123;                    list.add(Thread.currentThread().getName());                &#125;            &#125;).start();        &#125;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(list.size());    &#125;&#125;</code></pre><p><code>synchronized</code>关键字 可分为<code>synchronized</code>方法 和 <code>synchronized</code>块</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">int</span> args)</span> </span>&#123;&#125;</code></pre><p>同步块：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(Obj) &#123;  &#125;</code></pre><p><strong>Obj为同步监视器，</strong>可以使任何对象，但一般使用共享资源作为同步监视器</p><p>同步方法中则不需要指定同步监视器，因为就是this对象本身</p><p>执行过程：</p><ul><li>a访问，锁定obj，执行代码</li><li>b访问，发现被锁，无法进行访问</li><li>a执行完毕，解锁</li><li>b访问，发现没锁，进行访问</li></ul><h1 id="五-线程通信"><a href="#五-线程通信" class="headerlink" title="五.线程通信"></a>五.线程通信</h1><h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>125.验证回文串</title>
    <link href="/2022/01/19/leetcode08/"/>
    <url>/2022/01/19/leetcode08/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个字符串，验证它是否是回文串，<strong>只考虑字母和数字字符</strong>，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p><p> 示例 1:</p><p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p><p>示例 2:</p><p>输入: “race a car”<br>输出: false<br>解释：”raceacar” 不是回文串</p><p>提示：</p><p>1 &lt;= s.length &lt;= 2 * 105<br>字符串 s 由 ASCII 字符组成</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>自顶向下思考</strong> ==&gt;  从高层次(主干) 逻辑 入手 ==&gt;</p><pre><code>1. filter out number &amp; char 2. reverse and compare</code></pre><h2 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        String filterS = _filterNonNumberAndChar(s);        <span class="hljs-keyword">return</span> _reverse(filterS).equalsIgnoreCase(filterS);     &#125;    <span class="hljs-comment">//filter out number &amp; char </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String  <span class="hljs-title">_filterNonNumberAndChar</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> s.replaceAll(<span class="hljs-string">&quot;[^A-Za-z0-9]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//正则表达式</span>    &#125;    <span class="hljs-comment">//reverse</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">_reverse</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuffer(s).reverse().toString();     &#125;&#125;</code></pre><p><strong>效率太低，又弄新字符串，又正则表达式</strong></p><h2 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解和反射</title>
    <link href="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-注解"><a href="#1-注解" class="headerlink" title="1.注解"></a>1.注解</h1><h2 id="1-1什么是注解"><a href="#1-1什么是注解" class="headerlink" title="1.1什么是注解"></a>1.1什么是注解</h2><p><strong>注解：Annotation</strong>(特殊的注释)</p><p><strong>注释：comment</strong></p><p>​    jdk5.0引入的新技术</p><p>作用：</p><ul><li>不是程序本身，可以对程序做出解释(与注释并无区别)</li><li><strong>可以被其他程序(如：编译器)读取</strong> </li></ul><p>格式：</p><blockquote><p>以 ”@注释名”在代码中存在，甚至可以添加一些参数 </p></blockquote><p>在哪使用:</p><blockquote><p>可附加在 package，class，method，field上，相当于添加了额外的辅助信息</p><p>然后通过反射机制编程实现对这些元数据的访问</p></blockquote><h2 id="1-2内置注解"><a href="#1-2内置注解" class="headerlink" title="1.2内置注解"></a>1.2内置注解</h2><ul><li>@Override：定义在java.lang.Override中，只适用于修饰方法<ul><li>表示一个方法声明打算重写父类的另一个方法声明</li></ul></li><li>@Deprecated：定义在java.lang.Deprecated中，可修饰方法，属性，类<ul><li>表示不推荐使用此类元素，通常是因为危险或存在其余更好的选择</li></ul></li><li>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用于抑制编译时的警告信息</li></ul><pre><code class="hljs java"><span class="hljs-comment">//需要添加参数才可以使用</span><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span></code></pre><h2 id="1-3元注解"><a href="#1-3元注解" class="headerlink" title="1.3元注解"></a>1.3元注解</h2><p>(meta-annotation)</p><p>作用：解释其他注解, 提供对其他annotation类型的作说明</p><ul><li><strong>@Target</strong>：用于描述注解的使用范围(被描述的注解可以在哪用)</li><li><strong>@Retention</strong>: 表示需要在什么级别保存该注解信息，用于描述注解的声明周期<ul><li>SOURCE &lt; CLASS &lt; RUNTIME</li></ul></li><li>@Document: 说明 注解将被包含在javadoc中</li><li>@Inherited: 说明子类可以继承父类中的该注解</li></ul><h2 id="1-4自定义注解"><a href="#1-4自定义注解" class="headerlink" title="1.4自定义注解"></a>1.4自定义注解</h2><p>使用@interface自定义，自动继承了java.lang.annotation.Annotation接口</p><p> <img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/00.png" alt="image-20220119063355717"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-comment">//可以进行显示赋值,与顺序无关，若没有默认值，则必须给注解赋值</span>    <span class="hljs-meta">@myAnnotation(age = 18,name = &quot;yiheng&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; &#125;    <span class="hljs-meta">@myAnnotation01(&quot;Alice&quot;)</span> <span class="hljs-comment">// 此时可直接传入即可，不用写value = “Alice” (规范</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> myAnnotation&#123;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;  <span class="hljs-comment">//参数：  参数类型 + 参数名()</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;    String[] schools() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">&quot;pku&quot;</span>,<span class="hljs-string">&quot;cmu&quot;</span>&#125;;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> myAnnotation01&#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//若只要一个参数，用value</span>&#125;</code></pre><h1 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h1><p><strong>Reflection</strong></p><h2 id="2-1java反射概述"><a href="#2-1java反射概述" class="headerlink" title="2.1java反射概述"></a>2.1java反射概述</h2><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/01.png" alt="image-20220119065433643"></p><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p><p><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/02.png" alt="image-20220119070004240"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/03.png" alt="image-20220119071046834"></p><p><strong>优点</strong> ：</p><ul><li>可以实现动态创建对象和编译</li><li>灵活性高</li></ul><p><strong>缺点</strong>：</p><p>​    对性能有影响，是一种解释操作，比直接执行相同的操作慢</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/04.png" alt="image-20220119071312355"></p><h2 id="2-2理解class类并获取class实例"><a href="#2-2理解class类并获取class实例" class="headerlink" title="2.2理解class类并获取class实例"></a>2.2理解class类并获取class实例</h2><p><strong>Class类</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/05.png" alt="image-20220119075234418"></p><p><strong>Class类的功能</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/06.png" alt="image-20220119075357574"></p><pre><code class="hljs java"><span class="hljs-comment">// 1 通过对象方式获取</span>        Person p1 = <span class="hljs-keyword">new</span> Student();        Class c1  = p1.getClass();        System.out.println(c1.hashCode());<span class="hljs-comment">//2 通过forName 获取</span>        Class c2 = Class.forName(<span class="hljs-string">&quot;test.day04.test03.Student&quot;</span>); <span class="hljs-comment">//Student的路径</span>        System.out.println(c2.hashCode());<span class="hljs-comment">//3 通过类名.class获取</span>        Class c3 = Student.class;        System.out.println(c3.hashCode());<span class="hljs-comment">/*</span><span class="hljs-comment">356573597</span><span class="hljs-comment">356573597</span><span class="hljs-comment">356573597</span><span class="hljs-comment">*/</span></code></pre><p><strong>哪些类型有Class对象</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/07.png" alt="image-20220119081133308"></p><pre><code class="hljs java"> Class c1 = Integer.class; Class c2 = Override.class; Class c3 = Object.class; Class c4 = Comparable.class; Class c5 = String[].class; Class c6 = <span class="hljs-keyword">int</span>[][].class; Class c7 = ElementType.class; Class c8 = <span class="hljs-keyword">void</span>.class; Class c9 = Class.class;<span class="hljs-comment">/*</span><span class="hljs-comment">打印：</span><span class="hljs-comment">class java.lang.Integer</span><span class="hljs-comment">interface java.lang.Override</span><span class="hljs-comment">class java.lang.Object</span><span class="hljs-comment">interface java.lang.Comparable</span><span class="hljs-comment">class [Ljava.lang.String;</span><span class="hljs-comment">class [[I</span><span class="hljs-comment">class java.lang.annotation.ElementType</span><span class="hljs-comment">void</span><span class="hljs-comment">class java.lang.Class</span><span class="hljs-comment">*/</span></code></pre><h2 id="2-3-类的加载与ClassLoader"><a href="#2-3-类的加载与ClassLoader" class="headerlink" title="2.3 类的加载与ClassLoader"></a>2.3 类的加载与ClassLoader</h2><p>内存分析</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/08.png" alt="image-20220119081952225"></p><p><strong>类加载过程</strong>：</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/09.png" alt="image-20220119082107807"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/10.png" alt="image-20220119083702892"></p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">1.加载到内存，会产生一个类对应的Class对象</span><span class="hljs-comment">2.链接，链接结束后 x = 0(默认)</span><span class="hljs-comment">3.初始化 </span><span class="hljs-comment">    &lt;clinit&gt;() &#123;</span><span class="hljs-comment">        System.out.println(&quot;A类静态代码块初始&quot;);</span><span class="hljs-comment">         x = 20;</span><span class="hljs-comment">         x = 10;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">static</span>  &#123;        System.out.println(<span class="hljs-string">&quot;A类静态代码块初始&quot;</span>);        x = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;A类构造方法初始&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    A a = <span class="hljs-keyword">new</span> A();    System.out.println(a.x);&#125;<span class="hljs-comment">/* 故打印结果</span><span class="hljs-comment">A类静态代码块初始</span><span class="hljs-comment">A类构造方法初始</span><span class="hljs-comment">10</span><span class="hljs-comment">*/</span></code></pre><p><strong>什么时候会发生类初始化 ？</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/11.png" alt="image-20220119084510203"></p><p><strong>类加载器</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/12.png" alt="image-20220119150313613">.</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/13.png" alt="image-20220119150339508"></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/14.png" alt="image-20220119150420155"></p><h2 id="2-4获取运行时类的对象"><a href="#2-4获取运行时类的对象" class="headerlink" title="2.4获取运行时类的对象"></a>2.4获取运行时类的对象</h2><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/15.png" alt="image-20220119151416083"></p><p>有了Class类，能做什么？</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/16.png" alt="image-20220120074411795"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.day05.test01;<span class="hljs-comment">//User类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> id;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;            <span class="hljs-keyword">this</span>.id = id;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> age;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">this</span>.age = age;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.id = id;            <span class="hljs-keyword">this</span>.age = age;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                    <span class="hljs-string">&quot;, id=&quot;</span> + id +                    <span class="hljs-string">&quot;, age=&quot;</span> + age +                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;        &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;        <span class="hljs-comment">//获得对象</span>        Class c1 = Class.forName(<span class="hljs-string">&quot;test.day05.test01.User&quot;</span>);        <span class="hljs-comment">//构造一个对象  本质调用了User类中的无参构造器</span>        User user =(User) c1.newInstance();        System.out.println(user);<span class="hljs-comment">//  打印  User&#123;name=&#x27;null&#x27;, id=0, age=0&#125;</span>    &#125;</code></pre><p>若没有无参构造器，则如何操作？ ===&gt;  <strong>只需明确调用类中的构造器，并把参数传递过去</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/17.png" alt="image-20220120074626851"></p><pre><code class="hljs java"><span class="hljs-comment">//带有参数的构造器</span>      Constructor c2 = c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);      User user2 = (User)c2.newInstance(<span class="hljs-string">&quot;yiheng&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">20</span>);      System.out.println(user2); <span class="hljs-comment">//打印： User&#123;name=&#x27;yiheng&#x27;, id=1, age=20&#125;</span></code></pre><p><strong>反射操作方法</strong></p><pre><code class="hljs java">User user3 = (User)c1.newInstance();Method declaredMethod = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<span class="hljs-comment">//invoke激活==&gt; ( 对象 , &quot;对象的值&quot;)</span>declaredMethod.invoke(user3,<span class="hljs-string">&quot;恒&quot;</span>);System.out.println(user3.getName());  <span class="hljs-comment">// 打印 ： 恒</span></code></pre><p><strong>反射操作属性</strong></p><pre><code class="hljs java">User user4 = (User)c1.newInstance();Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);name.setAccessible(<span class="hljs-keyword">true</span>);name.set(user4,<span class="hljs-string">&quot;heng&quot;</span>);System.out.println(user4.getName());  <span class="hljs-comment">//加上之后，打印：heng</span><span class="hljs-comment">//报错，因为属性私有 不可以自己访问，只需关掉程序的安全检测 ==&gt; name.setAccessible(true);</span></code></pre><p><strong>setAccessible:</strong></p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/18.png" alt="image-20220120083625885"></p><h2 id="2-5反射操作泛型"><a href="#2-5反射操作泛型" class="headerlink" title="2.5反射操作泛型"></a>2.5反射操作泛型</h2><p>(了解)</p><p><img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/19.png" alt="image-20220120085157551"></p><h2 id="2-6反射操作注解"><a href="#2-6反射操作注解" class="headerlink" title="2.6反射操作注解"></a>2.6反射操作注解</h2><p> <img src="/2022/01/18/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/20.png" alt="image-20220120090418721"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.day05.test03;<span class="hljs-keyword">import</span> java.lang.annotation.*;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-comment">//反射操作注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;        Class c1 = Class.forName(<span class="hljs-string">&quot;test.day05.test03.Student&quot;</span>);        <span class="hljs-comment">//反射获得注解</span>        Annotation[] annotations = c1.getAnnotations();        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;            System.out.println(annotation);        &#125;        <span class="hljs-comment">//获得注解value的值</span>        TableHeng annotation = (TableHeng) c1.getAnnotation(TableHeng.class);        String value = annotation.value();        System.out.println(value);        <span class="hljs-comment">//获得类指定的注解</span>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);        fieldHeng annotation1 = name.getAnnotation(fieldHeng.class);        System.out.println(annotation1.columnName());        System.out.println(annotation1.type());        System.out.println(annotation1.length());    &#125;&#125;<span class="hljs-meta">@TableHeng(&quot;db_student&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_name&quot;,type = &quot;int&quot;,length = 10)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span>    <span class="hljs-keyword">int</span> age;    <span class="hljs-meta">@fieldHeng(columnName = &quot;db_id&quot;,type = &quot;varchar&quot;,length = 3)</span>    <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&quot;, id=&quot;</span> + id +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;<span class="hljs-comment">//类名的注解</span><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> TableHeng &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//属性的注解</span><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> fieldHeng &#123;    <span class="hljs-function">String <span class="hljs-title">columnName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">打印：</span><span class="hljs-comment">@test.day05.test03.TableHeng(value=db_student)</span><span class="hljs-comment">db_student</span><span class="hljs-comment">db_name</span><span class="hljs-comment">int</span><span class="hljs-comment">10</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>注解和反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/2022/01/15/css/"/>
    <url>/2022/01/15/css/</url>
    
    <content type="html"><![CDATA[<p><strong>HTML(结构) + CSS(表现) + JavaScript(交互)</strong></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ol><li>css是什么</li><li>如何用(快速入门)</li><li><strong>css选择器 （重难点)</strong></li><li>美化网页( 文字，阴影，超链接，列表，渐变…..)</li><li>盒子模型</li><li>浮动</li><li>定位</li><li>网页动画(特效)</li></ol><h2 id="1-1什么是css"><a href="#1-1什么是css" class="headerlink" title="1.1什么是css"></a>1.1什么是css</h2><p>Cascading Style Sheet(层叠级联样式表)</p><p>css ==&gt; 表现(用于美化网页)</p><p>包括：字体，颜色，边距，高度，宽度，背景图片，网页定位，网页浮动…..</p><p><img src="/2022/01/15/css/00.png" alt="image-20220121194547522"></p><p><strong>CSS预处理器</strong></p><p><img src="/2022/01/15/css/000.png" alt="image-20220121194650495"></p><h2 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h2><p>CSS1.0  ==&gt; 只能美化一些基础的</p><p>CSS2.0 ==&gt; div(块) + css，提出html与css结构分离的思想，网页变得简单</p><p>CSS2.1===&gt;  浮动，定位</p><p>CSS3.0 ===&gt; 圆角，阴影，动画…..（需要浏览器兼容性</p><h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h2><p>书写标准格式==&gt;</p><p><img src="/2022/01/15/css/01.png" alt="image-20220115095910933"></p><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">--</span>    规范:&lt;<span class="hljs-selector-tag">style</span>&gt;编写<span class="hljs-selector-tag">css</span>代码，每一个声明，最好用分号结尾    语法：        选择器&#123;            声明1;            声明2;            声明3;        &#125;此时<span class="hljs-selector-tag">html</span>和<span class="hljs-selector-tag">css</span>未分离，在一个文件写的 <span class="hljs-selector-tag">css</span>在&lt;<span class="hljs-selector-tag">head</span>&gt;中，<span class="hljs-selector-tag">html</span>在<span class="hljs-selector-tag">body</span>中<span class="hljs-selector-tag">--</span>&gt;    &lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-tag">h1</span>&#123;            <span class="hljs-attribute">color</span>: aqua;        &#125;    &lt;/style&gt;</code></pre><p>建议分离着写，使用独立于html的css结构，即使用下面规范！</p><p><img src="/2022/01/15/css/02.png" alt="image-20220115101410535"></p><p><strong>优势:</strong></p><ol><li>内容和表现分离</li><li>网页结构统一，可以实现复用</li><li>样式很丰富 </li><li>利于SEO(<em>Search engine optimization</em>)，容易被搜索引擎收录</li></ol><h2 id="1-4三种导入方式"><a href="#1-4三种导入方式" class="headerlink" title="1.4三种导入方式"></a>1.4三种导入方式</h2><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;&lt;html lang=&quot;en&quot;&gt;&lt;<span class="hljs-selector-tag">head</span>&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;!<span class="hljs-selector-tag">--</span>    2内部样式<span class="hljs-selector-tag">--</span>&gt;    &lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-tag">h1</span>&#123;            <span class="hljs-attribute">color</span>: yellow;        &#125;    &lt;/style&gt;&lt;!<span class="hljs-selector-tag">--</span>   3，外部样式<span class="hljs-selector-tag">--</span>&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;<span class="hljs-selector-tag">body</span>&gt;&lt;!<span class="hljs-selector-tag">--</span> 1.行内样式<span class="hljs-selector-tag">--</span>&gt;    &lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时显示 行内样式的颜色 若去掉行内样式，则显示 外部样式 对应的颜色 ，因为离h1最近  </p><p><strong>就近原则</strong> 即从上到下，下面覆盖重复上面的样式</p><p>外部样式的两种方式：</p><ul><li><p>链接式(目前用这个最多)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/style.css&quot;</span>&gt;</span></code></pre></li><li><p>导入式(css2.1中使用)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;css/style.css&quot;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></li></ul><h1 id="2-选择器-重要"><a href="#2-选择器-重要" class="headerlink" title="2.选择器(重要)"></a>2.选择器(重要)</h1><blockquote><p>选择页面上的某一个或某一类元素</p></blockquote><h2 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a><strong>2.1 基本选择器</strong></h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>会选择到这个页面上的所有标签</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><pre><code>格式:.class的名称&#123;   &#125;好处：可以多个标签归类，是同一个class，可复用</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.name</span>&#123;</span>        color: red;    &#125;<span class="css">    <span class="hljs-selector-class">.id</span>&#123;</span>        color: yellow;    &#125;<span class="css">    <span class="hljs-selector-class">.phone</span>&#123;</span>        color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;phone&quot;</span>&gt;</span>phone<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><pre><code>格式： #id名称&#123;   &#125;必须全局唯一，不可以复用 不遵循就近原则  生效原则：id选择器 &gt; 类选择器 &gt; 标签选择器     </code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-id">#test</span>&#123;</span>        color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><h2 id="2-2高级选择器"><a href="#2-2高级选择器" class="headerlink" title="2.2高级选择器"></a>2.2高级选择器</h2><h3 id="1层次选择器"><a href="#1层次选择器" class="headerlink" title="1层次选择器"></a>1层次选择器</h3><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>（body  里面所有p都起作用)</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">color</span>: blue;&#125;</code></pre><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p>只会body里面一代起作用</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&gt;<span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">color</span>: blue;&#125;</code></pre><h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><p>(同辈) ===&gt; 向下的相邻</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.test</span> + <span class="hljs-selector-tag">p</span>&#123;</span>    color: blueviolet;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>此时p3会变颜色</p><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>当前选择元素的所有向下的兄弟元素 生效</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.test</span>~<span class="hljs-selector-tag">p</span>&#123;</span>        color: red;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>此时p2 p3均为变颜色</p><h3 id="2-结构伪类选择器"><a href="#2-结构伪类选择器" class="headerlink" title="2.结构伪类选择器"></a>2.结构伪类选择器</h3><p>带冒号这种==&gt; 即伪类 (代表条件判断 )</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>l3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-comment">/*定位ul中li的第一个与最后一个*/</span></span><span class="css">    <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first-child</span>&#123;</span>        color: red;    &#125;<span class="css">    <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;</span>        color: blueviolet;    &#125;    /*首先找到当前p元素的父级元素，然后选中父级元素的第一个，并且类型要是当前元素才生效 （按顺序进行选择    此时p1会变颜色    */<span class="css">    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child(1)</span> &#123;</span>        color: blue;    &#125;<span class="css">    <span class="hljs-comment">/*选中父元素下的p元素的第二个  此时p2变颜色 (按类型进行选择)  */</span> </span><span class="css">    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span> &#123;</span>        background-color: blue;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h3 id="3-属性选择器-常用"><a href="#3-属性选择器-常用" class="headerlink" title="3.属性选择器(常用)"></a>3.属性选择器(常用)</h3><p> 格式： 标签[id属性] {  }</p><pre><code class="hljs css"><span class="hljs-comment">/*选中 a标签 中id属性为 first的元素*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[id=first]</span> &#123;  &#125;<span class="hljs-comment">/*  选择a标签中class含有 links的元素 </span><span class="hljs-comment">=代表完全匹配 *=只需要含有即可 ^=以什么开头 $= 以什么结尾 (正则表达式)</span><span class="hljs-comment">*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[class *= <span class="hljs-string">&quot;links&quot;</span>]</span> &#123; &#125;</code></pre><h1 id="3-美化网页元素"><a href="#3-美化网页元素" class="headerlink" title="3 美化网页元素"></a>3 美化网页元素</h1><p><strong>为何需要美化</strong></p><pre><code>-     更有效传递网页信息-     页面好看，才能吸引用户-     凸显页面主题-     提高用户体验</code></pre><p>span==&gt; 想重点突出的字，约定用 span套起来，然后表示</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-id">#java</span>&#123;</span>        color: red;        font-size: 50px;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>欢迎学习 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;java&quot;</span>&gt;</span>JAVA<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p><strong>字体</strong></p><pre><code class="hljs css">font-family ==&gt; 字体样式font-size ==&gt;字体大小font-weight ==&gt; 粗细color ==&gt; 颜色一般统一写 font: 字体粗细 行/高 字体格式  或 font:字体风格 字体粗细 大小 字体格式如 font: bold 20px/50px Arial;  或 font: oblique bolder 50px Arial;</code></pre><p><strong>文本样式</strong></p><ol><li><p>颜色</p><p>color (rgb)</p></li><li><p><strong>文本对齐方式</strong></p><p><code>text-align</code> (排版方式: center，right，left 是水平的居中) </p></li><li><p><strong>首行缩进</strong></p><p><code>text-indent:2em;</code></p></li><li><p>行高</p><p><code>height:300px;</code></p><p><code>line-height:300px;</code>  &lt;== 行高</p><p>当 行高 与块高度相同时，则可实现上下居中</p></li><li><p>装饰</p><ul><li>下划线 <code>text-decoration:underline;</code></li><li>删除线：<code>text-decoration:line-throuth;</code></li></ul></li></ol><pre><code class="hljs css"><span class="hljs-comment">/*鼠标悬浮时的状态*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;    <span class="hljs-attribute">text-decoration</span>:none;    <span class="hljs-attribute">color</span>:<span class="hljs-number">#000</span>; &#125;</code></pre><p><strong>背景</strong></p><pre><code class="hljs css"><span class="hljs-comment">/* 颜色 图片 图片位置(在页面中) 平铺方 */</span>background: red url(&quot;../images/d.gif&quot;) 270px 10px no-repeat;</code></pre><p><strong><a href="https://www.grabient.com/">渐变</a></strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#4158D0</span>;<span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">linear-gradient</span>(83<span class="hljs-selector-tag">deg</span>, <span class="hljs-selector-id">#4158D0</span> 0%, <span class="hljs-selector-id">#C850C0</span> 46%, <span class="hljs-selector-id">#FFCC70</span> 100%);</code></pre><p><strong>列表</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">list-style</span>: </code></pre><h1 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h1><p><img src="/2022/01/15/css/03.png" alt="image-20220119182320273"></p><ul><li>margin : 外边距</li><li>border ： 内边距</li><li>padding ： 边框</li></ul><p><strong>边框</strong></p><pre><code class="hljs css"><span class="hljs-comment">/*常见的初始化操作*/</span><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">body</span>&#123;            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;            <span class="hljs-attribute">text-decoration</span>: none;        &#125;     <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">red</span>;     <span class="hljs-selector-tag">margin</span>: 0 <span class="hljs-selector-tag">auto</span>; <span class="hljs-comment">/*  margin外边距妙用==&gt; 居中 (上下0，左右auto)     条件：块元素，有固定宽度</span><span class="hljs-comment">若margin: 0 1px 2px 3px ==&gt; 逆时针(上 右 下 左)</span><span class="hljs-comment">*/</span><span class="hljs-comment">/* 下面方式也可实现居中(更有效)*/</span>&lt;div style = &quot;width: 500px;display: block; test-align:center&quot;&gt;    &lt;img src = &quot;images/tx.jpg&quot; alt= &quot;&quot; &gt;&lt;/div&gt;</code></pre><blockquote><p> 给出 50 * 50 ==&gt; 盒子模型尺寸计算指：margin + border + padding + 内容元素 = 50 * 50</p></blockquote><p><strong>圆角边框</strong></p><p>4个角</p><pre><code class="hljs css"><span class="hljs-selector-tag">border-radius</span>: 40<span class="hljs-selector-tag">px</span>;  <span class="hljs-comment">/*四个角均变*/</span><span class="hljs-selector-tag">border-radius</span><span class="hljs-selector-pseudo">:50px</span> 40<span class="hljs-selector-tag">px</span> 30<span class="hljs-selector-tag">px</span> 20<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/*(顺时针) 左上 右上 右下 左下*/</span><span class="hljs-selector-tag">border-radius</span>: 40<span class="hljs-selector-tag">px</span> 10<span class="hljs-selector-tag">px</span>;<span class="hljs-comment">/* 左上  右下 */</span></code></pre><p><strong>盒子阴影</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">width</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">height</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">border</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">red</span>;<span class="hljs-selector-tag">border-radius</span>: 100<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">box-shadow</span>: 10<span class="hljs-selector-tag">px</span> 10<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span> <span class="hljs-selector-id">#888888</span>;</code></pre><p><img src="/2022/01/15/css/04.png" alt="image-20220121115240716"></p><h1 id="5-浮动"><a href="#5-浮动" class="headerlink" title="5.浮动"></a>5.浮动</h1><p><strong>标准文档流</strong></p><p><img src="/2022/01/15/css/05.png" alt="image-20220121152153377"></p><p>块级元素：独占一行</p><pre><code class="hljs apache"><span class="hljs-attribute">h1</span>~h<span class="hljs-number">6</span>, p标签 div标签 列表</code></pre><p>行内元素：不独占一行</p><pre><code class="hljs stylus"><span class="hljs-selector-tag">span</span>  a标签 <span class="hljs-selector-tag">img</span> <span class="hljs-selector-tag">strong</span>....</code></pre><p><strong>display</strong> 也是实现行内元素排列的方式，但多用float  ===&gt; <strong>方向不可以控制，不会出现父级边框塌陷问题</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">block</span> 块元素<span class="hljs-selector-tag">inline</span> 行内元素<span class="hljs-selector-tag">inline-block</span> 是块元素，但是可以内联，在一行none ==&gt; 消失 </code></pre><p><strong>float浮动</strong>()  ===&gt;  <strong>浮动的话可能会脱离标准文档流，所以要解决父级边框塌陷</strong></p><p>right,left <strong>左右浮动</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:both</span>; <span class="hljs-comment">/*两侧均不许有浮动元素，即按照正常元素向下排布*/</span><span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:right</span>;<span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:none</span>; <span class="hljs-comment">/*不清理*/</span></code></pre><p>浮动会出现<strong>父级边框塌陷问题</strong></p><p><strong>如何解决？</strong></p><p>1.将父级元素(div)边框高度变大</p><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;    <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>;&#125;</code></pre><p>2.再上面div后加一个空的div，然后清除它的浮动 <strong>（尽量避免空div，不用此方法）</strong></p><pre><code class="hljs css">&lt;div class = &quot;clear&quot;&gt;&lt;/div&gt;<span class="hljs-selector-class">.clear</span>&#123;    <span class="hljs-attribute">clear</span>:both;    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;&#125;</code></pre><p>3.利用overflow</p><pre><code class="hljs css"><span class="hljs-comment">/*设置父级元素overflow  根据里面内容而进行变化*/</span><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;    <span class="hljs-attribute">overflow</span>:hidden; <span class="hljs-comment">/*网页若下拉的场景不能使用*/</span>&#125;</code></pre><p>4.在父类中添加一个伪类**(推荐使用)**</p><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;&#125;<span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">conten</span>:<span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">clear</span>:both;&#125;</code></pre><h1 id="6-定位"><a href="#6-定位" class="headerlink" title="6.定位"></a>6.定位</h1><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>相对于原来的位置进行指定偏移，位置仍然在标准文档流中，原来位置被保留</p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span><span class="hljs-selector-pseudo">:relative</span>;  <span class="hljs-comment">/* 然后设置 距离 上下左右多少*/</span><span class="hljs-selector-tag">top</span>:<span class="hljs-selector-tag">bottom</span>:<span class="hljs-selector-tag">left</span>:<span class="hljs-selector-tag">right</span>:</code></pre><p><img src="/2022/01/15/css/06.png" alt="image-20220121160558405"></p><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;        <span class="hljs-selector-id">#box</span>&#123;            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;        &#125;        <span class="hljs-selector-tag">a</span>&#123;            <span class="hljs-attribute">text-decoration</span>: none;            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">background-color</span>: pink;            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">text-align</span>: center;            <span class="hljs-attribute">color</span>: white;            <span class="hljs-attribute">display</span>: block;        &#125;        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;            <span class="hljs-attribute">background-color</span>: cornflowerblue;        &#125;        <span class="hljs-selector-class">.a2</span>,<span class="hljs-selector-class">.a4</span>&#123;            <span class="hljs-attribute">position</span>: relative;            <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;            <span class="hljs-attribute">top</span>: -<span class="hljs-number">100px</span>;        &#125;        <span class="hljs-selector-class">.a5</span>&#123;            <span class="hljs-attribute">position</span>: relative;            <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">bottom</span>: <span class="hljs-number">300px</span>;        &#125;&lt;/style&gt;&lt;div id = &quot;box&quot;&gt;    &lt;a href=&quot;#&quot; class=&quot;a1&quot;&gt;链接1&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a2&quot;&gt;链接2&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a3&quot;&gt;链接3&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a4&quot;&gt;链接4&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;a5&quot;&gt;链接5&lt;/a&gt;&lt;/div&gt;</code></pre><h2 id="绝对定位和固定定位"><a href="#绝对定位和固定定位" class="headerlink" title="绝对定位和固定定位"></a>绝对定位和固定定位</h2><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">fixed</span>;</code></pre><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;    <span class="hljs-selector-tag">body</span>&#123;        <span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>; <span class="hljs-comment">/*会出现滚动条  当滚动时，固定定位一直不变，而绝对定位只是对于浏览器右边不变，上下会变*/</span>    &#125;    <span class="hljs-comment">/*绝对定位，相对于浏览器*/</span>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(1)</span> &#123;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: red;    &#125;    <span class="hljs-comment">/*固定定位*/</span>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span> &#123;        <span class="hljs-attribute">position</span>: fixed;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;        <span class="hljs-attribute">background</span>: blue;    &#125;&lt;/style&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">z-index</span>: 999; <span class="hljs-comment">/*0,1,2,3,....越大层级越高  作用类比于ps中的 图层*/</span><span class="hljs-selector-tag">opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/* 可以设置背景透明度 */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27.移除元素</title>
    <link href="/2022/01/12/leetcode07/"/>
    <url>/2022/01/12/leetcode07/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs java">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(<span class="hljs-number">1</span>) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:<span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><span class="hljs-keyword">int</span> len = removeElement(nums, val);<span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    print(nums[i]);&#125; 示例 <span class="hljs-number">1</span>：输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], val = <span class="hljs-number">3</span>输出：<span class="hljs-number">2</span>, nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]解释：函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="hljs-number">2</span> ，而 nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 或 nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]，也会被视作正确答案。示例 <span class="hljs-number">2</span>：输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>], val = <span class="hljs-number">2</span>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：<span class="hljs-number">0</span> &lt;= nums.length &lt;= <span class="hljs-number">100</span><span class="hljs-number">0</span> &lt;= nums[i] &lt;= <span class="hljs-number">50</span><span class="hljs-number">0</span> &lt;= val &lt;= <span class="hljs-number">100</span></code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力算法===&gt; 找到相同的进行覆盖，然后长度缩短</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length ; i++) &#123;            <span class="hljs-comment">//找到相同元素</span>            <span class="hljs-keyword">if</span> ( nums[i] == val ) &#123;                <span class="hljs-comment">//进行移动数组</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;                    nums[j - <span class="hljs-number">1</span>] = nums[j];                &#125;                length --;                i --;  <span class="hljs-comment">//因为数组下标i之后元素都前移了，故i也要前移一位</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> length;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.8 MB, 在所有 Java 提交中击败了77.63%的用户</p><p>通过测试用例：113 / 113</p></blockquote><p><strong>时间复杂度为 0(n^2)</strong></p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>双指针 （重点掌握！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;            <span class="hljs-keyword">if</span>( val != nums[fast] ) &#123;                nums[slow ++] = nums[fast];            &#125;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.2 MB, 在所有 Java 提交中击败了5.72%的用户</p><p>通过测试用例：113 / 113</p></blockquote><p><strong>时间复杂度为 O(n)</strong></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>977.有序数组的平方</title>
    <link href="/2022/01/11/leetcode06/"/>
    <url>/2022/01/11/leetcode06/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1：输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]示例 2：输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示：1 &lt;= nums.length &lt;= 10^4-10^4 &lt;= nums[i] &lt;= 10^4nums 已按 非递减顺序 排序 进阶：请你设计时间复杂度为 O(n) 的算法解决本问题</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>第一思路===&gt; 对每个元素进行平方，然后排序即可 （暴力排序！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length; i++) &#123;            nums[i] *= nums[i];        &#125;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：2 ms, 在所有 Java 提交中击败了39.61%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了96.37%的用户</p><p>通过测试用例：137 / 137</p></blockquote><p>java中Arrays.sort使用了两种排序方法，quick sort 和优化的 merge sort</p><p>故Java内置排序时间复杂度为o(nlogn)  ===&gt;  整体即是  o(nlogn  + n) </p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p><strong>双指针</strong></p><blockquote><p>数组是有序的，负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>考虑双指针法，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;         <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length; - <span class="hljs-number">1</span>,n = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]; <span class="hljs-comment">//大小不对！不然会越界，应该是new int[nums.length];</span>        <span class="hljs-keyword">while</span> (i &lt;= j ) &#123;            <span class="hljs-keyword">if</span> ( nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;                result[n--] = nums[i] * nums[i];                i++;             &#125;            <span class="hljs-keyword">else</span> &#123;                result[n--] = nums[j] * nums[j];                j --;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;       &#125;&#125;</code></pre><p>更改：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;         <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length]; <span class="hljs-comment">//要保证长度够</span>        <span class="hljs-keyword">while</span> (i &lt;= j ) &#123;            <span class="hljs-keyword">if</span> ( nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;                result[n--] = nums[i] * nums[i];                i++;             &#125;            <span class="hljs-keyword">else</span> &#123;                result[n--] = nums[j] * nums[j];                j--;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;       &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.3 MB, 在所有 Java 提交中击败了39.21%的用户</p><p>通过测试用例：137 / 137</p></blockquote><p>此时复杂度为 0(n) 比暴力更快！</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35.搜索插入位置</title>
    <link href="/2022/01/11/leetcode05/"/>
    <url>/2022/01/11/leetcode05/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs java">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。 示例 <span class="hljs-number">1</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span>输出: <span class="hljs-number">2</span>示例 <span class="hljs-number">2</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span>输出: <span class="hljs-number">1</span>示例 <span class="hljs-number">3</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span>输出: <span class="hljs-number">4</span>示例 <span class="hljs-number">4</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">0</span>输出: <span class="hljs-number">0</span>示例 <span class="hljs-number">5</span>:输入: nums = [<span class="hljs-number">1</span>], target = <span class="hljs-number">0</span>输出: <span class="hljs-number">0</span> 提示:<span class="hljs-number">1</span> &lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span>-<span class="hljs-number">104</span> &lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span>nums 为无重复元素的升序排列数组-<span class="hljs-number">104</span> &lt;= target &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span></code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果目标值在===&gt;  二分查找搞定，复杂度满足</p><p>如果不在，怎么找到对应位置？ ===&gt; 最终i &gt; j ,故直接返回 j + 1即是所找的位置 （可通过示例分析出来！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> ( i &lt;= j) &#123;            <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>   <span class="hljs-comment">//取mid更安全！</span>            <span class="hljs-keyword">if</span>( target &lt; nums[mid]) &#123;                j = mid - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[mid]) &#123;                i = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38 MB, 在所有 Java 提交中击败了61.66%的用户</p><p>通过测试用例：64 / 64</p></blockquote><p>抛开别的，另一种思路</p><p><strong>直接遍历一趟进行寻找，如果找到值大于 target 则返回相对应的下标，否则返回数组长度</strong> （更简便！</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> ( target &lt; nums[i] )&#123;                <span class="hljs-keyword">return</span> i;            &#125;              &#125;        <span class="hljs-keyword">return</span> nums.length;    &#125;&#125;</code></pre><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了92.45%的用户</p><p>通过测试用例：64 / 64</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>278.第一个错误版本</title>
    <link href="/2022/01/11/leetcode04/"/>
    <url>/2022/01/11/leetcode04/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。示例 1：输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。示例 2：输入：n = 1, bad = 1输出：1提示：1 &lt;= bad &lt;= n &lt;= 2^31 - 1</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分查找！</p><pre><code class="hljs java"><span class="hljs-comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><span class="hljs-comment">      boolean isBadVersion(int version); */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VersionControl</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,j = n;        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;            <span class="hljs-keyword">int</span> mid = (i + j ) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( isBadVersion(mid) ) &#123;                j = mid - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                i = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre><blockquote><p> 以上代码，超出时间限制！</p></blockquote><p>原因为何 ？ ===&gt; 只有while 循环中<strong>mid 取值不对</strong>，导致溢出</p><p>题目中还一条件：即bad 和 n范围 </p><p>因为是int 如果取值过大，比如刚好取值2^31 -1 即int的最大值，其实mid进行运算将溢出</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> mid = left + (right - left ) / <span class="hljs-number">2</span> <span class="hljs-comment">//取中间值的另一种方法,不会溢出===&gt; 要get√ </span></code></pre><p>改了之后进行提交，结果如图</p><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：11 ms, 在所有 Java 提交中击败了99.95%的用户</p><p>内存消耗：34.8 MB, 在所有 Java 提交中击败了94.21%的用户</p><p>通过测试用例：22 / 22</p></blockquote><p>总：</p><p>二分查找取中值的方法：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">//可能会溢出</span><span class="hljs-keyword">int</span> mid = (left + right - left) / <span class="hljs-number">2</span>  <span class="hljs-comment">// 不会溢出，重点掌握</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子数组和</title>
    <link href="/2022/01/09/leetcode03/"/>
    <url>/2022/01/09/leetcode03/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code class="hljs shell">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1:输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4示例 2:输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1//思路不难</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>直接暴力寻找</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>( nums[i] == target) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>二分法</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;       Arrays.sort(nums); <span class="hljs-comment">//不用写，题目说有序了</span>       <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (i &lt;= j) &#123;           <span class="hljs-keyword">int</span> mid = (i + j) / <span class="hljs-number">2</span>;           <span class="hljs-keyword">if</span>( target &lt; nums[mid] ) &#123;               j = mid - <span class="hljs-number">1</span>;           &#125;           <span class="hljs-keyword">if</span>( target &gt; nums[mid]) &#123;               i = mid + <span class="hljs-number">1</span>;           &#125;           <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;               <span class="hljs-keyword">return</span> mid;           &#125;       &#125;       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>217.存在重复元素</title>
    <link href="/2022/01/09/leetcode02/"/>
    <url>/2022/01/09/leetcode02/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">leetcode 217题 </a>–存在重复元素</p><pre><code class="hljs shell">给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1:输入: [1,2,3,1]输出: true示例 2:输入: [1,2,3,4]输出: false示例 3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最容易想到的，暴力算法</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numsSize;i++) &#123;        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; numsSize;j++) &#123;            <span class="hljs-keyword">if</span> ( *(nums + i) == *(nums + j) ) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//时间复杂度太高！无法通过测试</span></code></pre><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>排序 + 比较</p><blockquote><p>先进行排序，然后再进行循环一趟，看是否相邻的元素相等，若等则返回true，否则返回false</p><p>而排序可利用java中的内置方法 或者  C语言中的qsort 或者自己手写快排！</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums); <span class="hljs-comment">//java内置排序方法</span>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;i++) &#123;            <span class="hljs-keyword">if</span>( nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *b)</span> </span>&#123;    <span class="hljs-keyword">return</span> ( *(<span class="hljs-keyword">int</span>*)a - *(<span class="hljs-keyword">int</span>*)b );&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;    qsort(nums,numsSize,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>),compare); <span class="hljs-comment">//qsort</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span>;i++) &#123;        <span class="hljs-keyword">if</span>( *(nums+i) == *(nums+i+<span class="hljs-number">1</span>) ) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><blockquote><h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><p><em>语法:</em> </p><p>  <strong>#include  &lt;stdlib.h&gt;</strong> <strong>void qsort( void *buf, size_t num, size_t  size, int (*compare)(const void *, const void *)  );</strong></p><p><strong>功能：</strong>  对<em>buf</em>  指向的数据(包含<em>num</em>  项,每项的大小为<em>size</em>)进行快速排序。如果函数<em>compare</em>  的第一个参数小于第二个参数，返回负值；如果等于返回零值；如果大于返回正值。函数对<em>buf</em>  指向的数据按升序排序。 </p></blockquote><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>哈希表</p><blockquote><p>将数组中的元素，插入到哈希表中，如果插入时发现该元素已经存在哈希表中，则说明存在重复元素</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;         Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;            <span class="hljs-keyword">if</span> ( !set.add(x) ) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><blockquote><p>java中集合Set用法</p><p>Set`用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象(初级)</title>
    <link href="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/"/>
    <url>/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象-初级"><a href="#面向对象-初级" class="headerlink" title="面向对象(初级)"></a>面向对象(初级)</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/01.png" alt="image-20211231104708275"></p><blockquote><p>(1)类是抽象的,概念的,代表一类食物,比如人类,猫类.他是数据类型</p><p>(2)对象是具体的,实际的,代表一个具体事物,即是实例</p><p>(3)类是对象的模板,对象是类的一个个体,对应一个实例</p></blockquote><p><strong>java内存结构</strong></p><blockquote><p>栈：存放基本数据类型（局部变量</p><p>堆：存放对象（Cat cat，数组）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><p><strong>方法的调用过程</strong></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/02.png" alt="image-20211231105242496"></p><p><strong>可变参数</strong></p><blockquote><p>java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现</p><p>基本语法：</p><p>访问修饰符  返回类型 方法名(数据类型… 形参名) {   }</p></blockquote><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/03.png" alt="image-20211231105638546"></p><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h2><p>又称为构造器，是类的一种特殊方法，完成对新对象的初始化</p><blockquote><p>特点：</p><p>​    1.方法名和类名相同</p><p>​    2.没有返回值</p><p>​    3.在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</p><p>基本语法：</p><p>[修饰符] 方法名(形参列表) { 方法体; }</p></blockquote><p>1.构造器的修饰符可以默认， 也可以是 public protected private</p><ol start="2"><li>构造器没有返回值<ol start="3"><li>方法名 和类名字必须一样<ol start="4"><li>参数列表 和 成员方法一样的规则<ol start="5"><li>构造器的调用, 由系统完成  </li></ol></li></ol></li></ol></li></ol><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/04.png" alt="image-20211231120033568"></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/05.png" alt="image-20211231120052604"></p><p><strong>this关键字</strong></p><blockquote><p>java虚拟机会给每个对象分配this，代表当前对象</p><p>简单来说：哪个对象调用，this就代表哪个对象</p></blockquote><p><strong>使用细节：</strong></p><p>1、this 关键字可以用来访问本类的属性、 方法、 构造器  </p><p>2、this 用于区分当前类的属性和局部变量</p><p>3、访问成员方法的语法： this.方法名(参数列表); </p><p>4、访问构造器语法： this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一<br>条语句)  </p><p>5、this 不能在类定义的外部使用， 只能在类定义的方法中使用。  </p><h3 id="2-1-IDEA简单使用"><a href="#2-1-IDEA简单使用" class="headerlink" title="2.1.IDEA简单使用"></a>2.1.IDEA简单使用</h3><p>常用快捷键设置</p><p>file–&gt;setting–&gt;keymap进行设置</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/06.png" alt="image-20211231143309908"></p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>) 删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d<span class="hljs-number">2</span>) 复制当前行, 自己配置 ctrl + alt + 向下光标<span class="hljs-number">3</span>) 补全代码 alt + /<span class="hljs-number">4</span>) 添加注释和取消注释 ctrl + / 【第一次是添加注释， 第二次是取消注释】<span class="hljs-number">5</span>) 导入该行需要的类 先配置 <span class="hljs-built_in">auto</span> <span class="hljs-keyword">import</span> , 然后使用 alt+enter 即可<span class="hljs-number">6</span>) 快速格式化代码 ctrl + alt + L<span class="hljs-number">7</span>) 快速运行程序 自己定义 alt + R<span class="hljs-number">8</span>) 生成构造器等 alt + insert [提高开发效率]<span class="hljs-number">9</span>) 查看一个类的层级关系 ctrl + H [学习继承后， 非常有用]<span class="hljs-number">10</span>) 将光标放在一个方法上， 输入 ctrl + B , 可以定位到方法 [学继承后， 非常有用]<span class="hljs-number">11</span>) 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] </code></pre><h3 id="2-2包-package"><a href="#2-2包-package" class="headerlink" title="2.2包(package"></a>2.2包(package</h3><blockquote><p>作用：1.区分相同名字的类；2当类很多时，可以很好的管理类(看java API文档) 3.控制访问范围</p><p>包本质：就是创建不同的文件夹/目录保存类文件</p><p>命名规则：只能包含数字，字母，下划线，小圆点，但不可以数字开头，不能是关键字</p></blockquote><p>规范：<strong>com.公司名.项目名.业务模块名</strong></p><p>例如：com.sina.crm.user 用户模块</p><p>如何引入包 ===&gt; import 包名;</p><h3 id="2-3-访问修饰符"><a href="#2-3-访问修饰符" class="headerlink" title="2.3 访问修饰符"></a>2.3 访问修饰符</h3><p>用于控制方法和属性(成员变量)的访问权限(范围)</p><ol><li>公开级别 <strong>public</strong> ，对外公开</li><li>受保护级别：<strong>protected</strong>，对子类和同一个包中的类公开</li><li>默认，没有修饰符，对同一个包的类公开</li><li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li></ol><p><strong>访问范围</strong></p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/07.png" alt="image-20220109101437681"></p><h3 id="2-4-方法的重载"><a href="#2-4-方法的重载" class="headerlink" title="2.4 方法的重载"></a>2.4 方法的重载</h3><blockquote><p>一个类中可以包含多个同名的方法，但只是需要的形式参数不同</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 原本的方法</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">//ok 形参不同</span>        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-comment">//ok 返回值和形参均不同</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span> </span>&#123;    &#125;    <span class="hljs-comment">// 错误，仅返回值类型不同不能重载</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><h2 id="3-静态变量和静态方法"><a href="#3-静态变量和静态方法" class="headerlink" title="3.静态变量和静态方法"></a>3.静态变量和静态方法</h2><blockquote><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p></blockquote><ul><li>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span>    Student()&#123;        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">//打印：</span>初始化变量a构造类对象</code></pre><h2 id="3-封装-encaplation"><a href="#3-封装-encaplation" class="headerlink" title="3.封装(encaplation)"></a>3.封装(encaplation)</h2><p>封装就是把抽象出的**数据(属性)和对数据的操作(方法)**封装在一起，数据被 保护在内部，程序的其他部分只有通过被授权的操作(方法)，才能对数据进行操作</p><blockquote><p>封装的好处：1.隐藏实现细节 2.可以对数据进行验证，保证安全合理</p><p>封装的实现步骤：</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/08.png"></p></blockquote><h2 id="4-继承-extends"><a href="#4-继承-extends" class="headerlink" title="4.继承(extends)"></a>4.继承(extends)</h2><p>​        继承解决代码复用，当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p><p><img src="/2022/01/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E7%BA%A7/09.png" alt="image-20211231185044322"></p><pre><code class="hljs angelscript">语法：<span class="hljs-keyword">class</span> 子类 <span class="hljs-symbol">extends</span> 父类 &#123;    &#125;<span class="hljs-number">1.</span>子类就会自动拥有父类定义的属性和方法<span class="hljs-number">2.</span>父类又叫 超类，基类<span class="hljs-number">3.</span>子类又叫派生类继承的好处：代码复用性提高了 &amp; 拓展性和维护性提高了继承的细节：<span class="hljs-number">1.</span>子类继承了所有的属性和方法，非私有的属性和方法在子类可以直接访问，但私有属性和方法不能在子类直接访问，要通过父类提供公共的方法来访问<span class="hljs-number">2.</span>子类必须调用父类的构造器，完成父类的初始化<span class="hljs-number">3.</span>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用<span class="hljs-keyword">super</span>去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不通过<span class="hljs-number">4.</span>如果希望指定去调用父类的某个构造器，则显式的调用一下：<span class="hljs-keyword">super</span>(参数列表)<span class="hljs-number">5.</span><span class="hljs-keyword">super</span>在使用时，必须放在构造器第一行(<span class="hljs-keyword">super</span>只能在构造器中使用)<span class="hljs-number">6.</span><span class="hljs-keyword">super</span>()和<span class="hljs-keyword">this</span>() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器<span class="hljs-number">7.</span>java所有类都是Object类的子类，Object是所有类的基类<span class="hljs-number">8.</span>父类构造器的调用不限于直接父类，将一直往上追溯到Object类<span class="hljs-number">9.</span>子类最多只能继承一个父类(直接继承)，即java中式单继承机制问：如何让A类继承B类和C类？ ===&gt; 接口！<span class="hljs-number">10.</span>不能滥用继承，子类和父类直接必须满足 <span class="hljs-keyword">is</span> 的逻辑关系</code></pre><h2 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h2><blockquote><p>同一个行为具有多个不同表现形式或形态的能力。即同样的方法，因实现类的不同，执行结果也不同</p></blockquote><h3 id="5-1方法的重写"><a href="#5-1方法的重写" class="headerlink" title="5.1方法的重写"></a>5.1方法的重写</h3><blockquote><p>注意区分和重载的区别==&gt;</p><p>重载：原有方法的逻辑不变，可以支持更多的参数实现</p><p>重写：直接覆盖原有的方法</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//父类中 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;studying....&quot;</span>);&#125;<span class="hljs-comment">//子类中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;给你一些好康的！&quot;</span>);&#125;</code></pre><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);     student.study();   <span class="hljs-comment">//输出子类定义的内容</span>&#125;     </code></pre><blockquote><p>ps:静态方法不可以被重写，是属于类的一部分</p></blockquote><p>如果在重写时，要使用自己的逻辑，也想执行父类的逻辑，怎么办===&gt; super</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>.study();    System.out.println(<span class="hljs-string">&quot;给你看点好康的！&quot;</span>);&#125;</code></pre><p>如果要访问父类的成员变量，也可以使用super关键字来访问。同时，子类也可以具有和父类相同的成员变量，而在方法中访问的默认是： <strong>形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</strong> </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span> </span>&#123;    test = <span class="hljs-number">1</span>;    <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;    <span class="hljs-keyword">super</span>.tesr = <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="5-2类型转换"><a href="#5-2类型转换" class="headerlink" title="5.2类型转换"></a>5.2类型转换</h3><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;yh&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span>student.study();     <span class="hljs-comment">//得到依然是具体实现的结果，而不是当前类型的结果</span></code></pre><p>也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： (向下转型)</p><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;yh&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><span class="hljs-comment">//...</span>SportsStudent student1 = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span>student1.sport();  <span class="hljs-comment">//调用具体实现类的方法</span></code></pre><h3 id="5-3-instanceof关键字"><a href="#5-3-instanceof关键字" class="headerlink" title="5.3 instanceof关键字"></a>5.3 instanceof关键字</h3><p>如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？ ==&gt; instanceof 进行类型判断</p><p>可以明确类的具体实现到底是哪个类！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;        SportsStudent sportsStudent = (SportsStudent) student;        sportsStudent.sport();    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> ArtStudent)&#123;        ArtStudent artStudent = (ArtStudent) student;        artStudent.art();    &#125;&#125;</code></pre><pre><code class="hljs java">System.out.println(student <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">//打印true，因为student对应的类继承Student类</span></code></pre><h3 id="5-4-final关键字"><a href="#5-4-final关键字" class="headerlink" title="5.4 final关键字"></a>5.4 final关键字</h3><p>final关键字可以使一个变量的值不可更改，如果放在类前面呢？</p><pre><code class="hljs java"><span class="hljs-comment">// 此时类被声明为终态，无法再被继承，不允许子类的存在</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123; &#125;<span class="hljs-comment">//同样的 方法 定义为终态，也不能进行重写</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;学习！&quot;</span>);&#125;<span class="hljs-comment">//如何类的成员属性被声明为final，则必须在构造方法中或是在定义时赋初始值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name; <span class="hljs-comment">//引用类型不允许再指向其他对象</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//基本类型值不允许发生改变</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;</code></pre><blockquote><p>故当一个成员属性不发生改变时，应该添加上final关键字</p></blockquote><h3 id="5-5抽象类"><a href="#5-5抽象类" class="headerlink" title="5.5抽象类"></a>5.5抽象类</h3><p>抽象类是在类的基础上继续抽象，<strong>只保留特征，而不保留具体呈现形式</strong>。即方法可以定义好，但不去实现它，而是由子类进行实现！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123; <span class="hljs-comment">//抽象类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>&#125;<span class="hljs-comment">//抽象方法不需要编写具体实现（无方法体）但是 必须 由子类实现（除非子类也是一个抽象类）</span><span class="hljs-comment">//抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</span><span class="hljs-comment">//只能创建带实现的匿名内部类</span>Student s = <span class="hljs-keyword">new</span> Student() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>故抽象类一般作继承使用，使得继承关系之间更加明确</p><pre><code class="hljs java"><span class="hljs-comment">////现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;给你一些好康的！&quot;</span>)&#125;</code></pre><h3 id="5-6-接口-interface"><a href="#5-6-接口-interface" class="headerlink" title="5.6 接口(interface)"></a>5.6 接口(interface)</h3><p>接口进一步继续抽象，<strong>只代表某个确切的功能，也就是只包含方法的定义</strong>，其实已经不是一个类了！</p><p>接口包含了一些类方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//接口只包含public权限的抽象方法(java8之后有默认实现)</span><span class="hljs-comment">//可以通过声明default关键字来给抽象方法一个默认实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//do..</span>    &#125;&#125;<span class="hljs-comment">//接口中的变量，默认为public static final</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>一个类可以实现很多个接口，但是不能理解为多继承！</p><p>（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>,... </span>&#123;    <span class="hljs-meta">@override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;<span class="hljs-comment">//类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！</span><span class="hljs-comment">//实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</span></code></pre><h2 id="6-内部类"><a href="#6-内部类" class="headerlink" title="6.内部类"></a>6.内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment">//类中定义的一个内部类</span>    &#125;&#125;<span class="hljs-comment">//就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例</span></code></pre><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test test = <span class="hljs-keyword">new</span> Test();    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//写法有那么一丝怪异，但是没毛病！</span>&#125;</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//不用再创建外部类对象了！</span>&#125;</code></pre><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>和局部变量一样 ( 很少用 )</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;        &#125;        Inner inner = <span class="hljs-keyword">new</span> Inner();    &#125;&#125;</code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>其实就是在new的时候，直接对接口或者抽象类的实现，是实现Lambda表达式的原理。</p><pre><code class="hljs java">Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-comment">// 实现必要的抽象方法...</span>&#125;;<span class="hljs-comment">//例如：</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//DO something...</span>        &#125;    &#125;;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/2022/01/09/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/09/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p><strong>基本学习思路</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/01.png" alt="image-20211231100822172"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/02.png" alt="image-20211231100928592"></p><p><strong>java组织形式</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/03.png" alt="image-20211231101114237"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/04.png" alt="image-20211231101701040"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/05.png" alt="image-20211231101937844"></p><p><strong>关系运算符</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/06.png" alt="image-20211231102009783"></p><p>逻辑运算符</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/07.png" alt="image-20211231102034884"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/08.png" alt="image-20211231102303168"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/09.png" alt="image-20211231102318799"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/10.png" alt="image-20211231102436229"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>If,switch,</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/11.png" alt="image-20211231102454676"></p><p><strong>双分支</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/12.png" alt="image-20211231102516316"></p><p><strong>多分支</strong></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/13.png" alt="image-20211231102538524"></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="单层"><a href="#单层" class="headerlink" title="单层"></a>单层</h4><p>for(),while(),do..while()</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/14.png" alt="image-20211231103415980"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/15.png" alt="image-20211231103533253"></p><h4 id="多层循环"><a href="#多层循环" class="headerlink" title="多层循环"></a>多层循环</h4><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/17.png" alt="image-20211231103659318"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>动态初始化</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/18.png" alt="image-20211231103749009"></p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/19.png" alt="image-20211231103816308"></p><p>静态初始化</p><p><img src="/2022/01/09/java%E5%9F%BA%E7%A1%80/20.png" alt="image-20211231103826667"></p><p><strong>二维数组</strong></p><pre><code class="hljs markdown">int [<span class="hljs-string"></span>][<span class="hljs-symbol"></span>] y 或者 int[<span class="hljs-string"></span>]y[<span class="hljs-string"></span>] 或者 int y[][];例如:int map[][] = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;;//含有两个元素的一维数组,map[0]含有两个元素,map[1]含有三个元素</code></pre><blockquote><p>二维数组实际上是由多个一维数组组成的， 它的各个一维数组的长度可以相同， 也可以不相同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker命令</title>
    <link href="/2022/01/04/docker%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/04/docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre><code class="hljs shell">docker version #显示docker版本信息docker info #显示docker的系统信息，包括镜像和容器docker 命令 --help # 帮助命令</code></pre><p><a href="https://docs.docker.com/reference/">docker命令文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><pre><code class="hljs shell">docker images # 查看所有本机的主机上的镜像[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY:镜像的仓库源TAG ： 镜像标签IMAGE ID  ： 镜像idCREATED ： 创建时间SIZE ： 镜像大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images)  -q, --quiet           Only show image IDs</code></pre><p><strong>搜索镜像</strong></p><pre><code class="hljs shell">docker search xxxUsage:  docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions:  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print search using a Go template      --limit int       Max number of search results (default 25)      --no-trunc        Don&#x27;t truncate output<span class="hljs-meta">#</span><span class="bash">例如：找出mysql中stars大于3000的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker search mysql --filter=STARS=3000NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql     MySQL is a widely used, open-source relation…   11931     [OK]mariadb   MariaDB Server is a high performing open sou…   4561      [OK]</code></pre><p><strong>下载镜像</strong></p><pre><code class="hljs shell">docker pull xxx[:tag]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output<span class="hljs-meta">#</span><span class="bash">下载mysql</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql72a69066d2fe: Pull complete #分成下载，docker images的核心==&gt;联合文件系统93619dbc5b36: Pull complete99da31dd6142: Pull complete626033c43d70: Pull complete37d5d7efb64e: Pull completeac563158d721: Pull completed2ba16033dad: Pull complete688ba7d5c01a: Pull complete00e060b6d11d: Pull complete1c04857f594f: Pull complete4d7cfa90e6ea: Pull completee0431212d27d: Pull completeDigest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址<span class="hljs-meta">#</span><span class="bash">指定版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Already exists #此时不用再重新下载，已经存在相同部分93619dbc5b36: Already exists99da31dd6142: Already exists626033c43d70: Already exists37d5d7efb64e: Already existsac563158d721: Already existsd2ba16033dad: Already exists0ceb82207cd7: Pull complete37f2405cae96: Pull completee2482e017e53: Pull complete70deed891d42: Pull completeDigest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash">查看</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEmysql         5.7       c20987f18b13   2 weeks ago    448MBmysql         latest    3218b38490ce   2 weeks ago    516MBhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>删除镜像</strong></p><pre><code class="hljs shell">docker rmi xxxRemove one or more imagesOptions:  -f, --force      Force removal of the image      --no-prune   Do not delete untagged parentsdocker rmi -f 容器id #删除指定的容器docker rmi -f $(docker images -aq) #删除所有的容器</code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>有了镜像才能创建容器，必须先下载镜像，以centos为例 </p></blockquote><pre><code class="hljs shell">docker pull centos</code></pre><p><strong>新建容器并启动</strong></p><pre><code class="hljs shell">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new container<span class="hljs-meta">#</span><span class="bash">参数 </span>--name=&quot;Name&quot;  #容器名字-d #后台运行-it #使用交互方式运行-p  #指定容器端口    -p ip 主机端口:容器端口    -p 主机端口:容器端口(常用)    -p 容器端口    容器端口-P  #随机指定端口<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#测试===&gt; 启动并进入容器</span></span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker run -it centos /bin/bash  [root@bea475e51bda /]# <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看容器内的centos</span></span>[root@bea475e51bda /]#  lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#从容器中退到主机</span></span>[root@bea475e51bda /]# exitexit[root@iZ2ze9nu608mhi5at5aufaZ ~]# lsinstall.sh[root@iZ2ze9nu608mhi5at5aufaZ ~]# cd ..[root@iZ2ze9nu608mhi5at5aufaZ /]# lsbin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  patch  proc  root  run  sbin  srv  sys  tmp  usr  var  www</code></pre><p><strong>列出所有的容器</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker ps 命令</span>       #列出当前正在运行的容器    -a #列出当前正在运行的容器+带出历史运行过的容器    -n=？ #显示最近创建的容器    -q    #只显示容器的编号[root@iZ2ze9nu608mhi5at5aufaZ /]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@iZ2ze9nu608mhi5at5aufaZ /]# docker ps -aCONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMESbea475e51bda   centos        &quot;/bin/bash&quot;   4 minutes ago   Exited (127) 2 minutes ago             keen_rhodes537a7100443f   hello-world   &quot;/hello&quot;      5 days ago      Exited (0) 5 days ago                  jovial_thompson</code></pre><p> <strong>退出容器</strong></p><pre><code class="hljs shell">exit  #直接容器停止并退出ctrl + P + Q # 容器不停止退出[root@iZ2ze9nu608mhi5at5aufaZ /]#  docker run  -it centos  /bin/bash[root@25c39385df34 /]# [root@iZ2ze9nu608mhi5at5aufaZ /]#</code></pre><p><strong>删除容器</strong></p><pre><code class="hljs shell">docker rm 容器id     #删除指定的容器，不能删除正在运行的容器，如果要强制 rm -fdocker rm -f $(docker ps -aq) #删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器</code></pre><p><strong>启动和停止容器</strong></p><pre><code class="hljs shell">docker start 容器iddocker restart iddocker stop iddocker kill id</code></pre><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web介绍</title>
    <link href="/2022/01/04/JavaWeb/"/>
    <url>/2022/01/04/JavaWeb/</url>
    
    <content type="html"><![CDATA[<p><strong>javaWeb轮廓</strong></p><ul><li>Tomcat</li><li>http</li><li>maven</li><li><strong>servlet(核心)</strong></li><li>session，cookie</li><li>jsp(了解)</li><li>三层架构mvc</li><li>JSTL、EL表达式</li><li>过滤器，监听器</li><li>文件上传，邮件收发</li><li>…..(更多拓展)</li></ul><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><p>(1)web开发 ：即网页开发</p><ul><li>静态web ：html + css 提供给人看的数据不会发生变化</li><li>动态web：给人看的数据会变化，每个人看的信息各不相同！(几乎所有网站全是！ <ul><li>技术栈：Servlet/JSP ,ASP, PHP</li></ul></li></ul><p>在java中，动态web资源开发的技术成为Java web</p><p>(2)web应用程序</p><p>可以提供浏览器访问的程序，访问的任何页面或资源，均存在于世界上的某个地方的计算机上 ===&gt; URL</p><p>这个统一的web资源会被放在同一个文件夹下，即web应用服务器中===&gt; <strong>tomcat服务器</strong></p><ul><li>一个web文件多部分组成<ul><li>html + css，js</li><li>jsp ，servlet</li><li>java程序</li><li>jar包</li><li>配置文件(properties)</li></ul></li></ul><p>静态web</p><p><img src="/2022/01/04/JavaWeb/01.png" alt="image-20211231201024786"></p><p>缺点：</p><ul><li>无法动态更新，所有用户看的一样 === &gt; javaScript</li><li>无法和数据库交互，数据无法持久化</li></ul><p>动态web</p><p><img src="/2022/01/04/JavaWeb/02.png" alt="image-20211231201034766"></p><p>缺点：</p><ul><li>加入服务器的动态web资源出现了错误，需要重新编写<strong>后台程序</strong>，重新发布==&gt; 停机维护</li></ul><h1 id="2-WEB服务器"><a href="#2-WEB服务器" class="headerlink" title="2.WEB服务器"></a>2.WEB服务器</h1><h2 id="2-1技术"><a href="#2-1技术" class="headerlink" title="2.1技术"></a>2.1技术</h2><p><strong>ASP</strong> (微软–&gt; 最早流行)</p><ul><li>在HTML中嵌入了VB ==&gt; asp + COM</li><li>在asp中，基本一个页面就有几千行代码，页面很混乱，维护高！</li><li>asp里面主要用C#</li><li>IIS服务器 (windows 里面) </li></ul><p><strong>PHP</strong></p><ul><li>开发速度很快，功能很强，跨平台，代码简单</li><li>无法承载访问大的情况</li></ul><p><strong>JSP/servlet</strong>：</p><p>B/S ==&gt; 浏览器和服务器  C/S 客户端和服务器</p><ul><li>sun公司推出的B/S架构</li><li>基于java，可以承载三高（高并发，高可用，高性能</li></ul><h2 id="2-2-web服务器"><a href="#2-2-web服务器" class="headerlink" title="2.2 web服务器"></a>2.2 web服务器</h2><blockquote><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息</p></blockquote><p><strong>IIS</strong></p><ul><li>微软==&gt;windows 自带  </li></ul><p><strong>tomcat</strong></p><ul><li><p><strong>Tomcat</strong>是由Apache软件基金会属下<a href="https://zh.wikipedia.org/wiki/Jakarta%E9%A1%B9%E7%9B%AE">Jakarta项目</a>开发的<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>容器，实现了对<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>和<a href="https://zh.wikipedia.org/wiki/JavaServer_Page">JavaServer Page</a>（<a href="https://zh.wikipedia.org/wiki/JSP">JSP</a>）的支持，并提供了作为一些特有功能</p><blockquote><p>ps:工作3-5年后可以尝试手写tomcat服务器</p></blockquote><blockquote><p>下载东西的三部曲:</p><p>1.安装&amp;解压</p><p>2.了解配置文件和目录结构</p><p>3.这个东西的作用</p></blockquote><p>补充： java 内部的类，比如String 都来自于<strong>rt.jar包</strong>中</p></li></ul><p><img src="/2022/01/04/JavaWeb/03.png" alt="image-20220101085618516"></p><h1 id="3-tomcat"><a href="#3-tomcat" class="headerlink" title="3.tomcat"></a>3.tomcat</h1><h2 id="3-1下载"><a href="#3-1下载" class="headerlink" title="3.1下载"></a>3.1下载</h2><p><a href="https://tomcat.apache.org/">tomcat官网</a></p><p><img src="/2022/01/04/JavaWeb/04.png" alt="image-20220101090211230"></p><h2 id="3-2tomcat启动和配置"><a href="#3-2tomcat启动和配置" class="headerlink" title="3.2tomcat启动和配置"></a>3.2tomcat启动和配置</h2><p>文件夹结构:</p><p><img src="/2022/01/04/JavaWeb/05.png" alt="image-20220101090524114"></p><p><strong>启动和关闭</strong></p><p> <img src="/2022/01/04/JavaWeb/06.png" alt="image-20220101090649862"></p><p>点击即可</p><p>可看到命令行弹出 <strong>若闪退==&gt; 配置环境变量，检查是否错误！</strong></p><p><img src="/2022/01/04/JavaWeb/07.png" alt="image-20220101091655200"></p><p>在网页中输入：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>若页面显示，则正确</p><h2 id="3-3配置"><a href="#3-3配置" class="headerlink" title="3.3配置"></a>3.3配置</h2><p>服务器核心配置文件</p><p><img src="/2022/01/04/JavaWeb/08.png" alt="image-20220101091932529"></p><p>可以配置启动的端口号</p><ul><li>tomcat 默认端口号：8080</li><li>mysql ==&gt; 3306</li><li>http ==&gt; 80</li><li>https ==&gt; 443</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">             <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre><p>配置主机名</p><ul><li>默认主机名：localhost &lt;==&gt; 127.0.0.1</li><li>默认网站应用存在的位置==&gt;webapps</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span></code></pre><blockquote><p>面试题： 网站如何进行访问的！</p><ol><li>输入域名 ==&gt; 回车 </li><li>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件，看一下有无这个域名的映射<ol><li>有==&gt;直接返回对应ip，直接访问</li><li>无==&gt; 去DNS服务器找，找到就返回</li></ol></li></ol></blockquote><p><img src="/2022/01/04/JavaWeb/09.png" alt="image-20220101093806748"></p><p>可进行配置环境变量，方便启动</p><h2 id="3-4-发布一个web网站"><a href="#3-4-发布一个web网站" class="headerlink" title="3.4 发布一个web网站"></a>3.4 发布一个web网站</h2><p>模仿</p><ul><li><p>将自己写的网站，放在服务器tomcat指定的web文件夹下(webapps) ，就可以访问了</p></li><li><pre><code class="shell">--webapps: tomcat 服务器的web目录    -ROOT    -HUANGYIHENG 网站的目录        -WEB-INF            -classes :java 程序            -lib:web应用所依赖的包            -web.xml        -index.html 默认的首页        -static            -css                -style.css            -js            -img        -...</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础</title>
    <link href="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/04/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1.综述"></a>1.综述</h2><blockquote><p>docker学习</p></blockquote><ul><li>概述</li><li>安装</li><li>命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li>docker镜像</li><li>容器数据卷</li><li>dockerFile</li><li>docker网络原理</li><li>idea整合docker</li><li>docker Compose</li><li>docker swarm</li><li>CI/CD jenkins</li></ul><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2.概述"></a>2.概述</h2><h3 id="Docker为何会出现？"><a href="#Docker为何会出现？" class="headerlink" title="Docker为何会出现？"></a>Docker为何会出现？</h3><p>一款产品：开发==&gt; 上线  应用环境，应用配置</p><p>即开发 &amp; 运维。但常常有一个问题：在我的电脑可以运行，版本更新以及其他问题导致服务不可以，对于运维，考验就很大</p><p>而且环境配置是十分麻烦的，每一个机器都要部署环境（集群Redis，ES，hadoop）===&gt; 费事费力！</p><p>发布一个项目jar包（需要redis，mysql，jdk，es等环境）===&gt; 如果等<strong>带着jar包 和 环境</strong>一起发布岂不妙！</p><p>docker的作用就是如此！</p><blockquote><p>传统：开发jar，其余运维来做</p><p>现在，开发打包部署上线，一套流程</p></blockquote><p>类比: </p><p>java — 开发apk—-发布(到应用商店) —- 使用的话只需下载apk—-安装即可</p><p>java — jar(环境) —- 打包项目带上环境(<strong>镜像</strong>) — 放到docker仓库(即上述的商店) —  下载发布的镜像 — 直接可以运行</p><blockquote><p>docker的思想来自于 集装箱 ！</p><p>jre – 多个应用，可能会产生端口冲突</p><p>隔离 ===&gt; docker的核心思想，打包装箱，每个箱子是互相隔离的</p><p>故docker利用隔离机制，可以将服务器利用到极致！</p></blockquote><h3 id="docker历史"><a href="#docker历史" class="headerlink" title="docker历史"></a>docker历史</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/01.png" alt="image-20220102155224157"></p><p><a href="https://www.docker.com/">Docker官网</a></p><p><a href="https://docs.docker.com/">docker官网文档</a> 超级详细！</p><p><a href="https://hub.docker.com/">docker仓库地址</a> 类似于github</p><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F/1574">镜像</a>中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>操作系统的机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318">沙箱</a>机制，相互之间不会有任何接口。</p></blockquote><h2 id="3-docker安装"><a href="#3-docker安装" class="headerlink" title="3.docker安装"></a>3.docker安装</h2><h3 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h3><p>架构图</p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/2.png" alt="docker"></p><p><strong>镜像(image)</strong>:</p><blockquote><p>​    docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像===&gt; run ===&gt; tomcat01容器(提供服务器)，</p><p>可以通过这个镜像创建多个容器（最终服务运行或项目运行就在容器</p></blockquote><p><strong>容器(container)</strong></p><blockquote><p>docker利用容器技术，独立运行一个或一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令</p><p>目前可以把容器理解成一个简单的linux系统</p></blockquote><p><strong>仓库(repository)</strong></p><blockquote><p>仓库就是存放镜像的地方，分为共有仓库和私有仓库</p><p>docker hub(默认是国外的)</p><p>阿里云….也有容器服务器(需要配置镜像加速，类似于maven一样需要配置)</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>环境准备：</strong></p><blockquote><p>​    1、会linux命令</p><p>​    2、CentOS</p><p>​    3、使用ssh(例如xshell等….)</p></blockquote><p><strong>环境查看</strong>：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统内核是3.10以上的</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# uname -r3.10.0-1062.18.1.el7.x86_64</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 系统版本</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre><p> <strong>安装</strong> ===&gt; 根据官方文档</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、Uninstall old versions</span>sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span class="hljs-meta">#</span><span class="bash"> 2.安装需要的安装包</span> sudo yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo # 默认是从国外下载<span class="hljs-meta">#</span><span class="bash"> 更新一下yum索引</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4安装docker相关内容</span> sudo yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta"> #</span><span class="bash"> 5 启动docker</span> sudo systemctl start docker<span class="hljs-meta"> #</span><span class="bash"> 6 查看是否安装成功</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker versionClient: Docker Engine - Community Version:           20.10.12 API version:       1.41 Go version:        go1.16.12 Git commit:        e91ed57 Built:             Mon Dec 13 11:45:41 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.12  API version:      1.41 (minimum version 1.12)  Go version:       go1.16.12  Git commit:       459d0df  Built:            Mon Dec 13 11:44:05 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.4.12  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d runc:  Version:          1.0.2  GitCommit:        v1.0.2-0-g52b36a2 docker-init:  Version:          0.19.0  GitCommit:        de40ad0</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7 测试hello world</span>sudo docker run hello-world</code></pre><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/03.png" alt="image-20220103095017939"></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8 查看安装的镜像是否存在</span>[root@iZ2ze9nu608mhi5at5aufaZ ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</code></pre><p><strong>卸载</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1卸载依赖</span>sudo yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2 删除资源</span> sudo rm -rf /var/lib/docker #docker的默认工作路径 sudo rm -rf /var/lib/containerd</code></pre><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/04.png" alt="image-20220103095749769"></p><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://0wtfvcv1.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h3 id="HelloWorld运行的原理"><a href="#HelloWorld运行的原理" class="headerlink" title="HelloWorld运行的原理"></a>HelloWorld运行的原理</h3><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/05.png" alt="image-20220103100328777"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>docker如何工作的？</strong></p><blockquote><p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令</p></blockquote><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/06.png" alt="image-20220103101049775"></p><p><strong>docker为何比虚拟机快？</strong></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/07.png" alt="image-20220103101338942"></p><p><img src="/2022/01/04/Docker%E5%9F%BA%E7%A1%80/08.png" alt="image-20220103101646104"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2022/01/03/leetcode01/"/>
    <url>/2022/01/03/leetcode01/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/two-sum/"> leetcode 第一题</a></p><p>day1</p><blockquote><p>给定一个<strong>整数数组 nums</strong> 和一个<strong>整数目标值 target</strong></p><p>请你在该数组中找出 和为目标值 target  的那 两个 整数，并<strong>返回它们的数组下标。</strong></p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><p><strong>示例 1：</strong></p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p><strong>示例 2：</strong></p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p><strong>示例 3：</strong></p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力算法 ===&gt; </p><ul><li>i 和 j 双重遍历==&gt; 依次找对应数组元素两者之和是否等于target</li><li>新建数组，长度为2。若上述找到，则将数组内的值赋值为 i 和 j</li><li>将新数组作为最终结果进行return</li></ul><pre><code class="hljs c"><span class="hljs-comment">//c语言实现</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;        *returnSize = <span class="hljs-number">2</span>;<span class="hljs-comment">//因为要返回的数组大小为2</span>        <span class="hljs-comment">//新开辟数组，作为返回结果</span>       <span class="hljs-keyword">int</span> *result = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (*returnSize));       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numsSize; i++) &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; numsSize;j++) &#123;               <span class="hljs-keyword">if</span>( *(nums + i) + *(nums + j) == target ) &#123;                    *result = i;                    *(result + <span class="hljs-number">1</span>) = j;               &#125;           &#125;       &#125;       <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//返回最终结果</span>       <span class="hljs-built_in">free</span>(result);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//java实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> result[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; nums.length;j++) &#123;                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;                    result[<span class="hljs-number">0</span>] = i;                    result[<span class="hljs-number">1</span>] = j;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>效率太低了，时间复杂度高</li></ul><p><strong>如何才能把复杂度降到 0(n^2)以下？</strong></p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>利用<strong>哈希查找</strong></p><ul><li>遍历nums,记 <strong>i 为当前的下标</strong>，看 i 对应nums中的值 是否 map中存在**target - nums[i]**的key值</li><li>若存在，则找到了两个值，不存在则将当前**(num[i],i)** 放入map</li><li>一直遍历至结束</li></ul><p>比如：nums = [2,7,11,15]</p><blockquote><p>1、开始i = 0 找2，target-num[0] = 13-2 = 11 ,该值不存在，即map表中记上 key-value==&gt; (2,0)</p><p>2、此时i = 1 找到7 ，target - num[1] = 13 - 7 = 6 ,也不在，继续记上key-value===&gt;( 7, 1)</p><p>3、此时 i = 2 ,找 11，target - num[2] = 13 - 11 = 2 , 此时key在表中，找到，进行返回 对应下标0和2</p></blockquote><p>map:</p><table><thead><tr><th>key</th><th>2</th><th>7</th><th></th><th></th></tr></thead><tbody><tr><td>value</td><td>0</td><td>1</td><td></td><td></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-comment">//java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;         HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();         <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>( map.containsKey( target-nums[i]) ) &#123;                res[<span class="hljs-number">0</span>] = map.get(target - nums[i]);                res[<span class="hljs-number">1</span>] = i;            &#125;            <span class="hljs-keyword">else</span> &#123;                map.put(nums[i],i);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>法二好好学习 体会 ！哈希表写法</p><p>也可以不创建res数组，直接进行返回，减少空间复杂度</p><pre><code class="hljs java">Class HashMap&lt;K,V&gt;<span class="hljs-comment">// K -钥匙的Map保持型    V -映射的值的类型</span>Interface Map&lt;K,V&gt;<span class="hljs-comment">//以下均是map接口中的方法</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function"><span class="hljs-comment">//返回 `true`如果这Map包含一个指定的键映射。更正式地说，返回  `true`当且仅当这个图中包含了一个关键的 `k`这样 `(key==null ? k==null :  key.equals(k))`映射。（最多可以有一个这样的映射。） </span></span><span class="hljs-function"></span><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span><span class="hljs-function">返回指定的键映射的值，或 <span class="hljs-keyword">null</span>如果这个Map不包含的键映射。 </span><span class="hljs-function">    </span><span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key,V value)</span></span><span class="hljs-function">将指定的值与此映射中的指定键关联（可选操作）。如果映射以前包含一个键的映射，旧值将被指定的值替换</span></code></pre><p><img src="/2022/01/03/leetcode01/01.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html</title>
    <link href="/2021/07/18/html/"/>
    <url>/2021/07/18/html/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Hyper Text Markup Language(超文本标记语言)</p><p>W3C  =  World Wide Web Consortium（万维网联盟)</p><p><a href="https://www.w3.org/">万维网联盟</a></p><p>标准： <strong>结构化</strong>标准语言(html,xml)、<strong>表现</strong>标准语言(css)、<strong>行为</strong>标准(dom，ECMASript)</p><p>利用intelliJ IDEA 进行开发  如图</p><p><img src="/2021/07/18/html/1.png"></p><blockquote><p>HTML是负责描述文档语义的语言</p></blockquote><h3 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--我是注释 --&gt;</span><span class="hljs-comment">&lt;!--DOCTYPE 告诉浏览器，使用什么规范 --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--head网页头部--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--meta 描述性信息 ，一般用于做SEO=搜索引擎优化--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!--body网页主体--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="2、网页的基本标签"><a href="#2、网页的基本标签" class="headerlink" title="2、网页的基本标签"></a>2、网页的基本标签</h2><p>输入某个关键字，按tab键，快速生成</p><h3 id="1、标题标签"><a href="#1、标题标签" class="headerlink" title="1、标题标签"></a>1、标题标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标题标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标签<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre><h3 id="2、段落便签"><a href="#2、段落便签" class="headerlink" title="2、段落便签"></a>2、段落便签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--段落标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>跑的快 跑得快<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>一直没有耳朵 一直没有尾巴<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="3、换行标签"><a href="#3、换行标签" class="headerlink" title="3、换行标签"></a>3、换行标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--换行标签--&gt;</span>两只老虎 两只老虎<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>跑的快 跑得快 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>一直没有耳朵 一直没有尾巴 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>真奇怪 真奇怪！<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></code></pre><h3 id="4、水平线标签"><a href="#4、水平线标签" class="headerlink" title="4、水平线标签"></a>4、水平线标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--水平线标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span></code></pre><h3 id="5、字体样式标签"><a href="#5、字体样式标签" class="headerlink" title="5、字体样式标签"></a>5、字体样式标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--粗体 斜体--&gt;</span>粗体：<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>i love you！<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>斜体: <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>i love you!<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></code></pre><h3 id="6、注释和特殊符号"><a href="#6、注释和特殊符号" class="headerlink" title="6、注释和特殊符号"></a>6、注释和特殊符号</h3><p><strong>&amp;开始 ; 结束</strong>  中间部分根据输入的字母提示找对应的符号</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--特殊符号  &amp;提示; --&gt;</span>空       格空<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>格<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-symbol">&amp;gt;</span> 大于<span class="hljs-symbol">&amp;lt;</span> 小于<span class="hljs-symbol">&amp;copy;</span> 版权符号</code></pre><h3 id="7、图片标签"><a href="#7、图片标签" class="headerlink" title="7、图片标签"></a>7、图片标签</h3><p>常见图片格式：JPG、gif、png、bmp…..</p><p>**相对地址(推荐使用)**和绝对地址</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!--img</span><span class="hljs-comment">src:图片地址（必填</span><span class="hljs-comment">../  上一级目录 但本idea需要使用./才可以正常显示</span><span class="hljs-comment">alt：图片名字 (必填</span><span class="hljs-comment">title：在网页上鼠标放上去会显示(可选</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;./resources/image/2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;名校&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;悬停文字&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;700&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>文件结果如图，以后就这样写！规范</p><p><img src="/2021/07/18/html/2.png"></p><h3 id="8链接标签"><a href="#8链接标签" class="headerlink" title="8链接标签"></a>8链接标签</h3><p>必须掌握</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">a标签</span><span class="hljs-comment">href 必填，表示要跳转到哪个页面</span><span class="hljs-comment">target 表示窗口在哪打开</span><span class="hljs-comment">    _blank 表示在新标签中打开</span><span class="hljs-comment">    _self 表示在自己网页中打开(默认</span><span class="hljs-comment"></span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;1.我的第一个网页.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点击我跳转到页面1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点击我跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用name作为标记--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--锚链接</span><span class="hljs-comment">1需要一个锚标记</span><span class="hljs-comment">2跳转到此标记</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>功能性标签</p><p>第二个是<a href="https://shang.qq.com/v3/widget.html">qq推广</a>功能  里面自己粘贴过来</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--功能性标签</span><span class="hljs-comment">邮箱链接：mailto</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:1356410594@qq.com&quot;</span>&gt;</span>点击联系我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=1356410594&amp;site=qq&amp;menu=yes&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://wpa.qq.com/pa?p=2:1356410594:53&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;点我qq联系我&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>效果如图</p><p><img src="/2021/07/18/html/3.png"></p><p><strong>行内元素和块元素</strong></p><p>块元素：无论内容多少，只占一行 例如p标签</p><p>行内元素:内容撑开宽度，左右都是行内元素的可以排在一行</p><p>css中涉及块元素和行内元素转换</p><h3 id="9列表"><a href="#9列表" class="headerlink" title="9列表"></a>9列表</h3><h4 id="1、有序列表"><a href="#1、有序列表" class="headerlink" title="1、有序列表"></a>1、有序列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--有序列表 order list ，li = list --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre><h4 id="2、无序列表"><a href="#2、无序列表" class="headerlink" title="2、无序列表"></a>2、无序列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--无序列表--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><h4 id="3、自定义列表"><a href="#3、自定义列表" class="headerlink" title="3、自定义列表"></a>3、自定义列表</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!--自定义列表</span><span class="hljs-comment">dl:标签</span><span class="hljs-comment">dt 列表名称</span><span class="hljs-comment">dd:列表内容</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>学科<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>算法<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>c++<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>位置<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>菏泽<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre><h3 id="10表格"><a href="#10表格" class="headerlink" title="10表格"></a>10表格</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--表格 table</span><span class="hljs-comment">行 tr</span><span class="hljs-comment">列 td</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!--colspan 跨列 4表示跨4列    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>1-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-comment">&lt;!-- rowspan跨行 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></code></pre><p>如图</p><p><img src="/2021/07/18/html/4.png"></p><h3 id="11视频和音频"><a href="#11视频和音频" class="headerlink" title="11视频和音频"></a>11视频和音频</h3><p>video 和 audio</p><p><img src="/2021/07/18/html/04.png" alt="image-20210717175509092"></p><h2 id="3、页面分析"><a href="#3、页面分析" class="headerlink" title="3、页面分析"></a>3、页面分析</h2><p><img src="/2021/07/18/html/5.png"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页头部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>主体<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页脚部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="4-内联框架"><a href="#4-内联框架" class="headerlink" title="4.内联框架"></a>4.内联框架</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>  <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mainFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><ul><li>src:引用地址</li><li>width 和 height</li><li>mainFrame:框架标识名</li></ul><h2 id="5-表单"><a href="#5-表单" class="headerlink" title="5.表单"></a>5.表单</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;username &quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Yiheng&quot;</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;pwd &quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;Button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;Reset&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;重填&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><ul><li><p>method 请求方式==&gt; get/post</p><ul><li>get： 可以在url中看到提交的信息，不安全但高效</li><li>post：比较安全，可以传输大文件</li></ul></li><li><p>action 表单提交的位置，可以是网站，也可以是一个请求处理地址</p></li><li><p>value ==&gt; 表示该文本框的默认初始值</p><h3 id="表单格式"><a href="#表单格式" class="headerlink" title="表单格式"></a>表单格式</h3></li></ul><p><img src="/2021/07/18/html/06.png" alt="image-20220114074056056"></p><h3 id="单选框radio"><a href="#单选框radio" class="headerlink" title="单选框radio"></a>单选框radio</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 性别:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span> /&gt;</span>女    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>radio : 单选框标签 </p><p>name 表示组，要这俩是同一个组，不可以进行同时选择</p><h3 id="多选框-checkbox"><a href="#多选框-checkbox" class="headerlink" title="多选框 checkbox"></a>多选框 checkbox</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 爱好：       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>唱       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;dance&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>跳       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;rap&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>rap       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="按钮-button"><a href="#按钮-button" class="headerlink" title="按钮 button"></a>按钮 button</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>按钮:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;btn1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击！&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../resources/image/1.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>type:</p><ul><li>button ==&gt; 普通按钮</li><li>image ==&gt; 图像按钮</li><li>submit ==&gt; 提交按钮</li><li>reset ==&gt; 重置</li></ul><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 下拉框:    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>山东<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;value&quot;</span> &gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 反馈:     <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;textarea&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>我是文本框<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="文件域"><a href="#文件域" class="headerlink" title="文件域"></a>文件域</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 上传:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;files&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 邮箱验证:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    URL验证:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-comment">&lt;!--       数字验证 --&gt;</span>    商品数量:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="滑块和搜索框"><a href="#滑块和搜索框" class="headerlink" title="滑块和搜索框"></a>滑块和搜索框</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!--    滑块--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 音量:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;voice&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 搜索框:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;search&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>-  隐藏域：hidden-  只读: readonly-  禁用：disabled</code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!--     增强鼠标可用性 当点击时，就会规定到文本框中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span>你点我试试<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mark&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="表单初级验证"><a href="#表单初级验证" class="headerlink" title="表单初级验证"></a>表单初级验证</h3><ul><li><p>placeholder 提示信息 ，会让你根据提示输入对应信息</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name &quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><img src="/2021/07/18/html/blog\source\_posts\html\07.png" alt="image-20220114084831473" style="zoom:67%;"></li><li><p>require 非空验证</p></li><li><p>pattern 正则表达式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言学习</title>
    <link href="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习！"><a href="#C语言再学习！" class="headerlink" title="C语言再学习！"></a>C语言再学习！</h2><p>利用Visual Studio </p><p>vs –debug 将监视窗口、调用堆栈、以及内存变化调整出来！</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2.png"></p><blockquote><p>错误：编译错误&amp;链接错误</p><p>​    编译错误：双击就可以定位到第几行</p><p>​    链接错误：库函数可能写错了！看对应函数符号</p></blockquote><p>​    </p><p>编辑main.c —&gt; 编译main.obj —&gt;和库函数进行链接—&gt;main.exe—-&gt;执行</p><p><strong>写代码——增量编写法，写一点进行测试测试</strong>，<strong>保证正确</strong>，<strong>再继续写</strong></p><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>​    1. <strong>基本类型</strong></p><ul><li>整型 int</li></ul><p>​            表示范围：-2^31 到 2^31 - 1</p><p>​                short 表示范围：-2 ^ 15 到 2 ^ 15 - 1</p><p>​                long 32位机器(4个字节)，64位机器(8个字节)  -2 ^ 63 到 -2 ^63 - 1</p><p>​                unsigned int 变化范围： 0 到 2^32 - 1</p><ul><li>字符型 char</li></ul><p>​                    \n  光标到下一行行首</p><p>​                    \r   光标回到当前行行首</p><p>​                    \b  向前退一格</p><ul><li>实型(浮点型)：</li></ul><p>​                单精度实型float(四个字节)；  有效数字：6-7位</p><p>​                双精度double(八个字节)       有效数字：15-16位</p><p>​    2.<strong>构造类型</strong></p><blockquote><p>数组类型[]</p><p>结构类型struct</p><p>联合类型union</p><p>枚举类型 enum</p></blockquote><p>​    3.*<em>指针类型 **</em></p><ol start="4"><li><strong>空类型(无值类) ：void</strong></li></ol><p>常量：例如 100，3.14，‘a’，“abc”</p><p>变量：代表内存中具有特定属性的一个存储单元，用来存放数据，这就是变量的值，<strong>在程序运行期间，这些值得程序的执行过程是可以改变的。</strong></p><p>符号常量：#define SUN 7</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/3.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/4.png"></p><blockquote><p>熟悉进制的转换</p></blockquote><p>vs采用小端：低位在前，高位在后</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5.png"></p><p>补码：按位取反再+1</p><h3 id="二、scanf原理"><a href="#二、scanf原理" class="headerlink" title="二、scanf原理"></a>二、scanf原理</h3><blockquote><p>输入读取接口：scanf，getchar</p><p>标准输出接口：printf，putchar</p></blockquote><p>1、标准输入缓冲区原理</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">char</span> c;<span class="hljs-comment">//用户输入</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; i = %d\n&quot;</span>,i);<span class="hljs-comment">//正常打印了</span><span class="hljs-comment">//清除缓冲区  ps:vs2013以上版本需要rewind(stdin)  </span>fflush(<span class="hljs-built_in">stdin</span>); <span class="hljs-comment">//如果没有这一句，则c不会等待用户输入，而是直接显示出来c = </span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c); <span class="hljs-comment">//为何？因为输入一个数之后，按回车了，\n在缓冲区里面，读取到了 \n 所以不会等待用户输入 </span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>,c); </code></pre><p><strong>当使用%d的时候，会忽略空格 和 \n</strong></p><p>scanf匹配原理：即是匹配到什么之后，删除什么，没有匹配的仍在缓冲区中</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/5_1.png"></p><p>2、scanf循环读取</p><p><code>while( scanf(&quot;%d&quot;,&amp;i) != EOF )</code></p><p>进行完善</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i,ret<span class="hljs-comment">//即便输入的不是整型，也可以提供用户继续输入</span><span class="hljs-keyword">while</span> ( fflush(<span class="hljs-built_in">stdin</span>),(ret = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i)) != EOF ) </code></pre><p>3、混合读取 </p><pre><code class="hljs c"><span class="hljs-comment">//  %d %c中间加一个空格</span><span class="hljs-comment">//即在读取字符时，在字符前面加上空格</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c%f%lf&quot;</span>,&amp;i,&amp;c,&amp;f,&amp;d);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %5.2f %f &quot;</span>,i,c,f,d);</code></pre><p>getchar() 和 putchar()</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> c;c = getchar();<span class="hljs-built_in">putchar</span>(c);c = getchar();<span class="hljs-comment">//并不会再次阻塞，等待继续输入，而是直接结束，因为缓冲区里有\n,读取到直接退出了</span><span class="hljs-built_in">putchar</span>(c);</code></pre><p>printf()利用占位符进行对其</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-number">21</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hi，%-10s is %-3d age.\n&quot;</span>,<span class="hljs-string">&quot;Yiheng&quot;</span>,<span class="hljs-number">5</span>);</code></pre><h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h3><p>*<em>1、算术运算符（ + - * / %）*</em></p><p><strong>2、关系运算符( &gt; ,&lt;, ==, &gt;= ,&lt;= , !=)</strong></p><p><strong>3、逻辑运算符( !,&amp;&amp;,|| )</strong></p><p><strong>4、位运算符( &lt;&lt;, &gt;&gt;, ~, | , ^ , &amp;)</strong></p><p>​            左移&lt;&lt; : 高位丢弃，低位补0，<strong>相当于乘2</strong>，但效率比乘法高</p><p>​            右移&gt;&gt;：**相当于除2 **  正数(unsigned)的话，低位丢弃，高位补0(直接除2);负数的话，低位丢弃，高位补1(减1再除2)</p><p><strong>5、赋值运算符 （ = 及其扩展赋值运算符 ）</strong></p><p><strong>6、条件运算符( ? : )  即三目运算符</strong></p><p><strong>7、逗号运算符 ( , )</strong></p><p>*<em>8、指针运算符 （ * 和 &amp;）*</em></p><p><strong>9、求字节数运算符（ sizeof() )</strong></p><p><strong>10、强制类型转换运算符 （ （类型） ）</strong></p><p><strong>11、分量运算符 (  .  -&gt; )</strong></p><p><strong>12、下标运算符 （ [ ]  ）</strong></p><p><strong>13、其他，如函数调用运算符:()</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/6_1.png"></p><p><strong>算术运算符优先级高于关系运算符</strong></p><p><strong>关系运算符高于逻辑与和逻辑或</strong></p><p>a = 5  ==&gt;范围 -6到5</p><p> 0000 0101</p><p>1111 1010 ==&gt; 0000 0110 ==&gt; -6 </p><p>1111 1011 ==&gt;0000 0101 ==&gt; -5</p><p>ps:若要拿到任意一个数的最低位为1的那个数，不利用循环如何实现？<br>     1、若是循环，则此数字每一位和1进行&amp;运算，若为0，则1&lt;&lt;1，再进行下一位比较，为1则找到了<br>        2、利用 i &amp; -i = 最终低位为1的那个数字 ===&gt;该数与其对应补码进行&amp;操作</p><p>异或^：</p><p>​    <strong>任何数与自身异或为 0</strong> </p><p>​    <strong>任何数与0异或为其自身</strong></p><p>可利用异或对两个数进行交换，而不使用中间变量</p><p>交换两个数，三种方法</p><pre><code class="hljs c"><span class="hljs-comment">//1、利用异或，但必须有两个空间，不会出现溢出</span>a = <span class="hljs-number">5</span>,b = <span class="hljs-number">4</span>;a = a ^ b;b = a ^ b; <span class="hljs-comment">// 此时即为 b = (a^b) ^b = a</span>a = a ^ b; <span class="hljs-comment">//此时 a = (a ^ b ) ^ a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//2、利用数学运算对其进行交换,可能会溢出</span>a = a + b;b = a - b;<span class="hljs-comment">// b = (a + b) - b = a </span>a = a - b;<span class="hljs-comment">// a = (a + b) - a = b</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">//3、传统的，利用另一个变量temp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">7</span>,temp;temp = a;a = b;b = temp;</code></pre><p>例题：若数组中 101个数，50个数出现两次，1个数出现一次，找出出现一次的这个数的值？**(经典)**</p><p>对数组的的数进行异或操作</p><pre><code class="hljs C"><span class="hljs-comment">//简化版本</span><span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;;    <span class="hljs-keyword">int</span> i ,result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); i++) &#123;        result ^= arr[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find value = %d\n&quot;</span>,result); <span class="hljs-comment">//最终输出为7</span></code></pre><p>自增和自减</p><p><code>j = i-- &gt; -2; //等价于j = i &gt; -2;i --</code></p><h3 id="四、选择，循环和数组"><a href="#四、选择，循环和数组" class="headerlink" title="四、选择，循环和数组"></a>四、选择，循环和数组</h3><p>1、if …else</p><p>2、switch</p><pre><code class="hljs angelscript"><span class="hljs-comment">// ( )里面不可以是浮点型表达式 </span><span class="hljs-keyword">switch</span>()&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">break</span>     dafault:<span class="hljs-keyword">break</span>;&#125;</code></pre><p>3、循环</p><p>（1）goto  学校老师讲的不用掌握goto是错误的，<strong>goto才是循环的本质</strong>，对应于汇编中的jmp跳转 </p><pre><code class="hljs C"><span class="hljs-comment">//求前100个数字的和</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;label:    sum += i;    i++;     <span class="hljs-comment">//需要进行判断，小于100才goto，不然一直循环</span>    <span class="hljs-keyword">if</span>( i &lt;= <span class="hljs-number">100</span>)&#123;        <span class="hljs-keyword">goto</span> label;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);</code></pre><p>（2） while  和  do ….while </p><p>（3） for</p><p>4、数组：具有<strong>相同数据</strong>类型的数据的<strong>有序</strong>集合</p><p>(1)、一维数组</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-comment">//定义数组的时候，必须初始化</span>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//arr[0]到arr[4]</span>    <span class="hljs-keyword">sizeof</span>(arr) <span class="hljs-comment">//大小为20个字节 5*4</span>    <span class="hljs-comment">//访问越界，提示stack around arr 代表栈空间访问越界</span>    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">6</span>;    arr[<span class="hljs-number">6</span>] = <span class="hljs-number">7</span>;    arr[<span class="hljs-number">7</span>] = <span class="hljs-number">8</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<span class="hljs-comment">//此时i变为8了，在vs中</span></code></pre><p>访问越界如图所示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/7.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/8.png"></p><p>当作为函数参数传递时，是传递的数组的起始地址，<strong>即数组名存的是数组的起始地址</strong>，不可以修改</p><p>C<strong>语言函数调用是值传递</strong></p><p>(2)、二维数组</p><pre><code class="hljs markdown">int a[<span class="hljs-string">3</span>][<span class="hljs-symbol">4</span>] = &#123;1,3,5,7,2,4,6,8,9,11,13,15&#125;;//范围a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]到a[<span class="hljs-string">2</span>][<span class="hljs-symbol">3</span>]sizeof(a) //48个字节sizeof(a[0])  //16个字节 sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">1</span>]) //4个字节</code></pre><p>(3)、字符数组</p><p>利用%s时scanf(“%s”,d)， 如果输出的有空格，则停止向后读</p><pre><code class="hljs C"><span class="hljs-comment">//这样打印，会出现乱码，因为利用%s打印，遇到\0会停下，并没有存地方\0标志，所以会在内存中打印至\0为止</span><span class="hljs-comment">//  \0代表结束标志 而\0的值即为0</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,c);<span class="hljs-comment">//建议，要有空间保存\0，即长度比字符长度大1</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;ABCDEF&quot;</span>;<span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">sizeof</span>(c); <span class="hljs-comment">// 为10</span><span class="hljs-built_in">strlen</span>(c); <span class="hljs-comment">//是5</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/9.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/10.png"></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/11.png">当利用第二种方法存字符数组时，会在最后添上\0</p><pre><code class="hljs C">gets(c);<span class="hljs-comment">//会在最后添上\0，不会把\n读取到内存中   类似于scanf 也可能不安全，会访问越界</span> <span class="hljs-built_in">puts</span>(c)<span class="hljs-comment">//会在最后打印一个\n</span> <span class="hljs-comment">//等价于printf(&quot;%s\n&quot;,c);</span> <span class="hljs-comment">//循环输入字符串,并打印。按ctrl+z则会退出</span> <span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>]; <span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span> ) &#123;     <span class="hljs-built_in">puts</span>(c); &#125; <span class="hljs-comment">//安全，不会访问越界，当＞sizeof(c)时，系统不允许输入</span> <span class="hljs-comment">//并且会把\n读到内存中</span> fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>);</code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/12.png">例如：输入hello，fgets()会在后面增加\0和\0</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13.png">例：gets()情况，输入hello之后</p><p>str<strong>系列字符串操作函数</strong>   (在头文件#include&lt;string.h&gt;中)</p><pre><code class="hljs C"><span class="hljs-comment">//如果去除fget()后的最后一个\n呐？</span><span class="hljs-comment">//可以利用strlen获取最后的位置，然后替换成\0</span><span class="hljs-comment">//打印输出，并计算长度(去除\n)</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">size_t</span> len;<span class="hljs-keyword">while</span>( fgets(c,<span class="hljs-keyword">sizeof</span>(c),<span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;    c[ <span class="hljs-built_in">strlen</span>(c) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//进行替换</span>    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输入什么则进行输出什么</span>    len = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);<span class="hljs-comment">//输出输入的长度</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//复制字符串 不能用于整型数组</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">char</span> d[<span class="hljs-number">50</span>];<span class="hljs-comment">//如果过小，会访问越界</span><span class="hljs-built_in">strcpy</span>(d,c);<span class="hljs-comment">//利用此接口进行赋值，会把c中\0读到d中，之后结束</span><span class="hljs-built_in">puts</span>(d);<span class="hljs-comment">//将字符进行拼接！</span><span class="hljs-built_in">strcat</span>(d,<span class="hljs-string">&quot;Yiheng&quot;</span>); <span class="hljs-comment">//最后会有\0</span></code></pre><p>strn<strong>系列字符串造作函数</strong></p><pre><code class="hljs C"><span class="hljs-comment">//strncpy</span><span class="hljs-keyword">int</span> c[<span class="hljs-number">50</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">50</span>];<span class="hljs-keyword">while</span>( gets(c) != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//需要另加一句，保证要拷贝到的数组中元素为0</span>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));<span class="hljs-comment">//内置接口，此时将不会出现错误</span>    <span class="hljs-built_in">strncpy</span>(d,c,<span class="hljs-number">7</span>);<span class="hljs-comment">//将c中的前7个字符拷贝到d中，不会有\0结束符，知道内存中遇到\0才结束输出</span>    <span class="hljs-built_in">puts</span>(d);&#125;<span class="hljs-built_in">strncmp</span>(d,<span class="hljs-string">&quot;李宁&quot;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//判断前二个字节是否相等，即d中输入是否和‘李’相等(汉字占两个字节</span><span class="hljs-built_in">strncat</span>(d,<span class="hljs-string">&quot;牛牛牛&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//会部分拼接，把‘牛’拼到d后面</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> b[<span class="hljs-number">5</span>];<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//可以进行内存拷贝，不可以用strcpy()，因为遇到\0则停止拷贝</span></code></pre><h3 id="五、指针"><a href="#五、指针" class="headerlink" title="五、指针"></a>五、指针</h3><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-comment">//通过指针间接访问变量i</span><span class="hljs-keyword">int</span> *p = &amp;i;<span class="hljs-comment">//把i的地址保存起来，初始化必须是一个变量的取地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<span class="hljs-comment">//取保存起来地址所对应的值</span></code></pre><p>1、指针的使用场景：<strong>传递和偏移</strong></p><p>指针的传递：子函数要改变主函数的变量</p><pre><code class="hljs C"><span class="hljs-comment">//函数调用值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *i)</span></span>&#123;    *i /= <span class="hljs-number">2</span>;&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    change(&amp;i)<span class="hljs-comment">//这是会改变i的值，应该是传递的保存i的地址</span>&#125;</code></pre><p>指针的偏移(服务于数组)：p+1，是偏移的基类型的大小–&gt;sizeof(int)</p><pre><code class="hljs C"><span class="hljs-comment">//借助指针将数组元素输出</span><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> *p = &amp;a;<span class="hljs-comment">//数组名保存了数组的起始地址</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>,*(p + i)); <span class="hljs-comment">//其实a[i] &lt;==&gt; *(a+i)</span>&#125;</code></pre><p>2、指针和自增自减操作符</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> *p = a;<span class="hljs-keyword">int</span> j;j = *p++;<span class="hljs-comment">//==&gt;j = *p ,p ++;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 2 7</span>j = (*p)++ <span class="hljs-comment">//===&gt; j = *p,(*p)++;</span><span class="hljs-comment">//上面可改成j  = p[0] ++ 两者等价，不会有影响</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d,j = %d,*p = %d\n&quot;</span>,a[<span class="hljs-number">0</span>],j,*p);<span class="hljs-comment">//2 7 8</span><span class="hljs-comment">//通过上述(*p)++,把数组中第二个元素7变成了8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[1] = %d\n&quot;</span>,a[<span class="hljs-number">1</span>]); <span class="hljs-comment">//8</span></code></pre><p>3、指针与一维数组</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>&#123;    *p = <span class="hljs-string">&#x27;H&#x27;</span>;    p[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;E&#x27;</span>;    *(p+<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;L&#x27;</span>;&#125;main()&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;hello&quot;</span>;    change(c);    <span class="hljs-built_in">puts</span>(c) <span class="hljs-comment">//输出  HELlo</span>&#125;</code></pre><p> (1)动态内存申请</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> needSize;<span class="hljs-keyword">char</span> *pStart;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;needStart);pStart = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(needSize);<span class="hljs-comment">//使用malloc动态申请堆空间</span><span class="hljs-comment">//向申请的空间填入数据</span><span class="hljs-built_in">strcpy</span>(pStart,<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-built_in">puts</span>(pStart);<span class="hljs-built_in">free</span>(pStart);<span class="hljs-comment">//最后用完进行释放</span><span class="hljs-comment">//释放完之后要将此指针赋值为NULL,不然就成了野指针</span>pStart = <span class="hljs-literal">NULL</span>;</code></pre><p>（2）野指针</p><pre><code class="hljs C"><span class="hljs-keyword">int</span> *p1,*p2,*p3;p1 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p1 = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p1 = %d\n&quot;</span>,*p1);<span class="hljs-comment">//1</span>p2 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p2 = <span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p2 = %d\n&quot;</span>,*p2);<span class="hljs-comment">//2</span><span class="hljs-built_in">free</span>(p2);<span class="hljs-comment">//要加上p2 = NULL</span>p2 = <span class="hljs-literal">NULL</span>;p3 = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));*p3 = <span class="hljs-number">3</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//3</span>*p2 = <span class="hljs-number">100</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*p3 = %d\n&quot;</span>,*p3);<span class="hljs-comment">//不加p2 = NULL ，会输出100</span><span class="hljs-comment">//由于p2被free了，但是后来p3申请空间不知道，p3申请会用p2释放的空间。之后又用了p2所以造成p3出现错误</span><span class="hljs-comment">//在free后面添加p2 = NULL;，如果再次使用p2则会产生错误为何</span></code></pre><p>(3)都是内存空间，为何分栈和堆？</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/13_1.png"></p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>windows中栈空间有上限的，单个函数<span class="hljs-number">1</span>M，如果超过，则会Stack Overflow<span class="hljs-regexp">//</span>函数递归调用也有一个上限<span class="hljs-comment">#define N 500000</span>int a[N]<span class="hljs-regexp">//</span>执行到这里则会出现栈溢出</code></pre><p>(4)栈空间和堆空间的差异</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printStack</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;i am stack&quot;</span>;    <span class="hljs-built_in">puts</span>(c);<span class="hljs-comment">//输出i am stack</span>    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">printMalloc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;i am malloc&quot;</span>);    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出i am malloc</span>    <span class="hljs-keyword">return</span> p; &#125;main() &#123;    <span class="hljs-keyword">char</span> *p;    p = printStack();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//会出现乱码</span>    <span class="hljs-comment">//因为函数执行进行压栈，执行完之后弹栈</span>    <span class="hljs-comment">//之后执行puts的时候把原来函数的栈空间给占了</span>    <span class="hljs-comment">//应该怎么办，利用堆！</span>    p = printMalloc();    <span class="hljs-built_in">puts</span>(p);<span class="hljs-comment">//输出 i am malloc</span>    <span class="hljs-built_in">free</span>(p);    p = <span class="hljs-literal">NULL</span>;&#125;</code></pre><p>(5)realloc动态扩容</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 20</span><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(MAX);<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,max = MAX;<span class="hljs-comment">//对其进行循环输入字符</span><span class="hljs-keyword">while</span>( <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c) != EOF ) &#123;<span class="hljs-comment">//因为最后要放&#x27;\0&#x27;，故是max -1</span>    <span class="hljs-keyword">if</span>( i == max - <span class="hljs-number">1</span>) &#123;        p = (<span class="hljs-keyword">char</span> *)reallloc(p, max * <span class="hljs-number">2</span>);<span class="hljs-comment">//如果达到最后，利用realloc进行扩容</span>    &#125;    p[i] = c;<span class="hljs-comment">//每次输入的保存起来</span>    i++;&#125;p[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//将最后弄成结束标志，按下ctrl+z则会显示结果</span><span class="hljs-built_in">puts</span>(p);<span class="hljs-built_in">free</span>(p);p = <span class="hljs-literal">NULL</span>;</code></pre><p>（6）字符指针与字符数组初始化</p><p>申请完空间之后，为何<code>strcpy(p,&quot;i am malloc&quot;);</code>而不是 <code>p = &quot;i am malloc&quot;;</code></p><pre><code class="hljs C"><span class="hljs-keyword">char</span> *p = <span class="hljs-string">&quot;helloworld&quot;</span>; <span class="hljs-comment">//字符串存放在数据段的字符串常量区，是不可以修改的！p指向了首地址</span><span class="hljs-keyword">char</span> c[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-comment">//这个是在代码段，可以修改</span>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 正确！ </span>p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<span class="hljs-comment">// 错误！！</span>p = <span class="hljs-string">&quot;how are you&quot;</span><span class="hljs-comment">//正确</span>c = <span class="hljs-string">&quot;how are you!&quot;</span><span class="hljs-comment">//错误！！因为c是起始地址，是只读的</span><span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;helloworld!&quot;</span>)<span class="hljs-comment">//错误，因为strcpy会对p[0]=&#x27;h&#x27;进行逐一赋值，但p空间此时不可以修改</span><span class="hljs-comment">//strcpy必须是可读可写的，即malloc申请的堆空间,或让p指向堆空间，指向可以修改的空间</span><span class="hljs-comment">//例如：</span>p = c;<span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;Yiheng&quot;</span>);<span class="hljs-comment">//此时正确</span></code></pre><p>(7)数组指针（服务于二维数组）</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> b[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//b数组名是保存了数组的起始地址 </span><span class="hljs-comment">//&amp;b也是保存了数组的起始地址，但&amp;b类型是数组指针，而b里面的类型为整型指针</span><span class="hljs-comment">//b+1 偏移的是数组类型的一个字节的大小，例如b + 1之后所对应地址的那个变量的值为2</span><span class="hljs-comment">//&amp;b+1 偏移的是整个数组字节大小，此时将跑到数组外面那个地址区域</span><span class="hljs-built_in">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<span class="hljs-comment">//a+1 指向2的起始地址</span><span class="hljs-comment">//&amp;a+1 指向15之后那个地方的地址(相当于&amp;a是一个二维数组指针,偏移整个数组的大小)</span></code></pre><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14.png"></p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[][<span class="hljs-number">4</span>],<span class="hljs-keyword">int</span> row)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; row; i ++) &#123;         <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-keyword">sizeof</span>(*p) /<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> );j++)&#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*(*(p+i)+j));             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,p[i][j]);</span>             <span class="hljs-comment">//等价printf(&quot;%3d&quot;,*(p[i]+ j));</span>         &#125;     &#125;&#125;main() &#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;    <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>];<span class="hljs-comment">//数组指针，指向一个长度为4的一维数组</span>    p = a;<span class="hljs-comment">//不会报错</span>    print(p,<span class="hljs-number">3</span>);&#125; <span class="hljs-comment">//动态二维数组</span>p = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">4</span>])<span class="hljs-built_in">malloc</span>( <span class="hljs-number">16</span> * <span class="hljs-number">100</span>);</code></pre><p> (7)二级指针  (<strong>只服务于一级指针的传递和偏移</strong>)</p><p>子函数内需要修改主函数某个一级指针的值，需要二级指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p1,<span class="hljs-keyword">int</span> **p2)</span> </span>&#123;    *p1 = *p2&#125;main() &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>,j = <span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> *p1 = &amp;i,*p2 = &amp;j;<span class="hljs-comment">//此时*p1 = 10,*p2 = 5;</span>    <span class="hljs-comment">//想改变*p1 = 5,*p2 = 10 </span>    change(&amp;p1,&amp;p2);<span class="hljs-comment">//此时利用二级指针成了交换</span>&#125;</code></pre><p>二级指针的初始化必须是某个一级指针变量的取地址</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">10</span>])</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPointerArr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++) &#123;        pust(p[i]);    &#125;&#125;main()&#123;    <span class="hljs-keyword">char</span> b[N][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&quot;lilei&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;zhousi&quot;</span>&#125;;    <span class="hljs-keyword">char</span> **p = (<span class="hljs-keyword">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *) * N);    print(b);<span class="hljs-comment">//打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>    printPointerArr(b);<span class="hljs-comment">//同样打印出lele&quot;,&quot;lili&quot;,&quot;lilei&quot;,&quot;hanmeimei&quot;,&quot;zhousi</span>&#125;</code></pre><p>(8)函数指针</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am b func&quot;</span>);&#125;main() &#123;    <span class="hljs-keyword">void</span> (*p) () <span class="hljs-comment">//p为函数指针</span>    p = b;<span class="hljs-comment">//初始化必须为某个函数的函数名</span>    p();<span class="hljs-comment">//打印i am b func</span>&#125;</code></pre><h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p> <strong>1、函数声明，定义，及调用</strong></p><p>​    通常将程序内容分别放在若干个源文件中，再由若干原程序文件组成一个C程序，便于<strong>分别编写，分别编译，提高调试效率</strong></p><p>点击’运行’即代表增量编译，如果之前运行过，则在运行的基础上进行编译(耗时很短)</p><p>右键–&gt;重新生成 则代表重新编译一次(但意义并不大，运行也慢)</p><p>函数不能嵌套定义</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/14_1.png"></p><pre><code class="hljs C"><span class="hljs-comment">//main.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//函数调用</span>    printStar();    printMessage();&#125;<span class="hljs-comment">//func.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">//函数声明,作用：对函数的形参和返回值类型进行检查</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//fun.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;func.h&quot;</span></span><span class="hljs-comment">//函数定义</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;how are you?&quot;</span>);&#125;</code></pre><p>2、函数的分类</p><blockquote><p>(1)标准函数，即库函数，系统提供的</p><p>(2) 用户自己定义的函数</p></blockquote><p>不同函数之间传递数据：</p><p>​    参数：通过形参和实参(调用完，空间则释放掉)</p><p>​    返回值：用return语句返回计算结果</p><p>​    全局变量：外部变量(不好，因为会一直占用着空间，也导致阅读困难)</p><p>3、函数的嵌套调用</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><span class="hljs-comment">//嵌套函数直接回到主函数，main调用a，a调用b，b直接回到main</span><span class="hljs-comment">// 函数将系统栈保存于envbuf中，以供以后调用longjmp()。当第一次调用setjmp(),它的返回值为零。</span><span class="hljs-comment">//之后调用longjmp(),longjmp()的第二个参数即为setjmp()的返回值</span>jmp_buf envbuf;<span class="hljs-comment">//全局变量</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am func b\n&quot;</span>);    longjmp(envbuf,<span class="hljs-number">5</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before,i am func a\n&quot;</span>);    b();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after,i am func a\n&quot;</span>);<span class="hljs-comment">//此时这一句不会打印</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ret;    ret = setjmp(envbuf);    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == ret) &#123;        a();&#125;</code></pre><p> 4、函数的递归调用</p><pre><code class="hljs C"><span class="hljs-comment">//爬楼梯，一次只能爬1或者2层</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-number">1</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> ( <span class="hljs-number">2</span> == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-2</span>) + f(n<span class="hljs-number">-1</span>);&#125;</code></pre><p>5、变量及函数的作用域</p><p>​    局部变量和全局变量(内部变量和外部变量)</p><p><strong>变量在离自己最近的大括号内有效</strong></p><p>static—&gt;修饰局部变量，全局变量，函数</p><p><code>static int i = 0;</code>//静态变量只会初始化一次</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//局部变量加static</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//若没有static，则会多次执行此条语句</span>    i++;    print(<span class="hljs-string">&quot;%d\n&quot;</span>,i);&#125;main() &#123;<span class="hljs-comment">//每调用一次就会增加1</span>    fun();<span class="hljs-comment">//此时i = 1</span>    fun();<span class="hljs-comment">//此时i = 2</span>&#125;<span class="hljs-comment">//全局变量,以及函数 前加static，则表明不能被其他的文件借用了，只能在此文件中可见 </span>ps：另一个文件借用全局变量时，借用加<span class="hljs-keyword">extern</span>  </code></pre><h3 id="七、结构体"><a href="#七、结构体" class="headerlink" title="七、结构体"></a>七、结构体</h3><p>不同类型的数据组合成一个有机的整体</p><p>为了避免浪费空间，会把小字节的数据放在一起</p><pre><code class="hljs C"><span class="hljs-comment">//结构体定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">char</span> sex;    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">float</span> score;    <span class="hljs-keyword">char</span> address[<span class="hljs-number">30</span>];&#125;;<span class="hljs-comment">//结构体声明</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">s</span> = &#123;</span><span class="hljs-number">1001</span>,<span class="hljs-string">&quot;lili&quot;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">98</span>,<span class="hljs-string">&quot;heze&quot;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_t</span> <span class="hljs-title">sArr</span>[3];</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.address);<span class="hljs-comment">//打印</span><span class="hljs-comment">//用户输入数据，scanf里面空格别忘记</span><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i ++) &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s %c%d%f%s &quot;</span>,&amp;sArr[i].num,sArr[i].name,&amp;sArr[i].sex,&amp;sArr[i].age,&amp;sArr[i].score,sArr[i].address);&#125;<span class="hljs-comment">/** 用户输入</span><span class="hljs-comment">1001 lili M 20 98 heze</span><span class="hljs-comment">1002 lele F 22 92 heze</span><span class="hljs-comment">1003 hehe M 19 88 heze</span><span class="hljs-comment">**/</span><span class="hljs-comment">//打印到屏幕</span><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %c %d %5.2f %s\n&quot;</span>,sArr[i].num,sArr[i].name,sArr[i].sex,sArr[i].age,sArr[i].score,sArr[i].address);&#125;</code></pre><p>通过<strong>结构体变量名.成员名</strong>来访问结构体成员</p><p>1、结构体指针</p><p>一个结构体变量的指针就是该变量所占据的内存段的起始地址。</p><p>可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址</p><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">float</span> score;&#125;<span class="hljs-keyword">student_t</span>,*pStudent_t;<span class="hljs-comment">//student_t就是结构体的别名 *pStudent_t等价于struct student*，可以利用这个定义指针</span>pStudent_t p1,p2;<span class="hljs-comment">//p1，p2均为结构体指针</span><span class="hljs-keyword">student_t</span> s = &#123;<span class="hljs-number">101</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">99</span>&#125;;<span class="hljs-keyword">student_t</span> *p = &amp;s;<span class="hljs-comment">//结构体指针</span><span class="hljs-comment">//利用指针访问成员变量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s %0.2f\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;score);</code></pre><p>2、typedef定义变量 </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE; <span class="hljs-comment">//此时相当于INTERGE为int类型，即int的别名,编译的时候真正产生这个类型</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4<span class="hljs-comment">// 一般是定义常量，而且是在预处理时候直接替换,后面不需要加分号，上面那个需要加</span></span></code></pre><p>3、共用体与枚举</p><pre><code class="hljs C"><span class="hljs-comment">//联合体(共用体) 所有成员公用一块空间，并且不可修改</span><span class="hljs-keyword">union</span> data &#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">float</span> f;&#125;;<span class="hljs-comment">//枚举</span><span class="hljs-keyword">enum</span> weekday &#123;sun,mon,tue,wed,thus,fir,sat&#125;;<span class="hljs-comment">//sum = 0，mon = 2,.......</span></code></pre><h3 id="九、数据结构基础"><a href="#九、数据结构基础" class="headerlink" title="九、数据结构基础"></a>九、数据结构基础</h3><h4 id="1、链表的增删改查"><a href="#1、链表的增删改查" class="headerlink" title="1、链表的增删改查"></a>1、链表的增删改查</h4><p>线性表的两种存储结构：线性结构(<strong>数组</strong>）和链式结构(<strong>链表</strong>)</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/15.png"></p><p>写链表首先先定义结点！</p><pre><code class="hljs C"><span class="hljs-comment">//结点定义</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;        <span class="hljs-keyword">float</span> score;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">pNext</span>;</span> &#125;;</code></pre><p>新增：头插法，尾插法，有序插入</p><pre><code class="hljs C"><span class="hljs-comment">//结点的声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span>&#125;Student_t,*pStudent_t;<span class="hljs-comment">//头插法  参数是二级指针</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 新结点的next指针指向原有头结点，新结点作为头结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listHeadInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pNew-&gt;num = val;    <span class="hljs-comment">//判断链表是否为空</span>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-comment">//不空，则进行插入</span>    <span class="hljs-keyword">else</span> &#123;        pNew-&gt;next = *head;        *head = pNew;    &#125;&#125;<span class="hljs-comment">//尾插法</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//不空==&gt; 原来尾结点的next指针指向新结点，再将新结点作为尾结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listTailInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStduent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Stduent_t));    pNew-&gt;num = val;    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        (*tail)-&gt;next = pNew;        *tail = pNew;    &#125;&#125;<span class="hljs-comment">//有序插入</span><span class="hljs-comment">//新建结点，插入的值进行初始化，判断链表是否为空？</span><span class="hljs-comment">//若空==&gt; 新结点赋值给头指针，尾指针</span><span class="hljs-comment">//若不为空，如果头结点的值&gt;要插入结点的值==&gt;头插法;如果没有，则遍历链表，找到比插入值大的结点位置，新结点的next指针指向当前结点位置，前一个结点的next指针指向新结点;未找到插入位置，说明要放到链表尾部，尾插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listSortInsert</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    pStudent_t pNew = (pStudent_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Student_t));    pStudent_t pCur,pPre;<span class="hljs-comment">//vs老版本中，定义必须放在前面，不然会错误</span>    pNew-&gt;num = val; <span class="hljs-comment">//进行初始化，不然结果为0</span>    pCur = pPre = *head;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head) &#123;        *head = pNew;        *tail = pNew;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( val &lt; pCur-&gt;num ) &#123;    <span class="hljs-comment">//头插法</span>        pNew-&gt;next = *head;        *head = pNew;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( <span class="hljs-literal">NULL</span> != pCur) &#123;        <span class="hljs-comment">//找到了结点比要插入的结点大，这说明插入这中间</span>            <span class="hljs-keyword">if</span>( pCur-&gt;num &gt; val ) &#123;                pPre-&gt;next = pNew;                pNew-&gt;next = pCur;<span class="hljs-comment">//在这一步之前，要保证前一个结点不能丢失</span>                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//保证pCur向前走，而pPre跟在pCur之后那个位置，即:pPre先赋值成pCur(保存好位置),pCur再走</span>            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有插入到中间，则pCur == NULL,则插入到最后</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            pPre-&gt;next = pNew;            *tail = pNew;        &#125;    &#125;&#125;<span class="hljs-comment">//主函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    pStduent_t phead = <span class="hljs-literal">NULL</span>,pTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) != EOF) &#123;        listHeadInsert(&amp;pHead,&amp;pTail,<span class="hljs-keyword">int</span> num);<span class="hljs-comment">//要将地址进行传入</span>    &#125;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//删除链表中的结点</span><span class="hljs-comment">/*</span><span class="hljs-comment">    判断是否为空==&gt;为空打印，链表为空</span><span class="hljs-comment">    判断删除值是不是头结点==&gt;是的话==&gt;头结点的pNext赋值给头结点，free删除的结点空间，如果删除结点后链表为空，设置尾指针为NULL</span><span class="hljs-comment">    不是的话==&gt;遍历链表，找到要删除的值，将前一个结点的pNext的指针指向删除结点的下一个结点，判断删除结点地址值是否等于尾指针，相等==&gt;说明删除为尾结点，尾指针指向前一个结点，之后free删除的结点；若没有找到删除的结点，打印没有发现删除结点的值</span><span class="hljs-comment">    </span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(pStudent_t *head,pStudent_t *tail,<span class="hljs-keyword">int</span> deleteNum)</span> </span>&#123;    <span class="hljs-comment">//pCur用来指向被删除的结点，一直遍历，pPre指向pCur的前一个结点</span>    pStudent_t pCur = *head,pPre;    pPre = pCur;    <span class="hljs-comment">//判断是否为空</span>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pCur) &#123;        print(<span class="hljs-string">&quot;list is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//删除头部结点</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pCur-&gt;num == deleteNum) &#123;        *head = pCur-&gt;next;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *head ) &#123;            *tail = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-comment">//删除头部或尾部</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>( *head != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span> ( pCur-&gt;next == deleteNum) &#123;                pPre-&gt;next = pCur-&gt;next;                <span class="hljs-keyword">break</span>;            &#125;            pPre = pCur;            pCur = pCur-&gt;next;        &#125;        <span class="hljs-comment">//没有找到对应结点</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == pCur) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find deleteNum\n&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (pCur == *tail) &#123;            *tail = pPre;        &#125;    &#125;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//修改链表中的元素</span><span class="hljs-comment">//并不需要修改头指针，所以传入一级指针就行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listModify</span><span class="hljs-params">(pStudent head,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">float</span> score)</span> </span>&#123;    <span class="hljs-keyword">while</span> ( head != <span class="hljs-literal">NULL</span> ) &#123;        <span class="hljs-keyword">if</span>( head-&gt;num = num) &#123;            head-&gt;socre = socre;        &#125;        head = head-&gt;next;    &#125;    <span class="hljs-keyword">if</span> ( head == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Don&#x27;t find modify num\n&quot;</span>);    &#125;&#125;</code></pre><h4 id="2、常用数据结构和算法"><a href="#2、常用数据结构和算法" class="headerlink" title="2、常用数据结构和算法"></a>2、常用数据结构和算法</h4><p>设计数据结构，就是为了高效管理数据。</p><p>有效的存取方法可提高我们访问数据的效率，即算法</p><p>需要掌握的数据结构</p><p><strong>数组，栈，队列，链表，树，堆，散列表，图…..</strong></p><h5 id="1-、栈-stack"><a href="#1-、栈-stack" class="headerlink" title="(1)、栈(stack)"></a>(1)、栈(stack)</h5><p>后进先出</p><pre><code class="hljs C"><span class="hljs-comment">//栈的定义</span><span class="hljs-comment">//结点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> *<span class="hljs-title">pNext</span>;</span>&#125;Node_t,*pNode_t ;<span class="hljs-comment">//利用链，栈的结构体</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    pNode_t head;    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//栈的大小</span>&#125;Stack_t,pStack_t;<span class="hljs-comment">//一系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//初始化栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//入栈</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//出栈</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStck_t)</span></span>;<span class="hljs-comment">//返回栈的大小</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t)</span></span>;<span class="hljs-comment">//确定栈是否为空</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">stack</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Stack_t));<span class="hljs-comment">//系统内置接口，在&lt;string.h&gt;中，用于将内存初始化某值</span>    <span class="hljs-comment">//是将Stack_t中的分量设置为0的快捷的方法</span>    <span class="hljs-comment">//void *memset( void *buffer, int ch, size_t count );</span>    <span class="hljs-comment">// 拷贝ch到buffer从头开始的count个字符里，并返回buffer指针</span>&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//入栈，头插法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>,<span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-comment">//既然是入栈，肯定是要申请结点空间</span>    pNode_t pNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pNew-&gt;val = val;    pNew-&gt;pNext = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-built_in">stack</span>-&gt;head = pNew;    <span class="hljs-built_in">stack</span>-&gt;size ++;&#125;<span class="hljs-comment">//出栈，头部删除法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-comment">//先判断是否栈为空</span>    pNode_t pCur;<span class="hljs-comment">//因为要删除结点，肯定要free,所以必须要个pCur</span>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//之后进行pop</span>    pCur = <span class="hljs-built_in">stack</span>-&gt;head;    <span class="hljs-comment">//stack-&gt;head = stack-&gt;head-&gt;pNext;</span>    <span class="hljs-built_in">stack</span>-&gt;head = pCur = pCur-&gt;pnext;    <span class="hljs-built_in">free</span>(pCur);    pCur = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//防止野指针</span>    <span class="hljs-built_in">stack</span>-&gt;size --;&#125;</code></pre><pre><code class="hljs C"><span class="hljs-comment">//返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stack</span>-&gt;size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack is empty&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;head-&gt;val;&#125;<span class="hljs-comment">//返回栈的元素个数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>-&gt;size;&#125;<span class="hljs-comment">//判断是否为空</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">empty</span><span class="hljs-params">(pStack_t <span class="hljs-built_in">stack</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">stack</span>-&gt;size;&#125;</code></pre><h5 id="2-、队列"><a href="#2-、队列" class="headerlink" title="(2)、队列"></a>(2)、队列</h5><p>循环队列</p><pre><code class="hljs C"><span class="hljs-comment">//循环队列的定义，利用数组实现</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 5</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType data[MaxSize];    <span class="hljs-keyword">int</span> front,rear;&#125;SqQueue_t;<span class="hljs-comment">//系列接口</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *)</span></span>;<span class="hljs-comment">//初始化队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *,ElemType )</span></span>;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t *,ElemType* )</span></span>;<span class="hljs-comment">//出队,利用了传出参数</span></code></pre><pre><code class="hljs C"><span class="hljs-comment">//初始化循环队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>)</span> </span>&#123;    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-rear = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//入队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(SqQueue_t *<span class="hljs-built_in">queue</span>,ElemType x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否满了</span>    <span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; queue is full\n&quot;</span>);    &#125;    <span class="hljs-comment">//入队，放入x</span>    <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;rear] = x;    <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize;<span class="hljs-comment">//rear向前走</span>&#125;<span class="hljs-comment">//出队</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(SqQueue_t* <span class="hljs-built_in">queue</span>,ElemType *x)</span> </span>&#123;    <span class="hljs-comment">//判断队列是否为空</span>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-built_in">queue</span>-&gt;front ) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty\n&quot;</span>);    &#125;    <span class="hljs-comment">//出队</span>    *x = <span class="hljs-built_in">queue</span>-&gt;data[<span class="hljs-built_in">queue</span>-&gt;front];    <span class="hljs-built_in">queue</span>-&gt;front = ((<span class="hljs-built_in">queue</span>-&gt;rear + <span class="hljs-number">1</span>) % MaxSize)&#125;</code></pre><h5 id="3-、二叉树"><a href="#3-、二叉树" class="headerlink" title="(3)、二叉树"></a>(3)、二叉树</h5><p><strong>每个结点最多有两个子树的树结构！</strong></p><p>二叉树常用于实现 <strong>二叉查找树 和 二叉堆</strong></p><p><strong>层次建树==&gt;辅助队列</strong></p><p>k层，总节点数 2^k - 1</p><p>完全二叉树：只允许最后一层有空缺且在右边。对任一结点，其右子树的深度为j，则左子树深度必为j或j+1,度为1的点只有1个或0个</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<span class="hljs-comment">//结点声明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span></span><span class="hljs-class">&#123;</span>    ElemType c;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pleft</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pright</span>;</span>&#125;Node_t,*pNode_t;<span class="hljs-comment">//2、利用辅助队列进行层次建树</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span></span><span class="hljs-class">&#123;</span>    pNode_t insertPos; <span class="hljs-comment">//要插入结点的位置</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_t</span> *<span class="hljs-title">pNext</span>;</span>&#125;Queue_t,*pQueue_t;<span class="hljs-comment">//接口声明</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//前序遍历==&gt;根左右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//中序遍历==&gt;左根右</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOrder</span><span class="hljs-params">(pNode_t )</span></span>;<span class="hljs-comment">//后序遍历===&gt;左右根</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t*,pQueue_t*,pQueue_t *,<span class="hljs-keyword">int</span> )</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span> )     &#123;        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        <span class="hljs-built_in">putchar</span>(root-&gt;c);        preOrder(root-&gt;pright);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lastOreder</span><span class="hljs-params">(pNode_t root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)    &#123;        preOrder(root-&gt;pleft);        preOrder(root-&gt;pright);        <span class="hljs-built_in">putchar</span>(root-c);    &#125;&#125;<span class="hljs-comment">//2、层次建树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildBinaryTree</span><span class="hljs-params">(pNode_t *treeRoot,pQueue_t *queHead,pQueue_t *queTail,<span class="hljs-keyword">int</span> val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//申请结点</span>    pNode_t treeNew = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));    pQueue_t queNew = (pQueue_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Queue_t));    pQueue_t queCur = *queHead;<span class="hljs-comment">//指向给哪个元素结点放孩子 </span>    treeNew-&gt;c = val;    queNew-&gt;insertPos = treeNew;    <span class="hljs-comment">//判断是否有根节点</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == *treeRoot )    &#123;        *treeRoot = treeNew;        *queHead = queNew;        *queTail = queNew;    &#125;    <span class="hljs-comment">//根节点不为空，找插入位置</span>    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//队列操作，把元素放入队列===&gt;尾插法</span>        (*queTail)-&gt;pNext = queNew;        *queTail = queNew;        <span class="hljs-comment">//判断左子树是否空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pleft )        &#123;            queCur-&gt;inSertPos-&gt;pleft = treeNew;        &#125;        <span class="hljs-comment">//判断右子树是否为空</span>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == queCur-&gt;insertPos-&gt;pright )        &#123;            queCur-&gt;insertPos-&gt;pright = treeNew;            <span class="hljs-comment">//先保存后释放,某个结点左右孩子都有了之后，出队</span>            *queHead = queCur-&gt;pNext;            <span class="hljs-built_in">free</span>(queCur);            queCur = <span class="hljs-literal">NULL</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1、可利用数组进行层次建树</span>    ElemType c[] = <span class="hljs-string">&quot;ABCDEFJHI&quot;</span>;    pNode_t p[N];<span class="hljs-comment">//p为指针数组</span>    <span class="hljs-keyword">int</span> i,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j记住往哪个结点放数据</span>    <span class="hljs-comment">//为每个结点申请空间，同时把结点值放进去</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        p[i] = (pNode_t)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(Node_t));        p[i]-&gt;c = c[i];    &#125;    <span class="hljs-comment">//第一个结点A不需要建立，即A自己也是。故从1开始进入</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;N;i++)<span class="hljs-comment">//外层控制进入的元素</span>    &#123;        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p[j]-&gt;pleft )<span class="hljs-comment">//内层比较，找位置</span>        &#123;            p[j]-&gt;pleft = p[i];<span class="hljs-comment">//为空，则放入</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( NUll == p[j]-&gt;pright )        &#123;            p[j]-&gt;pright = p[i];            j++;<span class="hljs-comment">//插入完之后，跑到B位置等待左右孩子插入其中(j初始为0)</span>        &#125;    &#125;    <span class="hljs-comment">//2、辅助队列进行层次建树</span>    ElemType val;    pNode_t treeRoot = <span class="hljs-literal">NULL</span>;    pQueue_t queHead = <span class="hljs-literal">NULL</span>,queTail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%c&quot;</span>,&amp;val) != EOF)    &#123;        <span class="hljs-keyword">if</span>( val == <span class="hljs-string">&#x27;\n&#x27;</span> ) &#123;            <span class="hljs-keyword">break</span>;        &#125;        BuildBinaryTree(&amp;treeRoot,&amp;queHead,&amp;queTail,val);    &#125;&#125;</code></pre><h5 id="4-、排序算法"><a href="#4-、排序算法" class="headerlink" title="(4)、排序算法"></a>(4)、排序算法</h5><p>时间复杂度和空间复杂 </p><p>时间复杂度====&gt;大O符号表示</p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/16.png"></p><p><strong>掌握八种算法：冒泡，选择，插入，希尔，快排，堆排，归并，基排</strong>.  </p><blockquote><p>插入类：插入排序，希尔排序</p><p>选择类：选择排序，堆排序</p><p>交换类：冒泡排序，快速排序</p><p>归并类：归并排序</p><p>分配类：基数排序、计数排序、桶排序，同额外的空间来分配和收集，继而实现排序</p></blockquote><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/17.png"> </p><p><strong>qsort重点掌握！！！</strong></p><h5 id="lt-1-gt-冒泡"><a href="#lt-1-gt-冒泡" class="headerlink" title="&lt;1&gt;冒泡"></a>&lt;1&gt;冒泡</h5><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">2001 li 45.5 96.5 70.4</span><span class="hljs-comment">2009 liu 98.5 78.5 98.6</span><span class="hljs-comment">2003 lin 78 83.5 79.6</span><span class="hljs-comment">2004 zhang 95 93.5 80.5</span><span class="hljs-comment">2005 wang 88.5 75.7 40.6</span><span class="hljs-comment">*/</span><span class="hljs-comment">/* 冒泡排序</span><span class="hljs-comment">1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><span class="hljs-comment">2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><span class="hljs-comment">3、针对所有的元素重复以上的步骤，除了最后一个。</span><span class="hljs-comment">4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  SWAP(a,b) &#123;int tmp;tmp = a; a = b;b = tmp;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i &lt; N;i++)    &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>;i &lt; N - <span class="hljs-number">1</span> - i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])            &#123;                SWAP(arr[j],arr[j+<span class="hljs-number">1</span>])            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="lt-2-gt-选择"><a href="#lt-2-gt-选择" class="headerlink" title="&lt;2&gt;选择"></a>&lt;2&gt;选择</h5><pre><code class="hljs C"><span class="hljs-comment">/*选择排序</span><span class="hljs-comment">首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</span><span class="hljs-comment">然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span><span class="hljs-comment">以此类推，直到所有元素均排序完毕</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,maxPos;    <span class="hljs-keyword">for</span>(i = N;i&gt;<span class="hljs-number">0</span>;i++)    &#123;        maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>( j = <span class="hljs-number">1</span>;j &lt; i;j++)        &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[maxPos])            &#123;                maxPos = j;            &#125;        &#125;        SWAP(arr[maxPos,arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-3-gt-插入"><a href="#lt-3-gt-插入" class="headerlink" title="&lt;3&gt;插入"></a>&lt;3&gt;插入</h5><pre><code class="hljs C"><span class="hljs-comment">/*认为零号元素自然有序,从1号元素开始插入</span><span class="hljs-comment">先存储插入元素的值，从后向前，依次拿有序序列的值，依次与插入元素的值进行比较</span><span class="hljs-comment">如果有序序列值大于插入元素值，有序序列值向后移动一位，找到插入元素值的位置，将插入元素值放入对应位置</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>;i &lt; N;i++)     &#123;        InsertVal = arr[i];        <span class="hljs-keyword">for</span> (j = i <span class="hljs-number">-1</span>;j &gt;= <span class="hljs-number">0</span>; j--)         &#123;            <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )             &#123;                arr[j + <span class="hljs-number">1</span>] = arr[j];            &#125;            <span class="hljs-keyword">else</span>             &#123;                <span class="hljs-keyword">break</span>;            &#125;            &#125;        arr[j + <span class="hljs-number">1</span>] = InsertVal;        &#125;&#125;</code></pre><h5 id="lt-4-gt-希尔"><a href="#lt-4-gt-希尔" class="headerlink" title="&lt;4&gt;希尔"></a>&lt;4&gt;希尔</h5><pre><code class="hljs C"><span class="hljs-comment">//希尔排序,需要一个步长,步长以长度的1/2开始，每次步长除2减少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrShell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,j,InsertVal,gap;<span class="hljs-comment">//保存要插入的值</span>    <span class="hljs-keyword">for</span>(gap = N &gt;&gt; <span class="hljs-number">1</span>;gap &gt;<span class="hljs-number">0</span>;gap &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-comment">//gap 除以2 ,利用移位可调高效率</span>    &#123;        <span class="hljs-keyword">for</span>( i = gap;i &lt; N;i++)         &#123;            InsertVal = arr[i];            <span class="hljs-keyword">for</span> (j = i -gap;j &gt;= <span class="hljs-number">0</span>; j= j - gap)             &#123;                <span class="hljs-keyword">if</span>( arr[j] &gt; InsertVal )                 &#123;                    arr[j + gap] = arr[j];                &#125;                <span class="hljs-keyword">else</span>                 &#123;                    <span class="hljs-keyword">break</span>;                &#125;                &#125;            arr[j + gap] = InsertVal;            &#125;    &#125;&#125;</code></pre><h5 id="lt-5-gt-快排"><a href="#lt-5-gt-快排" class="headerlink" title="&lt;5&gt;快排"></a>&lt;5&gt;快排</h5><pre><code class="hljs C"><span class="hljs-comment">/*递归进行，开始进行partition划分，选择最后一个元素作为分割值，将比分隔值小的放在分隔值的左边，比分隔值大的放在分隔值的右边，此时分隔值的位置就确定了，故返回分隔值的下标。此时数组一分为二，对前半部分和后半部分继续进行分割，重复操作，进行递归</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i,k;<span class="hljs-comment">//i遍历数组，k记录比右边小的数的位置</span>    <span class="hljs-keyword">for</span>(i = left,k = left;i &lt; right;i++)     &#123;        <span class="hljs-comment">//进行交换</span>        <span class="hljs-keyword">if</span>(arr[right] &gt;  arr[i])        &#123;            SWAP(arr[i],arr[k]);            k++;        &#125;    &#125;    SWAP(arr[k],arr[right]);    <span class="hljs-keyword">return</span> k;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrQuick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span>( left &lt; right )    &#123;        <span class="hljs-keyword">int</span> pivot;        pivot = partition(arr,left,right);        arrQuick(arr,left,pivot - <span class="hljs-number">1</span>);        arrQuick(arr,pivot + <span class="hljs-number">1</span>,right);    &#125;&#125;</code></pre><h5 id="lt-6-gt-堆排"><a href="#lt-6-gt-堆排" class="headerlink" title="&lt;6&gt;堆排"></a>&lt;6&gt;堆排</h5><p>什么是堆===&gt;用数组去存一棵树</p><p>左孩子 son = 2 * dad + 1 (位置而言)</p><p><strong>大根堆(大顶堆)：若父结点的值恒大于等于子结点的值</strong>，若从小到大排序，需要建立大顶堆</p><p><strong>小根堆(小顶堆)：若父结点的值小于等于子结点的值</strong></p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/18.png"></p><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment">    堆排序</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_max_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> adjust_pos,<span class="hljs-keyword">int</span> len)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dad = adjust_pos;    <span class="hljs-keyword">int</span> son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子</span>    <span class="hljs-keyword">while</span>( son &lt; len)    &#123;        <span class="hljs-comment">//可能没右孩子，先判断右孩子是存在及右孩子是否大于左孩子</span>        <span class="hljs-keyword">if</span>( son + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) &#123;            son ++;        &#125;        <span class="hljs-keyword">if</span>(arr[son] &gt; arr[dad]) &#123;            SWAP(arr[son],arr[dad]);            <span class="hljs-comment">//因为一个调整后，可能或影响其他的，导致其他的需要再次调整，所以进行循环调整</span>            <span class="hljs-comment">//把交换完的重新作为dad，再次判断</span>            dad = son;            son = <span class="hljs-number">2</span> * dad + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">//倒着从最后一个父结点开始调整</span>    <span class="hljs-keyword">for</span>( i = N/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> ; i--) &#123;        adjust_max_heap(arr,i,N);    &#125;    <span class="hljs-comment">//接着需要进行有序化</span>    <span class="hljs-comment">//把最后一个结点和根节点交换，接着最后一个结点是最大的，去除！再进行调整</span>    SWAP(arr[<span class="hljs-number">0</span>],arr[N<span class="hljs-number">-1</span>]);     <span class="hljs-keyword">for</span>( i = N - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">1</span> ; i--) &#123;        <span class="hljs-comment">//因为只破坏了根部，所以只需一直调整根部为大根堆</span>        adjust_max_heap(arr,<span class="hljs-number">0</span>,i);        SWAP(arr[<span class="hljs-number">0</span>],arr[i<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h5 id="lt-7-gt-归并"><a href="#lt-7-gt-归并" class="headerlink" title="&lt;7&gt;归并"></a>&lt;7&gt;归并</h5><pre><code class="hljs C"><span class="hljs-comment">//归并</span><span class="hljs-comment">//合并两个有序数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> high)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> b[N];    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i = low;i &lt;= high;i++)    &#123;        b[i] = arr[i];    &#125;    <span class="hljs-keyword">for</span>(k = low,i = low,j = mid + <span class="hljs-number">1</span>;i &lt;= mid &amp;&amp; j&lt;= high;)    &#123;        <span class="hljs-keyword">if</span>(b[i] &lt; b[j])        &#123;            arr[k] = b[i];            k++;            i++;        &#125;        <span class="hljs-keyword">else</span>        &#123;            arr[k] = b[j];            k++;            j++;        &#125;    &#125;    <span class="hljs-keyword">while</span>(i &lt;= mid)    &#123;        arr[k] = b[i];        k++;        i++;    &#125;    <span class="hljs-keyword">while</span>(j &lt;= high)    &#123;        arr[k] = b[j];        k++;        j++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arr_merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">if</span>(low &lt; high)     &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        arr_merge(arr,low,mid);        arr_merge(arr,mid + <span class="hljs-number">1</span>,high);        merge(arr,low,mid,high);    &#125;&#125;</code></pre><h5 id="lt-8-gt-计数排序"><a href="#lt-8-gt-计数排序" class="headerlink" title="&lt;8&gt;计数排序"></a>&lt;8&gt;计数排序</h5><p>空间换时间！====  数据的范围必须是有限的</p><pre><code class="hljs C"><span class="hljs-comment">//申请一个被排序数的范围大小的空间arr_count,遍历数组，统计数组中每个值出现的次数</span><span class="hljs-comment">//遍历arr_count，根据每个值出现的次数，对要排序的数组进行填充</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>     M 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">int</span> arr_count[M] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">//统计出arr数组中，每个值出现的次数</span>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>;i&lt;N;i++)    &#123;        arr_count[arr[i]]++;    &#125;    k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; M;i++)    &#123;        <span class="hljs-keyword">for</span>(j= <span class="hljs-number">0</span> ;j&lt;arr_count[i];j++)        &#123;            arr[k] = i;            k++;        &#125;    &#125;&#125;</code></pre><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/19.png"> </p><p>涉及到磁盘的===&gt;尽可能少读磁盘，速度太慢</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/20.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/21.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/22.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/23.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/24.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/25.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/26.png"> </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>针对有序数组~</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high,<span class="hljs-keyword">int</span> target)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(low &lt;= high)    &#123;        mid = (low + high) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>( arr[mid ] &gt; target)        &#123;            high = mid <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( arr[mid ] &lt; target)        &#123;            low = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><h5 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h5><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/27.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/28_1.png"></p><p><strong>哈希冲突</strong></p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29.png"> </p><p><img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/29_1.png"></p><p>建议用链表法</p><pre><code class="hljs C"><span class="hljs-comment">//哈希查找：通过哈希函数对要找的字符串进行哈希计算，得到key值(数组下标)，通过key去哈希表中得到对应的元素</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxKey 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *key)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//ELF hash函数</span>    <span class="hljs-comment">//下面是公式！冲突会比较少，经验！</span>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>,g;    <span class="hljs-keyword">while</span>( *key )    &#123;        h = (h &lt;&lt; <span class="hljs-number">4</span>) + *key++;        g = h &amp; <span class="hljs-number">0xf0000000</span>;        <span class="hljs-keyword">if</span>(g)         &#123;            h ^= g &gt;&gt; <span class="hljs-number">24</span>;        &#125;        h &amp;= ~g;    &#125;    <span class="hljs-keyword">return</span> h % MaxKey;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_hash</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *pStr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;xiongda&quot;</span>,<span class="hljs-string">&quot;lele&quot;</span>,<span class="hljs-string">&quot;hanmeimei&quot;</span>,<span class="hljs-string">&quot;wangdao &quot;</span>,<span class="hljs-string">&quot;fenghua&quot;</span>&#125;;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *pHash_table[MaxKey] = &#123;<span class="hljs-literal">NULL</span>&#125;;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is key = %d\n&quot;</span>,pStr[i],hash(pStr[i]));        pHash_table[hash(pStr[i])] = pStr[i];    &#125;&#125;</code></pre><h3 id="十、文件操作"><a href="#十、文件操作" class="headerlink" title="十、文件操作"></a>十、文件操作</h3><p><strong>程序执行时成为进程</strong>，进程运行过程中的数据均在内存中。需要存储运算后的数据时，就需要使用文件</p><p>文件是指存储在外部介质(磁盘或磁带)上的数据集合。操作系统是以文件为单位对数据进行管理的</p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/30.png"> </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/31.png"> </p><p>1、文件的打开、读写、关闭  </p><p> <img src="/2021/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/32.png">  </p><pre><code class="hljs C"><span class="hljs-comment">//从文件中读</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> c;    FILE *fp;<span class="hljs-comment">//是结构体指针，系统定义好的</span>    fp = fopen(<span class="hljs-string">&quot;text.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//r表示只读</span>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == fp )    &#123;        perror(<span class="hljs-string">&quot;fopen&quot;</span>);<span class="hljs-comment">//如果指针错误，则利用perror定位错误信息</span>        <span class="hljs-keyword">goto</span> error;    &#125;    <span class="hljs-comment">//把text.txt文件的内容打印到屏幕上</span>    <span class="hljs-keyword">while</span>( (c = fgetc(fp)) != EOF)    &#123;        <span class="hljs-built_in">putchar</span>(c);    &#125;error:    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客的搭建-hexo-github</title>
    <link href="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/"/>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/</url>
    
    <content type="html"><![CDATA[<h2 id="1前提介绍："><a href="#1前提介绍：" class="headerlink" title="1前提介绍："></a>1前提介绍：</h2><p>​    我用的是win10，下面会从win10来介绍，不过mac应该也差别不大</p><p>正式搭建之前，我们先要做好提前的准备</p><h2 id="2需要提前安装的软件："><a href="#2需要提前安装的软件：" class="headerlink" title="2需要提前安装的软件："></a>2需要提前安装的软件：</h2><h3 id="1-、node-js"><a href="#1-、node-js" class="headerlink" title="(1)、node.js"></a><strong>(1)、node.js</strong></h3><p>官网 ：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> </p><p>image-20200811072015514</p><p>点击12.18.3 LTS 根据步骤安装即可，记得勾选添加到环境变量</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-10-24.png" alt="Snipaste_2020-08-11_08-10-24"></p><p>安装之后，打开命令行，即win+r 敲入cmd，进入命令行</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-08-40.png"></p><p>输入：<code>node -v</code> 和 <code>npm -v</code></p><p>​    如图所示</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-05-46.png" alt="Snipaste_2020-08-11_08-05-46"></p><h3 id="2-、git"><a href="#2-、git" class="headerlink" title="(2)、git"></a>(2)、<strong>git</strong></h3><p>(也可以用别的命令行工具，但需要带git，我就用的cmder也可以)</p><p>git官网： <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-12-37.png" alt="Snipaste_2020-08-11_08-12-37"></p><p>cmder官网： <a href="https://cmder.net/">https://cmder.net/</a>    (选择Download  Full)</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-13-33.png" alt="Snipaste_2020-08-11_08-13-33"></p><p>安装完毕之后，就可以在开始菜单看到所安装的东西了</p><p><code>tips：git bash/cmder其实就是相当于linux下的终端窗口，之后就用它来代替win10里面的cmd就行啦</code></p><p>下面正式开始！！！</p><h2 id="3安装hexo"><a href="#3安装hexo" class="headerlink" title="3安装hexo"></a>3安装hexo</h2><p>首先在电脑某位置建立blog文件</p><p>类似这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-21-08.png" alt="Snipaste_2020-08-11_08-21-08"></p><p>之后的操作都在blog文件里面，如果哪儿不行，就可以把blog文件删掉，重新来</p><p>然后在文件夹内用git bash 或cmder 右键打开终端</p><p>输入：</p><p>​     <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code> </p><p>即借用npm安装cnpm的淘宝源~安装之后下载会更快一些</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-16-35.png" alt="Snipaste_2020-08-11_10-16-35"></p><p>可以利用  <code>cnpm</code> 和 <code>cnpm -v</code>   查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-35.png" alt="Snipaste_2020-08-11_08-48-35"></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-48-47.png" alt="Snipaste_2020-08-11_08-48-47"></p><p>则说明成功！</p><p>接着利用cnmp安装hexo</p><p> <code>cnpm install -g hexo-cli</code>      等待…….</p><p>再输入</p><p><code>hexo -v</code></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-51-44.png" alt="Snipaste_2020-08-11_08-51-44"></p><p><strong>则hexo安装成功！！</strong></p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_08-54-17.png" alt="Snipaste_2020-08-11_08-54-17"></p><p>利用 <code>pwd</code>  命令查看一下自己所在的文件位置 ，是否在blog下</p><p>如果是ok，进行初始化 <code>hexo init</code>，接着等待 就行啦</p><p>之后blog文件夹会变成这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-06-14.png" alt="Snipaste_2020-08-11_09-06-14"></p><p>可以在source -&gt; _posts中看到博客的内容，在里面进行创建，是Markdown的形式</p><p>大功告成，进行测试，下面这几个命令我们管理博客经常用到的~</p><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> clean <span class="hljs-comment">#用来清理缓存文件</span>hexo g      <span class="hljs-comment">#生成文件</span>hexo  s     <span class="hljs-comment">#运行本地服务器</span>hexo  d   <span class="hljs-comment">#上传到服务器</span></code></pre><p>终端敲入<code>hexo s</code></p><p>就会看到 4000端口的localhost网址，在浏览器输入，就会看到默认landscape主题的博客</p><p>类似于这样</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-12-33.png"></p><p><strong>本地环境搭建完毕！！！</strong></p><h2 id="4推送到远端"><a href="#4推送到远端" class="headerlink" title="4推送到远端"></a>4推送到远端</h2><p>下面就要推到远端github上，所以需要一个<a href="https://github.com/">github</a>账号</p><p>然后进行注册就好啦~最好name是小写英文，否则好像会出现bug</p><p>可以在account中change name</p><p>创建好之后，create a new repository</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-26-02.png" alt="Snipaste_2020-08-11_09-26-02"></p><p>Repository name 中输入前面Owner的具体名字，再加github.io</p><p>就如：<code>codeheng.github.io</code> 以后就可以利用这个网址访问</p><p>在blog下打开终端，win10输入<code>npm install --save hexo-deployer-git</code></p><p>安装git部署的插件</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-18-46.png" alt="Snipaste_2020-08-11_10-18-46"></p><p>安装完毕后，进行一些设置，博客的基本配置都在<code>_config.yml</code>中，我是用vscode打开的</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-19-37.png" alt="Snipaste_2020-08-11_10-19-37"></p><p>进行如下的修改</p><p>type中内容改为git，<em>注意<strong>冒号后面有一个空格</strong></em></p><p>添加repo：后面是在github中查看</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-45-07.png" alt="Snipaste_2020-08-11_09-45-07"></p><p>最终如图所示：</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_10-12-53.png" alt="Snipaste_2020-08-11_10-12-53"></p><p>接着就可以把本地的部署到远端了，利用<code>hexo d</code>命令，之后输入用户名和密码就成功了！</p><p>如果没有用过git，需要提前输入下面这两行命令，设置名字和邮箱，再进行上述输入</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.name&quot;</span>`git<span class="hljs-built_in"> config </span>--global <span class="hljs-string">&quot;user.email&quot;</span></code></pre><p>到此为止基本结束！只不过主题是默认的~根据自己的喜好更好即可</p><p><img src="/2020/08/11/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-hexo-github/Snipaste_2020-08-11_09-56-14.png" alt="Snipaste_2020-08-11_09-56-14"></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
